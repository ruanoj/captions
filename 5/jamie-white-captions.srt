1
00:00:01,270 --> 00:00:03,062
Welcome to Peer to Peer,

2
00:00:03,190 --> 00:00:06,982
where you can hone your
skills by watching live coding videos.

3
00:00:07,730 --> 00:00:09,737
Our guest today is Jamie White,

4
00:00:10,020 --> 00:00:13,725
who's a Ruby and JavaScript
developer at With Associates

5
00:00:13,760 --> 00:00:17,131
and a co-organizer of the London Ember meetup.

6
00:00:17,150 --> 00:00:19,120
I'm your host, Drew Neil,

7
00:00:19,300 --> 00:00:23,371
And the challenge that I set for
Jamie is called Deducing Collaborations.

8
00:00:23,908 --> 00:00:27,160
DN: OK, Jamie, would you like to
start by reading out the challenge?

9
00:00:27,177 --> 00:00:31,330
JW: OK. Generate a data
structure representing the collaborations

10
00:00:31,330 --> 00:00:34,728
between guests and hosts
in the Peer to Peer catalog.

11
00:00:34,720 --> 00:00:37,617
A collaboration has an
episode, one guest and one host.

12
00:00:37,610 --> 00:00:45,520
It appears in sequence, with an optional
prequel (0 or 1) and optional sequels (0 or more).

13
00:00:45,520 --> 00:00:49,337
Build this data structure from the
data provided as two JSON documents:

14
00:00:49,337 --> 00:00:52,590
episode.json and partners.json.

15
00:00:52,590 --> 00:00:56,720
Render a simple representation
of the data structure in a web browser.

16
00:00:56,906 --> 00:01:02,830
And on page 2, this is
how the sequencing should look.

17
00:01:02,830 --> 00:01:06,697
Episode 1 begins a sequence,
and is followed by Episode 2.

18
00:01:06,690 --> 00:01:09,645
2 follows 1 followed by 5.

19
00:01:09,645 --> 00:01:11,611
3 begins a sequence followed by 4.

20
00:01:11,610 --> 00:01:15,382
And a sequence is connected by guests and hosts.

21
00:01:15,390 --> 00:01:17,188
DN: Effectively yes.

22
00:01:17,200 --> 00:01:22,045
JW: So let's have a look at the data to begin with.

23
00:01:27,060 --> 00:01:29,257
I've already got this stuff.

24
00:01:36,450 --> 00:01:38,777
Let's look at past episodes to begin with.

25
00:01:38,777 --> 00:01:44,170
I'm interested in the ones that
do form parts of sequences already.

26
00:01:45,750 --> 00:01:51,862
We have episode one, where the
host was you and the guest was Tom.

27
00:01:52,900 --> 00:01:54,925
That sequence moves on to two,

28
00:01:54,925 --> 00:02:00,594
where Tom the guest becomes Tom
the host and Camille becomes the guest.

29
00:02:00,840 --> 00:02:04,000
And then this one leads on to here,

30
00:02:04,000 --> 00:02:07,702
where Camille goes from guest
to should have been host.

31
00:02:07,710 --> 00:02:13,497
DN: Yes, unfortunately Camille was
ill today so I'm standing in as host.

32
00:02:14,270 --> 00:02:20,262
In fact, this data is slightly stale.

33
00:02:21,250 --> 00:02:29,428
We could have changed it so that we have
a branch where I interview Tom and also you,

34
00:02:29,485 --> 00:02:32,810
but we're going to pretend
that Camille is acting as host today

35
00:02:32,810 --> 00:02:35,611
and stick with the sample data that we came up with.

36
00:02:35,720 --> 00:02:39,062
We can always adapt it later.

37
00:02:40,080 --> 00:02:46,217
JW: Thinking of the nouns in this description,
the data structure is composed of collaborations.

38
00:02:46,217 --> 00:02:48,630
The description is quite explicit about that.

39
00:02:48,630 --> 00:02:54,560
Now, at the moment, an
episode isn't strictly a collaboration.

40
00:02:54,610 --> 00:02:58,411
A collaboration should have an
episode but not necessarily be an episode.

41
00:02:58,410 --> 00:03:03,211
And the thing that isn't explicit in
this data is the prequels and sequels.

42
00:03:03,220 --> 00:03:07,680
But we know that we can determine
those from the host and guest ids.

43
00:03:07,680 --> 00:03:10,792
[New Chapter]

44
00:03:13,420 --> 00:03:18,274
I am going to use Ember for this.

45
00:03:18,434 --> 00:03:23,120
A bit like reaching for Rails,
I won't use all of it to begin with,

46
00:03:23,154 --> 00:03:26,320
but it gives you plenty of
directions to go in once you're set up.

47
00:03:32,114 --> 00:03:35,245
Let me see what version of Ember CLI I'm running.

48
00:03:35,250 --> 00:03:39,177
Cool... Bleeding edge Ember CLI.

49
00:03:39,200 --> 00:03:44,662
And let's call this peertopeer.

50
00:03:48,900 --> 00:03:52,480
Ember CLI is installing all the
tooling dependencies we need.

51
00:03:52,502 --> 00:03:54,205
DN: OK.

52
00:03:56,200 --> 00:03:59,782
JW: It will take a while, there's quite a few of them.

53
00:03:59,780 --> 00:04:03,920
[Jamie types]

54
00:04:04,020 --> 00:04:10,800
Because I'm using a local copy of
Ember CLI– (I cloned it off Github)...

55
00:04:10,830 --> 00:04:18,960
With npm, what you tend to do when
working on packages that you're adapting is to...

56
00:04:18,971 --> 00:04:23,817
You do npm link and it will
symlink up your copy of the repository

57
00:04:23,817 --> 00:04:27,805
to the node_modules global directory.

58
00:04:28,650 --> 00:04:33,097
I can't use it straight away, I need
to first enter npm link ember-cli,

59
00:04:33,260 --> 00:04:36,560
and that says also use it inside this project.

60
00:04:37,630 --> 00:04:42,674
Now, if you follow the
trail in this local project,

61
00:04:42,685 --> 00:04:48,830
you'll find this symlink
here going to /usr/local/lib/node_modules.

62
00:04:48,830 --> 00:04:52,342
In if we look at that directory

63
00:04:52,370 --> 00:04:59,965
You'll find Ember CLI linked to my
very own copy of it. It's a nicety of npm.

64
00:04:59,965 --> 00:05:02,540
So now we should be able to do ember serve...

65
00:05:02,540 --> 00:05:09,870
[Silence]

66
00:05:09,870 --> 00:05:13,977
DN: That's "lolhost"?
JW: Yup.

67
00:05:14,240 --> 00:05:21,257
Let's just make a quick change to make sure
we're doing what we think we're doing.

68
00:05:21,268 --> 00:05:28,491
[Silence]

69
00:05:28,525 --> 00:05:30,491
OK, it seems to work.

70
00:05:33,540 --> 00:05:45,268
I'm inclined to get the data in first and
get it in the browser and think about it that way.

71
00:05:45,348 --> 00:05:48,400
Pick up the data and put
it down again as many times as possible

72
00:05:48,400 --> 00:05:51,360
until some way to handle it emerges.

73
00:05:54,710 --> 00:06:01,371
Before we get going,
I'm going to install another dependency.

74
00:06:09,560 --> 00:06:14,342
So Ember is about to
undergo some significant improvements,

75
00:06:14,365 --> 00:06:19,680
and this Ember CLI add-on will let us use the future.

76
00:06:22,468 --> 00:06:27,382
And then I need to opt-in to the future.

77
00:06:30,925 --> 00:06:33,565
And I think I want to do that.

78
00:06:37,350 --> 00:06:39,748
I just want to do a quick check.

79
00:06:46,490 --> 00:06:51,771
Ember-htmlbars I want.
And there is another one.

80
00:06:51,771 --> 00:06:56,480
[Silence]

81
00:06:56,530 --> 00:06:59,942
DN: Did you just switch
to the repository for ember.js?

82
00:06:59,965 --> 00:07:02,251
JW: Yes.

83
00:07:04,890 --> 00:07:08,594
So I want these three features.

84
00:07:10,380 --> 00:07:14,971
If you're running on Canary at the
latest build off of master of Ember,

85
00:07:15,680 --> 00:07:20,765
the new things that are coming down
the pipe are hidden behind feature flags.

86
00:07:20,820 --> 00:07:28,400
That allows the core team
to release things incrementally,

87
00:07:28,470 --> 00:07:32,594
but it also allows people to try
them out without breaking the past.

88
00:07:32,690 --> 00:07:36,742
So I want those three things.
And the other thing I want is...

89
00:07:38,617 --> 00:07:44,582
I don't want this stable build of Ember,
I want the Canary build components.

90
00:07:50,857 --> 00:07:53,485
DN: OK, so this is bleeding edge all the way.

91
00:07:53,500 --> 00:07:59,760
JW: Yes, and the reason I think
it's going to be worth while is that

92
00:07:59,780 --> 00:08:07,005
Ember will be changing shortly after we record this,
and I think it's worth seeing what it's about to become.

93
00:08:07,000 --> 00:08:11,520
So I think I want that version of Handlebars.

94
00:08:11,600 --> 00:08:14,594
And that version of Ember.

95
00:08:16,171 --> 00:08:19,440
Let's check that has taken... yes.

96
00:08:22,350 --> 00:08:28,628
I'll just have a look at all these differences.

97
00:08:29,990 --> 00:08:37,497
So bleeding edge Ember opted in to
these new features and included HTMLBars,

98
00:08:37,497 --> 00:08:41,451
which is the next generation template compiler.

99
00:08:41,462 --> 00:08:45,222
I'll just make sure all that actually works.

100
00:08:52,560 --> 00:08:59,108
I've never quite understood this side
of Bower because it doesn't have a lockfile.

101
00:08:59,542 --> 00:09:02,450
It keeps the dependency
resolutions in the same file

102
00:09:02,450 --> 00:09:05,040
in which they were specified in the first place.

103
00:09:11,020 --> 00:09:13,870
There's not a lot of
difference to notice at the moment

104
00:09:13,870 --> 00:09:17,280
but things are better under
the hood for various reasons.

105
00:09:20,570 --> 00:09:22,450
I'm not going to in to tests just yet

106
00:09:22,450 --> 00:09:25,851
because I don't know
quite what the target is at the moment.

107
00:09:25,851 --> 00:09:30,022
I know I want a data structure.
But if it's something I want to display

108
00:09:30,030 --> 00:09:36,822
then I want to let the view lead
me to what would be most useful.

109
00:09:36,940 --> 00:09:39,154
Let's say for the beginning...

110
00:09:40,350 --> 00:09:44,560
Let's just a display a list of episodes.

111
00:09:44,560 --> 00:09:58,902
[Jamie types]

112
00:09:58,900 --> 00:10:02,342
I think that's right.
Oh, it might be with an underscore.

113
00:10:02,340 --> 00:10:11,680
[Silence]

114
00:10:11,730 --> 00:10:18,697
Thinking back to Tom's Peer
to Peer and how often he commits,

115
00:10:18,708 --> 00:10:22,560
I realise that I'm already several
changes in without committing.

116
00:10:22,571 --> 00:10:29,220
Let me just commit my bits of bleeding edge stuff.

117
00:10:30,100 --> 00:10:34,845
DN: I didn't see you create a Git repository.
Was that done for you by the ember generate command?

118
00:10:34,845 --> 00:10:37,451
JW: Yes, ember new creates a repo.

119
00:10:37,470 --> 00:10:42,171
So that's my stuff to get up on the latest Ember.

120
00:10:42,170 --> 00:10:50,560
[Silence]

121
00:10:50,560 --> 00:10:54,605
And partly I want to demonstrate how
easy it is to use the bleeding edge of Ember.

122
00:10:54,628 --> 00:10:59,874
It's modelled after Rails and
Rails's command line tooling.

123
00:10:59,874 --> 00:11:03,760
So it should feel familiar to anyone who knows that.

124
00:11:03,870 --> 00:11:06,834
Check in that change as well.

125
00:11:08,205 --> 00:11:11,371
I'll just see what that is exactly... whoops.

126
00:11:14,460 --> 00:11:17,200
So that at the moment is fine.

127
00:11:17,210 --> 00:11:21,371
It's compiling. It's just that there's
nothing to render because there is no data.

128
00:11:21,394 --> 00:11:23,565
So I'm going to commit that.

129
00:11:23,560 --> 00:11:30,971
[Jamie types]

130
00:11:31,000 --> 00:11:39,040
Let's pull in those files. I've got
them next door. Let's pull them in...

131
00:11:40,130 --> 00:11:43,190
I'm going to pretend they're
coming from an API of some sort.

132
00:11:44,520 --> 00:11:47,405
So we'll put them in.

133
00:11:47,400 --> 00:11:56,091
[Jamie types]

134
00:11:56,130 --> 00:12:01,634
DN: So we now should be able to
fetch them from lolhost/api/episodes.

135
00:12:01,890 --> 00:12:06,045
JW: lolhost is because I always mistype it.

136
00:12:12,770 --> 00:12:16,480
I'll concentrate on episodes for
now because it looks the most like...

137
00:12:18,171 --> 00:12:22,500
I don't have an application route yet.
Routes are where data gets loaded in,

138
00:12:22,500 --> 00:12:27,360
so I will generate one of those... route application.

139
00:12:29,380 --> 00:12:33,325
I don't want to change the
template, but I do want the rest of it.

140
00:12:39,740 --> 00:12:43,908
In my template I wasn't referring to model directly,

141
00:12:43,908 --> 00:12:50,380
I'm referring to the episodes
and I'm going to stick with that.

142
00:12:50,400 --> 00:12:54,148
So what I want to return from here is...

143
00:12:54,170 --> 00:12:58,228
I'm just going to set up some aliases.

144
00:13:01,360 --> 00:13:04,250
I want to return a Promise to load in that data.

145
00:13:04,800 --> 00:13:18,570
So RSPV.hash and this is
episodes, and we need some ajax.

146
00:13:18,594 --> 00:13:24,590
I think I have the ic-ajax library handy.

147
00:13:24,590 --> 00:13:33,188
So what we want to get is
/api/episodes.json

148
00:13:33,680 --> 00:13:37,290
I think that should be enough.

149
00:13:37,290 --> 00:13:40,217
Let's just see if it compiles.

150
00:13:40,594 --> 00:13:41,720
Yes, it seems to.

151
00:13:44,170 --> 00:13:56,194
[Jamie mumbles inaudibly as he types]

152
00:13:56,380 --> 00:14:03,234
I'm going to step back to something that
looks a bit more like the guides.

153
00:14:03,234 --> 00:14:10,000
[Silence]

154
00:14:10,617 --> 00:14:12,640
DN: Oh wow, that was quick.

155
00:14:12,640 --> 00:14:15,520
JW: Yes (laughter).

156
00:14:15,520 --> 00:14:18,514
Oh, of course because ... yes.

157
00:14:18,510 --> 00:14:22,422
DN: The episodes.json is already namespaced.

158
00:14:22,422 --> 00:14:29,222
JW: Yes, I wasn't accounting for
that but it's actually way better.

159
00:14:29,220 --> 00:14:34,937
All you need to do to bring in
the model for this template to render,

160
00:14:34,940 --> 00:14:40,480
is promise that you're going to load it at some
point in the future and the rest will be taken care of.

161
00:14:40,480 --> 00:14:42,982
Let's just look at this template.

162
00:14:45,142 --> 00:14:48,948
Let's emit a little more data about this.

163
00:14:48,940 --> 00:15:02,628
[Silence]

164
00:15:02,640 --> 00:15:06,377
So, what else do we have to work with here?

165
00:15:08,468 --> 00:15:11,954
Guest name, host name, poster frame.

166
00:15:14,502 --> 00:15:17,497
Let's put host first.

167
00:15:17,531 --> 00:15:33,177
[Jamie types]

168
00:15:33,220 --> 00:15:40,137
This is to 'feel out' the data and see what
it suggests as a good way to move forward.

169
00:15:40,137 --> 00:15:42,114
Interestingly...

170
00:15:42,190 --> 00:15:46,685
You won't find this in current Ember,
I'm going to leave off the closing dl tag.

171
00:15:46,680 --> 00:15:53,314
And then what you'll find here
is that the new template compiler

172
00:15:53,460 --> 00:15:58,594
has worked out that I made a
semantic mistake in not closing my dl.

173
00:16:01,691 --> 00:16:03,428
So let's do that.

174
00:16:07,714 --> 00:16:11,382
Should have a bit more display... cool.

175
00:16:13,120 --> 00:16:15,931
I guess I could just...

176
00:16:29,017 --> 00:16:32,194
DN: It should work for all but the last one.

177
00:16:32,220 --> 00:16:34,560
JW: Great.

178
00:16:35,771 --> 00:16:41,120
DN: I don't have a poster frame yet for today's episode.

179
00:16:41,120 --> 00:16:48,720
[Jamie types]

180
00:16:48,971 --> 00:16:51,634
JW: We'll be doing a lot of that.

181
00:17:00,820 --> 00:17:10,685
This data, in a sense tells us everything we need
to know about how to determine a sequence.

182
00:17:12,340 --> 00:17:17,954
What I would like to do is be able to...

183
00:17:17,970 --> 00:17:20,811
If I'm going to create this
collaborators data structure.

184
00:17:20,820 --> 00:17:25,165
I feel like I want to do it in a nice, clean unit test.

185
00:17:25,200 --> 00:17:30,000
Now that I've got that rendering
of the data it's a good place to start.

186
00:17:30,850 --> 00:17:35,062
Let's just commit that.

187
00:17:35,140 --> 00:17:41,485
So I've added a route,
which brings in the episodes data.

188
00:17:41,520 --> 00:17:46,342
I've added some of that data to my
template to make sure I fully understand it.

189
00:17:47,740 --> 00:17:51,497
And I've generated some
boilerplate tests which I'll leave alone.

190
00:17:51,500 --> 00:17:54,744
I don't care too much about them at the moment.

191
00:17:54,750 --> 00:18:06,504
[Silence]

192
00:18:06,520 --> 00:18:09,584
[New Chapter]

193
00:18:12,800 --> 00:18:15,940
Maybe the simplest thing
for now is just to have a function

194
00:18:16,660 --> 00:18:27,222
that does the job of taking these two data sources
and producing all the right things as the output.

195
00:18:27,410 --> 00:18:40,354
If I generate util,
let's call it... build-collaborators...

196
00:18:40,350 --> 00:18:46,868
[Silence]

197
00:18:47,350 --> 00:18:53,040
So that's going to generate
a function in its own module.

198
00:18:53,040 --> 00:19:01,371
[Silence]

199
00:19:01,440 --> 00:19:07,017
So I need a bunch of episodes to feed this thing.

200
00:19:08,160 --> 00:19:11,600
And I might leave the partners to one side for now.

201
00:19:11,600 --> 00:19:17,142
It would be good eventually, if that
data is available that the objects are re-used.

202
00:19:17,154 --> 00:19:20,674
So that if I've got for example, one
record for Tom loaded into memory.

203
00:19:20,690 --> 00:19:24,502
It's always that same
record, wherever I reference it.

204
00:19:24,530 --> 00:19:31,017
Let's just see if the sequencing
does what we would expect for the moment.

205
00:19:32,822 --> 00:19:36,880
I'm just going to refer to this again.

206
00:19:38,760 --> 00:19:43,062
Episode 1 begins the sequence,
therefore it has no prequel.

207
00:19:43,074 --> 00:19:46,228
but it has one sequel.

208
00:19:46,360 --> 00:19:49,725
Oh no, it has two sequels according to this data.

209
00:19:49,730 --> 00:19:53,165
Episode 1 is followed by both 2...

210
00:19:53,160 --> 00:19:58,617
So episode one is followed just by 2 and 2 is followed by 5

211
00:19:59,420 --> 00:20:01,885
Are there any that have 2 sequels?

212
00:20:01,897 --> 00:20:08,910
DN: Not yet, but I think we could easily
adapt our data to accommodate that later.

213
00:20:09,270 --> 00:20:15,310
JW: OK. So let's take some of what's in this data here.

214
00:20:19,140 --> 00:20:21,750
So the episodes we're passing in are:

215
00:20:21,750 --> 00:20:35,005
[Silence]

216
00:20:35,160 --> 00:20:38,411
Let's get the prequel side of things working first.

217
00:20:38,420 --> 00:20:41,268
The challenge being...

218
00:20:42,400 --> 00:20:48,080
Let's just base this entirely on the
ids I used to begin with... So host_ud:1

219
00:21:15,790 --> 00:21:22,708
I want to know when
I build collaborators out of this:

220
00:21:25,291 --> 00:21:27,771
So these episodes...

221
00:21:29,150 --> 00:21:33,851
Basically, I want a data structure
that's exactly as described in here.

222
00:21:36,130 --> 00:21:38,548
So I want something that looks like...

223
00:21:38,540 --> 00:21:41,062
I'll just take away this OK.

224
00:21:41,060 --> 00:21:53,051
[Jamie types]

225
00:21:53,350 --> 00:21:56,360
What I'm expecting to get
at the other end is episode...

226
00:21:57,780 --> 00:22:00,350
It's going to look a bit like...

227
00:22:00,350 --> 00:22:08,091
[Silence]

228
00:22:08,330 --> 00:22:10,571
Like that.

229
00:22:10,570 --> 00:22:17,657
[Jamie thinks]

230
00:22:17,657 --> 00:22:23,360
Let's just deal with the sequels.

231
00:22:25,860 --> 00:22:28,674
This is an interesting aspect,

232
00:22:30,800 --> 00:22:33,360
If they point at each other...

233
00:22:34,777 --> 00:22:37,405
Let's find out.

234
00:22:39,430 --> 00:22:41,474
It could get cyclic

235
00:22:41,485 --> 00:22:43,211
DN: Yes, that's possible.

236
00:22:43,222 --> 00:22:48,377
JW: So this collaboration is
going to point to the next one.

237
00:22:48,380 --> 00:22:53,062
via sequel which is going to point
back to this one, via prequel.

238
00:22:53,130 --> 00:22:59,360
So I can't really expand out that..
They will have to refer to each other by an id I think.

239
00:22:59,390 --> 00:23:00,331
DN: Right.

240
00:23:00,360 --> 00:23:03,540
So you don't want this one containing its sequels?

241
00:23:03,670 --> 00:23:07,314
JW: Not necessarily...
[Jamie and Drew talk at the same time]

242
00:23:09,480 --> 00:23:12,114
It would look like...

243
00:23:12,130 --> 00:23:24,520
[Silence as Jamie types]

244
00:23:24,980 --> 00:23:28,057
So this is an episode and
it would have this one sequel.

245
00:23:28,050 --> 00:23:34,537
But then this would have a prequel, which is...

246
00:23:34,548 --> 00:23:36,640
this one again which contains sequels.

247
00:23:42,380 --> 00:23:53,097
Maybe what I want is to simply append the id of
the prequel and ids of sequels onto these episodes.

248
00:23:53,300 --> 00:23:57,805
Otherwise it will become this cyclic thing.

249
00:24:01,325 --> 00:24:04,380
Say instead that I do get episodes back...

250
00:24:04,388 --> 00:24:07,600
I get the same two episodes but with a bit more data.

251
00:24:58,990 --> 00:25:02,228
I guess we should run some tests against this.

252
00:25:02,251 --> 00:25:07,257
Let's ditch that server for now and get a test server.

253
00:25:15,554 --> 00:25:19,325
I've got no need to see the container just now.

254
00:25:19,337 --> 00:25:22,450
That's interesting,
I'm being told I've got a jshint error.

255
00:25:36,330 --> 00:25:44,034
It's telling me that the results are just true
because I've not written a line of this method yet.

256
00:25:44,548 --> 00:25:48,460
And this is the data that's expected so let's start by...

257
00:25:51,840 --> 00:25:55,497
Rather than returning true from this let's go:

258
00:25:57,020 --> 00:26:01,485
Let's return the episodes back
and make it an identity function.

259
00:26:02,380 --> 00:26:04,130
Let's see what the diff looks like.

260
00:26:05,250 --> 00:26:08,182
I'm missing the prequel and sequel ids.

261
00:26:08,230 --> 00:26:09,890
DN: So we're close.
JW: Yes.

262
00:26:09,890 --> 00:26:15,588
[Jamie thinks]

263
00:26:15,580 --> 00:26:23,474
JW: If we take this list of episodes.
We want to reduce it to some result.

264
00:26:23,485 --> 00:26:28,937
[Silence]

265
00:26:28,930 --> 00:26:33,462
The result is another list.

266
00:26:34,210 --> 00:26:38,880
Each time we hit an episode
we can figure out what its...

267
00:26:38,880 --> 00:26:43,748
[Jamie thinks]

268
00:26:43,770 --> 00:26:50,902
We've got a temporal advantage which is
that our list of episodes are in order of time,

269
00:26:50,920 --> 00:26:57,657
and therefore a prequel isn't going
to appear after one of its sequels.

270
00:26:57,680 --> 00:26:58,605
DN: Yes, that's true.

271
00:26:58,640 --> 00:27:01,348
JW: Although if they did come in
a different order this would break down.

272
00:27:01,348 --> 00:27:03,050
But let's just go for this to start with.

273
00:27:03,050 --> 00:27:06,377
DN: That's a safe assumption for now at least.

274
00:27:06,480 --> 00:27:08,200
JW: Yes. So let's say:

275
00:27:08,200 --> 00:27:12,742
[Jamie types]

276
00:27:12,750 --> 00:27:17,131
I need to figure out what its prequel id is.

277
00:27:17,140 --> 00:27:21,977
I'm looking for something in
the list of episodes, that has...

278
00:27:22,000 --> 00:27:24,800
I'll pseudo code this for a second.

279
00:27:24,830 --> 00:27:29,142
It's a prequel if my current
host was guest on that episode.

280
00:27:29,748 --> 00:27:34,605
So episode.host_id

281
00:27:40,994 --> 00:27:43,862
[Inaudible]

282
00:27:52,030 --> 00:27:55,330
This isn't going to be very efficient algorithmically,

283
00:27:55,330 --> 00:27:58,060
but it's a small list so it shouldn't matter too much.

284
00:27:58,180 --> 00:28:10,868
So we want to find an episode whose
guest id matches this episode's host id.

285
00:28:10,860 --> 00:28:22,422
I think that's correct at the moment,
we will push that on to our result.

286
00:28:22,770 --> 00:28:29,737
DN: I think that find by is going to return
a record isn't it? You're assigning that to prequel id.

287
00:28:29,737 --> 00:28:32,200
JW: You're absolutely right.

288
00:28:33,070 --> 00:28:36,502
Let's make sure we actually get a prequel first.

289
00:28:44,410 --> 00:28:51,062
I'm mutating the episode that has been
passed in. I want to make a shallow copy of it.

290
00:28:51,200 --> 00:28:53,051
But we'll deal with that in a second.

291
00:28:53,050 --> 00:28:54,777
So prequel_id equals...

292
00:28:54,770 --> 00:29:01,280
[Silence]

293
00:29:01,290 --> 00:29:04,377
Let's see what effect that has.

294
00:29:04,388 --> 00:29:08,480
Sure enough we do have
a prequel id on one of them.

295
00:29:10,491 --> 00:29:12,460
It's a weird diff to read.

296
00:29:14,110 --> 00:29:16,697
DN: The second one looks right.

297
00:29:16,950 --> 00:29:21,920
JW: Yes, I think this is cool, I've got
prequel id, it's just commas it's confused about.

298
00:29:21,940 --> 00:29:25,200
OK, so let's try the
same thing with sequels.

299
00:29:28,460 --> 00:29:32,274
Rather than find by we will use filter by.

300
00:29:32,380 --> 00:29:37,542
I'll refer to the docs for these methods,
just to show you where I'm getting them from.

301
00:29:37,550 --> 00:29:43,394
These are extensions to the
array prototype that Ember adds

302
00:29:43,430 --> 00:29:50,308
You don't have to opt in to extensions,
you can leave them on the floor

303
00:29:50,320 --> 00:29:54,060
if you don't want your
core objects monkey-patched.

304
00:29:54,290 --> 00:29:57,965
But they are so useful most of the time.

305
00:29:58,010 --> 00:30:03,394
So a sequel is an episode whose
host id, is equal to our guest ID.

306
00:30:03,428 --> 00:30:10,617
[Silence]

307
00:30:10,730 --> 00:30:14,205
And with this one...

308
00:30:14,260 --> 00:30:19,200
Because we know it's always a list,
we don't need to check so much.

309
00:30:23,657 --> 00:30:29,485
We can do a map by,
its another thing that Ember provides.

310
00:30:29,828 --> 00:30:32,480
I'll just break this out a bit.

311
00:30:32,662 --> 00:30:35,577
I'll probably one line that.

312
00:30:36,240 --> 00:30:39,222
Let's see what's the difference here.

313
00:30:39,330 --> 00:30:41,500
DN: It's only the "prequel_id": null.

314
00:30:44,811 --> 00:30:48,700
JW: Yes, it's undefined instead rather than null.

315
00:30:48,700 --> 00:30:55,062
[Jamie types]

316
00:30:55,080 --> 00:30:59,188
So rather than expecting null, let's just say
the key isn't even there.

317
00:30:59,180 --> 00:31:03,062
That's our data structure.

318
00:31:03,062 --> 00:31:06,860
So yes we could now...

319
00:31:06,868 --> 00:31:10,662
Let me commit this.

320
00:31:10,720 --> 00:31:12,822
See what new stuff we've got.

321
00:31:12,880 --> 00:31:15,817
I fixed a JSHint error so...

322
00:31:15,810 --> 00:31:36,800
[Silence]

323
00:31:36,834 --> 00:31:39,230
DN: You're making your commits granular there.

324
00:31:39,230 --> 00:31:40,834
JW: Yes.

325
00:31:40,850 --> 00:31:45,794
I'm not always the best at
this, but it's such good practice.

326
00:31:46,440 --> 00:31:49,400
It's probably the best habit
you can get into as a programmer.

327
00:31:50,530 --> 00:31:53,245
Let's have a quick look at what this did.

328
00:31:53,650 --> 00:31:58,102
So I've got this
inefficient object mutating function.

329
00:31:58,130 --> 00:32:04,902
It's not a very pure function, but it does
help us work out what the algorithm is

330
00:32:04,902 --> 00:32:08,148
and what it's trying to produce.

331
00:32:08,240 --> 00:32:10,948
I'll commit this.

332
00:32:13,820 --> 00:32:19,817
So Add buildCollaborators util function.

333
00:32:21,540 --> 00:32:30,788
And then I fancy giving it a quick refactor,
to make sure that they can be refactored.

334
00:32:31,190 --> 00:32:34,180
Avoid this nasty mutation.

335
00:32:35,090 --> 00:32:38,788
Ideally, what I want is...

336
00:32:39,830 --> 00:32:43,600
Rather than using the
original episode let's copy it.

337
00:32:45,750 --> 00:32:50,582
This will be a shallow copy so it will be a new object.

338
00:32:50,620 --> 00:32:53,920
but the values for each of
the fields should be the same.

339
00:33:01,780 --> 00:33:09,142
Right, so this is telling me I've not imported Ember, and I'm going to try to use it here.

340
00:33:09,140 --> 00:33:15,257
This is all using the ES6 module syntax which
assumes you don't want things off the global scope.

341
00:33:15,462 --> 00:33:18,160
So you want something
you have to import it.

342
00:33:18,171 --> 00:33:21,497
So let's import Ember from the Ember package.

343
00:33:25,417 --> 00:33:28,720
OK cool, so that still works.

344
00:33:28,780 --> 00:33:31,920
Let's see if there's anything
else that can be tidied up there.

345
00:33:31,920 --> 00:33:33,600
I think there isn't.

346
00:33:33,650 --> 00:33:37,440
I was talking about the temporal problem earlier...

347
00:33:38,180 --> 00:33:43,348
If a sequel or a prequel appeared
elsewhere, out of order, it might not find it.

348
00:33:43,370 --> 00:33:48,605
But because we're looking over the entire
list of episodes each time that doesn't matter.

349
00:33:48,650 --> 00:33:52,457
If we wanted to make this
more efficient we could assume that

350
00:33:52,468 --> 00:33:57,554
a sequel won't appear earlier up the list
and you can only search after this point.

351
00:33:57,600 --> 00:34:00,571
But there's very little need in this case.

352
00:34:00,730 --> 00:34:01,680
So let's just add:

353
00:34:01,680 --> 00:34:16,640
[Jamie types]

354
00:34:16,994 --> 00:34:20,080
[New Chapter]

355
00:34:20,160 --> 00:34:23,394
So now we've got that let's...

356
00:34:24,910 --> 00:34:27,337
Let's go for another test.

357
00:34:27,350 --> 00:34:30,582
I want to know that...

358
00:34:32,250 --> 00:34:35,428
I guess that what might be a good thing to do...

359
00:34:36,890 --> 00:34:42,274
A way to represent this in HTML, could just be links.

360
00:34:42,990 --> 00:34:46,040
So jumping back and
forth between different episodes

361
00:34:46,040 --> 00:34:50,285
and making sure that
sequence is maintained correctly.

362
00:34:51,942 --> 00:34:54,800
Let's see what's the best way to do this.

363
00:34:57,230 --> 00:35:04,171
I'm going to side step the problem of mocking
out the data under test because our data is static.

364
00:35:04,194 --> 00:35:10,640
and instead I'm going to say...
Let's make an acceptance test

365
00:35:10,730 --> 00:35:17,314
and we'll call this walking-a-sequence.

366
00:35:20,560 --> 00:35:27,645
It should generate me a failing test, although this
test isn't going to mirror what we actually want.

367
00:35:27,650 --> 00:35:33,542
You'll notice, it's trying to
look up the URL walking sequence.

368
00:35:33,550 --> 00:35:36,868
DN: It wants to live in a world of URLs.

369
00:35:36,860 --> 00:35:46,937
[Silence]

370
00:35:46,940 --> 00:35:57,988
JW: The way to prove this works is
go to the home of the representation,

371
00:35:58,670 --> 00:36:01,977
see a list of people who
have played a part in Peer to Peer,

372
00:36:02,160 --> 00:36:05,988
click on somebody's name and
see the episode they first appeared in.

373
00:36:05,980 --> 00:36:11,577
And then see the sequels and
be able to follow to a sequel.

374
00:36:11,577 --> 00:36:13,485
DN: OK yes.

375
00:36:13,480 --> 00:36:16,834
Yes I think that makes sense.

376
00:36:17,230 --> 00:36:21,650
So I want to be able to click on Tom and see the...

377
00:36:24,994 --> 00:36:27,880
I'll remind myself what the name of the episode was.

378
00:36:28,820 --> 00:36:32,525
Counting Tree Nodes, where he was the host,

379
00:36:32,720 --> 00:36:38,537
and be able to see all the sequels to the episode.

380
00:36:38,540 --> 00:36:44,148
Click on those to follow through,
and then be able to click back to the prequel.

381
00:36:44,770 --> 00:36:49,885
I think the most logical way to represent
the sequence is probably via via links.

382
00:36:49,920 --> 00:36:51,290
DN: Yes, OK.

383
00:36:52,370 --> 00:37:02,754
What would be nice later is to find a way to
represent the whole graph In one visual snapshot.

384
00:37:02,820 --> 00:37:10,914
But this is a useful way to test
being able to pull all the data in.

385
00:37:12,030 --> 00:37:19,485
Let's call this one walking from Tom to Camille.

386
00:37:19,510 --> 00:37:22,868
Let's start by visiting the home of the app.

387
00:37:33,490 --> 00:37:38,891
And click on a link that
contains the words Tom Stuart.

388
00:37:41,410 --> 00:37:44,857
What we are expecting is that...

389
00:37:44,850 --> 00:37:48,285
[Jamie thinks]

390
00:37:48,290 --> 00:37:53,520
At that point we should see...
Maybe it should just be an episode.

391
00:37:55,170 --> 00:38:02,605
I guess what I want to do is go from the tree
episode to the Poker ranks episode and back again.

392
00:38:04,754 --> 00:38:20,110
[Silence]

393
00:38:20,120 --> 00:38:24,731
DN: I suppose another way to look at this is
rather than starting with a list of all the people,

394
00:38:24,742 --> 00:38:30,091
you could start with a list of all
the episodes that have no prequels.

395
00:38:30,102 --> 00:38:37,554
Which at the moment, Tom's episode
has no prequel and neither has Ollie's episode.

396
00:38:37,580 --> 00:38:43,268
JW:  That sounds good, that
sounds like what I was flailing for.

397
00:38:43,394 --> 00:38:45,980
DN:  If we did have a list of all the people...

398
00:38:46,020 --> 00:38:48,590
JW: Some of those people
don't have root episodes.

399
00:38:49,090 --> 00:38:53,371
Everyone has an episode
that they first appeared on.

400
00:38:53,410 --> 00:38:55,120
Yes, OK let's do that then.

401
00:38:55,140 --> 00:38:59,965
We want the root episodes,
of the different sequences.

402
00:39:00,040 --> 00:39:04,937
Counting Tree Nodes is one of those
roots. That feels like a thing we click on.

403
00:39:05,700 --> 00:39:11,394
So when we've clicked on
Counting Tree Nodes we expect to end up on...

404
00:39:12,250 --> 00:39:17,337
See what we can ask about
this... the state you've ended up in.

405
00:39:17,360 --> 00:39:21,782
We could ask something about the
URL I think that might be useful.

406
00:39:21,780 --> 00:39:30,136
We can ask "is the current path equal
to episode 2", which I believe is Poker Hands.

407
00:39:33,410 --> 00:39:41,000
The other thing I want to know is does
this episode contain a link back to its prequel.

408
00:39:43,880 --> 00:39:53,820
So I want a link whose href is episodes 1.

409
00:39:53,890 --> 00:39:58,504
DN: So if we're starting on the home page and
we click a link that says Counting Tree Nodes.

410
00:39:58,500 --> 00:40:04,864
That is episode 1 itself. So wouldn't we end
up with currentPath() being /episodes/1.

411
00:40:05,050 --> 00:40:08,144
JW: Oh yes, of course, you're right.

412
00:40:10,560 --> 00:40:13,856
Then I'd expect to be able to click a link, of course.

413
00:40:13,860 --> 00:40:15,808
I'll get there eventually.

414
00:40:15,800 --> 00:40:27,208
[Silence]

415
00:40:27,312 --> 00:40:29,528
We expect to be able to visit the home page,

416
00:40:29,520 --> 00:40:32,256
click on Counting Tree Nodes
then click on Ranking Poker Hands.

417
00:40:34,700 --> 00:40:38,784
Maybe we could say at certain
points what URL we expect to be on.

418
00:40:40,990 --> 00:40:43,592
It doesn't matter too much.

419
00:40:45,150 --> 00:40:48,904
I'm trying to tell the story of walking
backwards and forwards through a sequence.

420
00:40:48,970 --> 00:40:53,152
To get some confidence
that we've set things up right.

421
00:40:53,168 --> 00:40:59,928
[Jamie types]

422
00:40:59,940 --> 00:41:03,288
Let's leave it like this for now, and see where this leads.

423
00:41:03,450 --> 00:41:09,368
DN: So we're staring at the top level in
the directory of episodes that have no prequel.

424
00:41:09,380 --> 00:41:13,184
And then we click the first one which
is Counting Tree Nodes and that has a sequel,

425
00:41:13,190 --> 00:41:15,168
which is episode 2 Ranking Poker Hands?

426
00:41:15,176 --> 00:41:16,440
JW: Yes.

427
00:41:17,730 --> 00:41:21,648
See what kind of errors...

428
00:41:21,680 --> 00:41:25,232
DN:  It doesn't like the URL walking a sequence.

429
00:41:25,496 --> 00:41:27,136
JW: Let's find out.

430
00:41:27,144 --> 00:41:28,896
DN: How did it end up there?

431
00:41:28,910 --> 00:41:31,304
JW: That's a very good question.

432
00:41:34,130 --> 00:41:38,712
Anyway, the failure is that there is
no link containing Counting Tree Nodes.

433
00:41:39,560 --> 00:41:42,576
So let's head over to this template

434
00:42:04,880 --> 00:42:14,584
We want to link to a root episode.

435
00:42:14,890 --> 00:42:19,000
And the model we want to pass
in for it is this episode here.

436
00:42:19,000 --> 00:42:34,208
[Jamie types and mumbles]

437
00:42:34,880 --> 00:42:39,230
We need to deliver this data down.

438
00:42:39,870 --> 00:42:44,256
DN: So do we need a rootEpisodes function?

439
00:42:45,970 --> 00:42:50,024
JW: We could say that the model
for the application is the root episodes.

440
00:42:50,030 --> 00:42:52,536
So if we did that...

441
00:42:52,560 --> 00:42:57,528
Now it's getting stuck for some reason and...

442
00:43:00,400 --> 00:43:04,872
I'm going to do something to the
model before handing it over, so let's say

443
00:43:04,904 --> 00:43:34,344
[Jamie types and mumbles]

444
00:43:34,770 --> 00:43:39,800
The first test is passing so let's see
what the world looks like at this point.

445
00:43:39,808 --> 00:43:47,140
[Silence]

446
00:43:47,140 --> 00:43:49,960
So now we're expecting...

447
00:43:49,960 --> 00:43:52,560
It should be the same list of episodes actually.

448
00:43:52,560 --> 00:43:57,544
[Silence]

449
00:43:57,560 --> 00:44:01,577
DN: Ah yes, because
buildCollaborators does return the full list.

450
00:44:01,792 --> 00:44:05,184
We don't yet have
something that just returns the roots.

451
00:44:05,180 --> 00:44:09,360
[Jamie thinks]

452
00:44:09,590 --> 00:44:14,600
That's interesting, we're passing
something into it that it doesn't understand.

453
00:44:14,616 --> 00:44:24,432
[Silence]

454
00:44:24,750 --> 00:44:32,136
That's curious, I wonder if undefined is not
a function: what's the exact stacktrace of that?

455
00:44:34,960 --> 00:44:36,840
build-collaborators line 8

456
00:44:36,840 --> 00:44:46,288
[Silence]

457
00:44:46,290 --> 00:44:49,970
That is probably slightly
adrift of where it really is.

458
00:44:50,800 --> 00:44:59,590
So lets see...

459
00:44:59,870 --> 00:45:02,488
Oh, I know what I've done, again.

460
00:45:03,870 --> 00:45:05,976
Let's call this data.

461
00:45:12,290 --> 00:45:14,352
DN: Unpack it.
JW: Yes.

462
00:45:15,800 --> 00:45:17,930
Now we've got a different kind of failure...

463
00:45:17,930 --> 00:45:23,016
I'm going back to the test at this point
rather than relying on the running application.

464
00:45:23,010 --> 00:45:37,432
[Silence]

465
00:45:37,440 --> 00:45:42,376
It's not bubbling up, but the error is
that we try and link to a root called episode,

466
00:45:42,370 --> 00:45:47,008
but we've not yet said what
that root is or where it lives. So let's do that.

467
00:45:47,240 --> 00:45:49,150
Before we do that let's...

468
00:45:49,160 --> 00:46:25,008
[Jamie types and mumbles]

469
00:46:25,080 --> 00:46:28,880
I'm happy to lump all those together as one commit.

470
00:46:32,000 --> 00:46:42,224
Use buildCollaborators and emit episode links.

471
00:46:45,740 --> 00:46:49,936
There's no root just yet so let's get that working.

472
00:46:55,760 --> 00:47:04,880
So the path to this route... is going to be that.

473
00:47:07,070 --> 00:47:09,430
Let's see what kind of difference that makes.

474
00:47:09,990 --> 00:47:11,984
Cool, now on to the next.

475
00:47:11,980 --> 00:47:14,888
[Jamie thinks]

476
00:47:15,088 --> 00:47:19,384
Right now, there's no visible
link to Counting Tree Nodes on here.

477
00:47:19,390 --> 00:47:24,912
And technically we're on root,
which doesn't do very much.

478
00:47:24,940 --> 00:47:26,770
And there's only the template for it.

479
00:47:29,940 --> 00:47:34,768
I'll have a running version of the
app to look at, alongside the tests.

480
00:47:34,930 --> 00:47:37,128
DN: OK.

481
00:47:48,450 --> 00:47:51,120
Oh that's curious,
I wonder whether I...

482
00:47:51,120 --> 00:48:06,360
[Silence]

483
00:48:06,380 --> 00:48:08,616
Oh that's interesting.

484
00:48:08,620 --> 00:48:10,680
Oh right yes.

485
00:48:11,990 --> 00:48:17,936
I'm going to do a bit of a maneuver here.

486
00:48:18,520 --> 00:48:24,520
Right now the episodes...
let me have a look at the tree roots again.

487
00:48:24,930 --> 00:48:28,968
There's an application root
which is at the top root of everything.

488
00:48:28,980 --> 00:48:29,550
DN: OK.

489
00:48:29,550 --> 00:48:32,472
The episode route will be rendered inside of it.

490
00:48:32,490 --> 00:48:39,736
And I decide where I want it rendered
using outlet, so I will put the outlet here.

491
00:48:39,730 --> 00:48:45,000
But I want the main list of episodes to
go away when I step into an individual one.

492
00:48:45,000 --> 00:48:47,968
So, let's say app/templates/index

493
00:48:48,872 --> 00:48:54,860
Which is a route you get
for free you don't have to define it.

494
00:48:55,910 --> 00:48:58,560
And it should inherit its model from its parents.

495
00:48:59,450 --> 00:49:02,184
That change, I wouldn't expect to do very much.

496
00:49:02,720 --> 00:49:06,500
I could be wrong, that's
why all the tests are breaking.

497
00:49:09,416 --> 00:49:12,050
That looks the same.

498
00:49:14,050 --> 00:49:18,984
I think it might be a case
of too many changes at once.

499
00:49:19,272 --> 00:49:22,088
DN: Your test error is quite fragile I see.

500
00:49:22,110 --> 00:49:26,432
JW: It is yes, but that is
probably because we're on a...

501
00:49:27,880 --> 00:49:30,070
I know that at this point in time

502
00:49:30,070 --> 00:49:36,160
the CLI is operating to a new file
watching strategy, so that may be part of it.

503
00:49:36,180 --> 00:49:39,688
It's probably still going through growing pains.

504
00:49:41,950 --> 00:49:46,232
So now we're on roughly the same point I think.

505
00:49:52,570 --> 00:49:54,256
I'll take one of these.

506
00:49:54,290 --> 00:49:59,208
We've got the right URL, there's nothing to
display, because there's no template just yet.

507
00:49:59,220 --> 00:50:04,568
So let's make a template for this route.

508
00:50:04,616 --> 00:50:06,960
In fact, let's just generate a route.

509
00:50:20,220 --> 00:50:23,560
So I've added that other route.
It doesn't want to display yet.

510
00:50:23,590 --> 00:50:28,320
That is the right direction to head in.

511
00:50:28,320 --> 00:50:31,280
So if I add everything in app/

512
00:50:31,280 --> 00:50:38,896
[Silence]

513
00:50:38,912 --> 00:50:42,272
I think these are all part of one step.

514
00:50:54,610 --> 00:50:56,312
So far there's not much here.

515
00:50:56,320 --> 00:51:04,896
What we ideally want is to be able to go
from episode and refer that to that acceptance test.

516
00:51:06,640 --> 00:51:10,936
We're expecting to find another link at
this point with Ranking Poker Hands on it.

517
00:51:14,120 --> 00:51:19,944
DN: So the list you are doing now,
is a list of sequels for the current episode?

518
00:51:20,304 --> 00:51:25,160
JW: Yes, so let's say
model.sequels as |sequel|

519
00:51:25,160 --> 00:51:33,130
[Jamie types]

520
00:51:33,130 --> 00:51:40,384
And we'll do the same kind of thing,
link-to sequel.challenge_name.

521
00:51:42,048 --> 00:51:49,600
[Jamie types and mumbles]

522
00:51:49,600 --> 00:51:52,512
DN; So that's the name of the route episode?

523
00:51:53,520 --> 00:52:00,104
JW: Yes, the name of the episode,
the route and the actual instance of them.

524
00:52:00,100 --> 00:52:02,520
And the model we want for that route.

525
00:52:06,720 --> 00:52:12,288
I think my buildCollaborators function
might not be the thing I wanted after all, but...

526
00:52:12,768 --> 00:52:20,352
Jamie and Drew laugh and Jamie thinks again.

527
00:52:20,400 --> 00:52:23,144
I might just...

528
00:52:23,144 --> 00:52:25,140
[Jamie types]

529
00:52:27,550 --> 00:52:30,056
I'll just check out...

530
00:52:30,050 --> 00:52:40,536
[Silence]

531
00:52:40,536 --> 00:52:43,420
DN: Your going to switch to different Ember CLI?

532
00:52:43,420 --> 00:52:51,575
JW: Yes, I'm going to go to last stable releases.
I have a feeling this is the cause of my problem so...

533
00:52:52,160 --> 00:52:54,680
Narrator: We're going to speak through this section.

534
00:52:54,704 --> 00:52:57,848
We spent almost 10
minutes troubleshooting this issue.

535
00:52:57,850 --> 00:53:02,544
But, switching to the latest stable release
of Ember CLI didn't fix the tests however.

536
00:53:03,920 --> 00:53:07,584
Narrator: We'll pick up again where
Jamie came up with a 'workaround'.

537
00:53:08,370 --> 00:53:13,048
JW: Unfortunately, in the current build of Ember CLI,

538
00:53:13,048 --> 00:53:16,736
or rather the current master build of Ember CLI,

539
00:53:16,770 --> 00:53:23,456
some aspects when rapidly re-loading
files, causes the build to fall over.

540
00:53:23,490 --> 00:53:29,912
So for the time being, instead we will run
Ember test as a 'one off', like a one shot test.

541
00:53:29,940 --> 00:53:33,200
So it will run the tests, then
it will tear it all down again.

542
00:53:33,280 --> 00:53:36,744
That will give us
something to work against

543
00:53:37,060 --> 00:53:38,750
So it's not working at the moment.

544
00:53:39,280 --> 00:53:48,464
And the reason is that although my
buildCollaborators does point to the correct ids.

545
00:53:48,696 --> 00:53:51,640
What we won't have here is...

546
00:53:51,970 --> 00:53:55,872
We're asking for model.sequels,
but there is no such thing right now.

547
00:53:55,880 --> 00:53:56,888
DN: Of course, right.

548
00:53:56,890 --> 00:54:03,320
JW: So we need to get those.

549
00:54:04,700 --> 00:54:10,800
You're probably thinking it may
be possible to do something like:

550
00:54:10,800 --> 00:54:23,048
<a href="episodes/{{sequel.id}}">
or something like that.

551
00:54:23,260 --> 00:54:30,250
We know from buildCollaborators
that we do have the sequel ids, like this:

552
00:54:30,250 --> 00:54:34,744
[Silence]

553
00:54:34,760 --> 00:54:38,792
So based on that first bit of work we
did that's as far as we got at the moment.

554
00:54:39,700 --> 00:54:42,048
Technically, that would work.

555
00:54:43,120 --> 00:54:47,280
The API doesn't actually have an end
point for that you could load up all the data

556
00:54:47,304 --> 00:54:50,408
and find the one with the correct id.

557
00:54:51,040 --> 00:55:00,128
At this point I'm inclined to lean on
Ember.Data to do some pulling together of records.

558
00:55:00,150 --> 00:55:02,760
So I'm going to...

559
00:55:03,970 --> 00:55:06,496
I'm going to put in an elbow commit.

560
00:55:08,088 --> 00:55:10,544
Let's see what I added there.

561
00:55:13,410 --> 00:55:18,280
Let's say... [Jamie thinks]

562
00:55:18,280 --> 00:55:26,150
Attempt to add list of sequels to an episode.

563
00:55:26,150 --> 00:55:28,952
[New Chapter]

564
00:55:29,544 --> 00:55:34,288
Let's checkout a branch.

565
00:55:34,430 --> 00:55:38,120
This will be quite a
substantial thing to start to add in.

566
00:55:39,410 --> 00:55:42,424
I think that in order to
prove that is definitely working.

567
00:55:42,430 --> 00:55:48,304
I'm going to have a play with the inspector
to begin with, rather than the test environment.

568
00:55:48,300 --> 00:55:50,750
I have a gut feeling it will be quicker that way.

569
00:55:50,752 --> 00:55:54,864
So up top, in the application route.

570
00:55:55,880 --> 00:56:01,890
Rather than this quite manual process of

571
00:56:03,040 --> 00:56:08,032
getting the data and it pulling it
out and building collaborators from that.

572
00:56:08,096 --> 00:56:11,240
I'm going to return:

573
00:56:13,288 --> 00:56:17,792
Lets see, earlier on I reached for this.

574
00:56:17,790 --> 00:56:25,480
[Silence]

575
00:56:25,490 --> 00:56:30,696
The promise library has this hash
function which is a hash of promises.

576
00:56:30,690 --> 00:56:35,984
Where they all pass on this hash with the promises switched out

577
00:56:35,990 --> 00:56:39,776
for whatever they're
resolved into. So it's quite handy.

578
00:56:39,850 --> 00:56:43,384
What this let's us do is...

579
00:56:44,344 --> 00:56:46,832
Well, I want to do two things.

580
00:56:46,840 --> 00:56:50,056
I want to load the episodes.

581
00:56:51,176 --> 00:56:57,500
I'll do this with
this.store.find('episode')

582
00:56:57,500 --> 00:57:02,550
meaning get the episodes
and that returns a promise.

583
00:57:06,460 --> 00:57:11,968
This is going to return two promises and it's going
to wait for them both to resolve before it finishes.

584
00:57:12,020 --> 00:57:14,472
Don't need the ajax anymore.

585
00:57:14,720 --> 00:57:19,240
DN: Do we now have to define a store for each of those?

586
00:57:19,250 --> 00:57:22,632
JW: The store we get for free, but what we do need is...

587
00:57:22,650 --> 00:57:24,984
To begin with, some models.

588
00:57:24,980 --> 00:57:44,224
[Jamie types]

589
00:57:44,390 --> 00:57:49,760
So right now this is going to be
complaining that I've got no such models, I think.

590
00:57:51,020 --> 00:57:53,256
No models found for episode.

591
00:58:11,550 --> 00:58:16,192
DN: You're using camel case deliberately
here while the API uses underscore case.

592
00:58:16,200 --> 00:58:18,376
JW: It does yes.

593
00:58:18,376 --> 00:58:23,810
Just by convention Ember
tends to use camel case where possible.

594
00:58:23,810 --> 00:58:27,520
Just because that's what JavaScript looks like.

595
00:58:28,208 --> 00:58:30,490
challengeName string...

596
00:58:30,670 --> 00:58:33,432
What else have we got... we've
got host name and guest name.

597
00:58:33,432 --> 00:58:36,048
We should be able to infer those from the...

598
00:58:36,040 --> 00:58:42,032
Let's say we've got a guest,
which is a belongs-to relationship

599
00:58:42,040 --> 00:58:45,384
and a host, which is another
belongs-to relationship.

600
00:58:48,360 --> 00:58:51,776
That should have made me a model for episode.

601
00:58:51,770 --> 00:58:57,000
[Silence]

602
00:58:57,480 --> 00:59:00,672
Let's generate another one of these:

603
00:59:01,520 --> 00:59:08,056
Interesting, cannot read property of ajax.

604
00:59:08,060 --> 00:59:15,064
Ember g model partner is the other one.

605
00:59:15,820 --> 00:59:17,550
Let's just have a look at the data.

606
00:59:48,030 --> 00:59:51,088
It might get confused about what I mean here.

607
00:59:51,080 --> 00:59:54,864
[Silence]

608
00:59:54,890 --> 00:59:58,856
It will think there's a model
with that name, but in fact these are...

609
00:59:59,460 --> 01:00:02,696
It's referring to the partner model.

610
01:00:03,960 --> 01:00:07,250
And just like in rails I'll have to tell it...

611
01:00:09,056 --> 01:00:12,550
Oh sorry I'm in Partner so this is
referring to the Episode model.

612
01:00:12,550 --> 01:00:21,840
[Silence]

613
01:00:22,000 --> 01:00:25,856
And just like in Rails, I'll have to tell it...

614
01:00:28,960 --> 01:00:33,872
what the names of the inverse relationships
are, if the names are substantially different.

615
01:00:36,610 --> 01:00:40,280
So here, the inverse is guest.

616
01:00:42,880 --> 01:00:48,048
And here the inverse is host.

617
01:01:13,030 --> 01:01:19,152
At this point, I'm looking at building
collaborators as a way to prove to myself

618
01:01:19,160 --> 01:01:26,280
that following host and guest that way is
what's intended by the description of the challenge.

619
01:01:26,288 --> 01:01:35,080
But I have a feeling that using Ember Data like
this is going to shoulder a lot of the work for me.

620
01:01:35,600 --> 01:01:42,170
I'm just going to go for ember-data...
I think canary has a fix for that issue.

621
01:01:42,170 --> 01:01:52,152
[Silence]

622
01:01:52,176 --> 01:01:57,128
OK, so what you are seeing here is,
it's trying to load episodes partners.

623
01:01:58,180 --> 01:02:01,337
It assumes those are the
end points we're looking for.

624
01:02:01,337 --> 01:02:03,880
DN: We've got them in the API namespace haven't we?

625
01:02:03,880 --> 01:02:04,880
JW: We have indeed.

626
01:02:05,820 --> 01:02:08,528
If we add some of this, lets see...

627
01:02:09,560 --> 01:02:18,380
Firstly, use ember-data#canary

628
01:02:18,380 --> 01:02:24,800
[Jamie types]

629
01:02:24,830 --> 01:02:33,660
This isn't quite the order that
things happened in. Let's add models.

630
01:02:33,660 --> 01:02:37,872
That can be a part of that...

631
01:02:37,870 --> 01:02:40,400
And then this change...

632
01:02:40,400 --> 01:02:49,472
[Silence]

633
01:02:49,490 --> 01:02:52,000
It's fine, right so...

634
01:02:52,000 --> 01:02:58,616
[Silence]

635
01:02:58,688 --> 01:03:04,770
Retrieve episodes and partners.

636
01:03:11,170 --> 01:03:14,580
It doesn't know about the
namespace of the API just yet.

637
01:03:14,580 --> 01:03:18,251
And further more it doesn't
know to stick a .json on the end.

638
01:03:18,310 --> 01:03:22,440
We need to tell it, the way
to do that is an adapter.

639
01:03:24,300 --> 01:03:32,464
We want this to be the universal rule
so we call this the application adapter.

640
01:03:32,460 --> 01:03:51,968
[Jamie types]

641
01:03:51,992 --> 01:03:54,290
DN: Ah, forgot to save the inverse.

642
01:03:54,290 --> 01:04:00,976
JW: Yes, add inverses to...
Which one's that? Partner.

643
01:04:03,530 --> 01:04:07,344
So app/adapters/application.

644
01:04:08,050 --> 01:04:10,440
At the moment it's the REST adapter.

645
01:04:10,450 --> 01:04:18,552
But the data we're working with looks quite a
lot like what active model serializers would yield.

646
01:04:18,560 --> 01:04:23,112
So let's use the
ActiveModelAdapter instead.

647
01:04:25,360 --> 01:04:30,072
Which is expecting data of this form
so it should know what to do with it.

648
01:04:30,180 --> 01:04:39,912
Then we need to tell it the namespace
and I think it is just namespace like this.

649
01:04:39,910 --> 01:04:59,440
[Silence]

650
01:04:59,510 --> 01:05:02,860
DN: Does it still need to add .json?

651
01:05:02,860 --> 01:05:03,370
JW: It does.

652
01:05:03,370 --> 01:05:08,160
Now we're getting the right path
but without the .json on the end.

653
01:05:08,160 --> 01:05:11,712
And I think there's another method adapter:

654
01:05:11,710 --> 01:05:20,536
[Silence]

655
01:05:20,650 --> 01:05:23,440
urlPrefix is not quite what we want.

656
01:05:24,970 --> 01:05:27,240
There's pathForType.

657
01:05:29,520 --> 01:05:31,640
Which might well do the job.

658
01:05:32,340 --> 01:05:36,576
Unless there's something more general
than that, which there might well be.

659
01:05:38,570 --> 01:05:42,216
buildUrl... oh it just says to use
pathForType anyway.

660
01:05:42,230 --> 01:05:44,840
Let's do that: pathForType
And what we want to do is return...

661
01:05:53,810 --> 01:05:57,310
Basically this calls straight
through to the superclass method.

662
01:06:01,480 --> 01:06:04,088
And then I add .json on the end.

663
01:06:07,710 --> 01:06:11,168
Now some interesting things have happened.

664
01:06:12,150 --> 01:06:18,664
We've got these warnings here: The payload
for episode contains some unknown keys.

665
01:06:18,870 --> 01:06:22,808
It's saying you've got this data but you've
not declared that you're going to use it.

666
01:06:22,816 --> 01:06:27,296
Similarly, we've got guest episode host episode.

667
01:06:40,170 --> 01:06:43,720
It's expecting simply... like that:

668
01:06:43,720 --> 01:06:44,720
DN: Yes, right.

669
01:06:44,720 --> 01:06:49,640
So we can now use a...
Lets just commit the adapter.

670
01:06:49,640 --> 01:06:55,104
[Silence]

671
01:06:55,128 --> 01:06:59,210
Add namespace and suffix to adapter.

672
01:06:59,210 --> 01:07:02,824
[Silence]

673
01:07:02,840 --> 01:07:06,312
Let's generate a serializer which will enable us

674
01:07:06,328 --> 01:07:10,616
to perform those kind of
transformations on the input data.

675
01:07:10,690 --> 01:07:18,144
Before we do that let's stop it
complaining about those missing fields.

676
01:07:18,320 --> 01:07:23,056
That's episodes, it's expecting to see,
guest name, host name, poster frame url.

677
01:07:23,464 --> 01:07:24,840
DN: They can all be strings I suppose can't they?

678
01:07:24,848 --> 01:07:27,504
JW: Yes I guess so.

679
01:07:37,480 --> 01:07:42,560
DN: Again, you're using camel case
but the API has snakecase underscores.

680
01:07:42,570 --> 01:07:43,280
JW: Yes.

681
01:07:43,280 --> 01:07:47,336
DN: So, where is that inference
happening from one format to the other?

682
01:07:47,330 --> 01:07:49,520
JW: It's all happening in the serializer.

683
01:07:49,520 --> 01:07:50,800
DN: Ah right.

684
01:07:50,968 --> 01:07:57,850
JW: You will find that by default there's this
normalize method which does all this kind of work,

685
01:07:57,850 --> 01:08:04,088
converting snake case into camel
case, converting plurals into singular,

686
01:08:04,320 --> 01:08:08,160
whatever is appropriate for the format.

687
01:08:08,180 --> 01:08:10,880
Now I've got rid of some of my warnings.

688
01:08:10,890 --> 01:08:14,368
But there's still this guest
episode, host episodes problem.

689
01:08:14,380 --> 01:08:18,080
So let's say [Jamie thinks].

690
01:08:18,090 --> 01:08:26,568
We don't want a serializer for everything,
we just want a serializer for partner.

691
01:08:29,824 --> 01:08:39,544
So that's generated that.
So let me just add...

692
01:08:40,680 --> 01:08:46,770
"Add missing attrs"

693
01:08:46,770 --> 01:08:57,712
Now I've got partner serializer and
this is again an ActiveModelSerializer.

694
01:08:57,720 --> 01:09:02,496
There has got to be some hook where
I can turn these into what it's expecting.

695
01:09:04,550 --> 01:09:08,344
I've got normalize which takes
type, hash and prop.

696
01:09:08,800 --> 01:09:10,432
And that's going to do this work.

697
01:09:10,460 --> 01:09:19,952
So if I normalize type has prop.

698
01:09:20,740 --> 01:09:23,472
Type meaning: when you get the data through

699
01:09:26,700 --> 01:09:32,240
it's going to infer the type from
this key, under which each record lives.

700
01:09:35,150 --> 01:09:39,264
But we don't care too
much about that manipulation here.

701
01:09:39,310 --> 01:09:43,176
All we want to do is say, let's see...

702
01:09:43,710 --> 01:09:47,992
Hash is this.

703
01:09:48,230 --> 01:09:52,464
We want to move this attribute basically.
So we're saying:

704
01:09:52,470 --> 01:10:02,616
hash.host_episode_ids equals
hash.host_episodes

705
01:10:02,616 --> 01:10:07,900
and then delete the original key,
otherwise it will complain.

706
01:10:08,000 --> 01:10:10,296
And then to do a similar thing:

707
01:10:10,500 --> 01:10:19,290
hash.guest_episode_id (singular) equals
hash_guest_episode.

708
01:10:19,290 --> 01:10:25,640
[Silence]

709
01:10:26,510 --> 01:10:34,216
Once we've done those manipulations we just want
to hand it off to the regular superclass method.

710
01:10:34,456 --> 01:10:39,104
so: type, our manipulated hash, and prop.

711
01:10:39,120 --> 01:10:48,064
I've not been so careful to dodge a mutation
here because I think you get passed a safe hash.

712
01:10:48,064 --> 01:10:49,336
DN: Oh, OK.

713
01:10:49,330 --> 01:10:51,816
JW: I'm fairly sure that's the case.

714
01:10:53,160 --> 01:10:57,016
Host episodes [Jamie thinks].

715
01:10:57,010 --> 01:10:59,400
Oh right yes. [slight laugh]

716
01:11:01,400 --> 01:11:03,851
My warnings have now gone.

717
01:11:03,880 --> 01:11:07,325
It's complaining that the value
each loops over must be an array.

718
01:11:07,400 --> 01:11:09,632
We passed a record array.

719
01:11:09,660 --> 01:11:13,608
DN: So are we down to this thing called model.sequels?

720
01:11:14,150 --> 01:11:17,952
JW: Now I'm at template index.

721
01:11:18,580 --> 01:11:25,032
I'm calling model, which is this
object here containing an episode's partners.

722
01:11:25,040 --> 01:11:30,784
So I want to do model.episodes.

723
01:11:30,850 --> 01:11:36,896
DN: Ah, because now your model is in
that promise containing both models effectively.

724
01:11:36,896 --> 01:11:38,784
JW: Yes.

725
01:11:38,780 --> 01:11:40,610
So this has got me back to this point.

726
01:11:41,590 --> 01:11:44,800
But the advantage I have now,
which I didn't have before.

727
01:11:44,810 --> 01:11:50,072
Before, I got to the point where I knew the Ids
I wanted to get to, but I didn't have the data to hand.

728
01:11:50,420 --> 01:11:54,328
And the question was, where
do I go and load in that data.

729
01:11:54,360 --> 01:11:59,176
Do I even have it available? Whereas
now Ember Data is doing that work for me.

730
01:11:59,560 --> 01:12:03,920
And furthermore, here I can see
the records that have been loaded.

731
01:12:06,590 --> 01:12:09,016
I should also be able to see...

732
01:12:09,725 --> 01:12:12,068
There will be some computed properties here.

733
01:12:12,060 --> 01:12:15,656
So you can see, belongs to guest episode.

734
01:12:15,660 --> 01:12:18,670
There you can see it has
managed to dig up the real model.

735
01:12:20,430 --> 01:12:23,680
That was me just clicking through, let me
do that again it went real quick.

736
01:12:24,570 --> 01:12:29,112
Here's an episode, "Counting Tree Nodes".
These are its properties, here on the right.

737
01:12:29,110 --> 01:12:33,952
you've got guest, that's Tom Stuart,

738
01:12:34,460 --> 01:12:37,536
These might be the wrong way round.
DN: No, that's right.

739
01:12:37,720 --> 01:12:39,856
JW: Oh course, yeah!
You're the host, Drew Neil.

740
01:12:39,872 --> 01:12:42,960
I should be able to go to the guest... cool...

741
01:12:44,380 --> 01:12:47,896
See what episodes Tom hosts:
that's a many array, I'll go in there.

742
01:12:47,928 --> 01:12:51,528
It's an array containing
one which is "Ranking Poker Hands".

743
01:12:51,520 --> 01:12:54,168
So you can see it flow through.

744
01:12:54,330 --> 01:12:55,288
DN: Very nice.

745
01:12:55,970 --> 01:12:58,960
JW: Leaning on Ember
Data makes it a lot quicker.

746
01:13:01,280 --> 01:13:05,976
Now that's in place, let me commit
this, that seems like quite a lot all at once.

747
01:13:06,850 --> 01:13:11,040
A new serializer, changed the template a bit.

748
01:13:11,040 --> 01:13:13,510
Oh it's not too bad, OK.

749
01:13:14,872 --> 01:13:20,256
So we're adding the partner serializer.

750
01:13:21,048 --> 01:13:23,992
[New Chapter]

751
01:13:26,000 --> 01:13:28,880
JW: Right now we have an acceptance test.

752
01:13:29,976 --> 01:13:33,912
Which at this point is still failing,
because we've not added the list of sequels,

753
01:13:33,920 --> 01:13:37,080
and we've not added the prequel link yet.

754
01:13:37,230 --> 01:13:39,257
I've got some unit tests which are failing,

755
01:13:39,250 --> 01:13:43,056
simply because they are just
boilerplate that was generated for me.

756
01:13:43,260 --> 01:13:46,280
They need to be told
more about the rest of the world.

757
01:13:49,580 --> 01:13:55,040
I could just remove them. I feel I want to
get them passing to have a clean environment

758
01:13:55,070 --> 01:13:57,500
So I'll do that quickly:

759
01:13:57,500 --> 01:14:00,936
The first thing to pass is the episode.

760
01:14:01,280 --> 01:14:04,840
And actually you never know, they might
tell me something useful.

761
01:14:07,200 --> 01:14:09,960
model:guest, model:host, ok so....

762
01:14:10,300 --> 01:14:15,184
When I generated the episode model
I said that it had these two relationships.

763
01:14:15,200 --> 01:14:20,528
And the boilerplate test has these
two dependencies in it because I said that.

764
01:14:20,520 --> 01:14:26,504
But in fact there are no such
models as those. It's just partner.

765
01:14:27,450 --> 01:14:29,968
So if I do that...

766
01:14:30,104 --> 01:14:33,992
Actually you might have to keep
jumping back to tests you were on.

767
01:14:35,300 --> 01:14:42,816
Now episode passes and if we flip over to
the partner test you'll see a similar problem.

768
01:14:43,530 --> 01:14:45,874
Really all this wants is...

769
01:14:45,870 --> 01:14:53,768
[Silence]

770
01:14:53,770 --> 01:14:57,720
Now I'm back to my acceptance
test which is the thing that is driving us

771
01:14:57,752 --> 01:14:59,944
towards the place we want to be.

772
01:14:59,970 --> 01:15:03,272
Which is as follows:

773
01:15:03,270 --> 01:15:06,736
[Silence].

774
01:15:06,850 --> 01:15:11,725
Eventually what we want to see
is a list of just the root episodes.

775
01:15:11,725 --> 01:15:13,942
The episodes that begin a sequence.

776
01:15:13,990 --> 01:15:17,192
Click on one of those, and you see it's sequels.

777
01:15:17,220 --> 01:15:17,810
DN: Yes,

778
01:15:17,810 --> 01:15:23,064
JW: And you click on a sequel and
you see it's sequel, and prequel as well.

779
01:15:23,060 --> 01:15:28,536
So, let's commit.

780
01:15:29,800 --> 01:15:32,864
I'm using so many styles of working with git.

781
01:15:32,896 --> 01:15:36,888
So let's commit those to...

782
01:15:37,080 --> 01:15:40,696
DN: So this is the fugitive commit feature?
JW: Yes.

783
01:15:55,650 --> 01:16:00,608
It's complaining at the moment because
I can't click on Ranking Poker Hands.

784
01:16:00,630 --> 01:16:02,248
So that is...

785
01:16:02,256 --> 01:16:07,104
I'm in an episode. I'm expecting to
list all the sequels of the model.

786
01:16:07,100 --> 01:16:13,120
Now what you'll find here is that

787
01:16:13,520 --> 01:16:17,384
I do have the ul,
so it's ready to list something.

788
01:16:17,380 --> 01:16:20,992
It's not going to complain that
this isn't an array.

789
01:16:23,590 --> 01:16:28,664
It's more useful to just fail silently,
when your at the template point of things

790
01:16:28,950 --> 01:16:32,712
because there's so little failure
handling you can do in template.

791
01:16:32,710 --> 01:16:38,128
As a general principle it's best
to treat these values as monadic.

792
01:16:39,864 --> 01:16:44,420
They will resolve down to nil, or the value you want.

793
01:16:46,800 --> 01:16:51,632
I think what I need to to is get hold of these sequels.

794
01:16:51,632 --> 01:16:55,152
That's going to change later on if I don't do it now.

795
01:16:57,450 --> 01:17:03,016
The question is, if I take an
episode how do I find it's sequels?

796
01:17:03,010 --> 01:17:07,928
[Silence]

797
01:17:07,920 --> 01:17:14,856
I'm going to add a computed
property to this episode called sequels.

798
01:17:23,885 --> 01:17:26,697
Effectively I want to look
at the rest of the episodes.

799
01:17:26,690 --> 01:17:32,464
And filter them down to just
a set where the host is my guest.

800
01:17:32,750 --> 01:17:36,448
Let's have a look at what
we have in terms of filtering.

801
01:17:41,110 --> 01:17:45,040
Whenever you access records in
Ember data you always go via the store.

802
01:17:45,200 --> 01:17:49,531
Which is the central book keeping object.

803
01:17:49,570 --> 01:17:53,848
And it makes sure your always getting
the same instance you got last time.

804
01:17:53,848 --> 01:17:54,976
DN: Right.

805
01:17:56,750 --> 01:18:04,272
I do have filter here, which
takes type and a query and a filter.

806
01:18:05,280 --> 01:18:14,712
So I think I'll try asking for this.store.filter.
And we'll be asking for episodes.

807
01:18:17,928 --> 01:18:21,168
The thing I'm going to be
filtering on is the host id.

808
01:18:22,360 --> 01:18:24,920
Or rather just the host in fact.

809
01:18:29,550 --> 01:18:31,530
Let's see what the signature of this is.

810
01:18:31,570 --> 01:18:39,820
It's just going to give me an episode to work with.

811
01:18:41,960 --> 01:18:45,808
Now this is going to return a promise of some kind.

812
01:18:50,340 --> 01:18:52,824
It says it returns a live record array.

813
01:18:52,820 --> 01:18:57,912
So hopefully we will be able to dump that
into the template, and it will update live

814
01:18:57,940 --> 01:19:00,352
Let's find out... that might not be true.

815
01:19:00,350 --> 01:19:05,240
We're saying: episode that we're
looking at...

816
01:19:06,816 --> 01:19:09,360
Get the host...

817
01:19:09,776 --> 01:19:13,096
equals...
Let's just pull up guest.

818
01:19:13,104 --> 01:19:16,624
[Silence]

819
01:19:16,670 --> 01:19:21,984
We could go potentially have ids here,
but I think they will be hidden from us by this point.

820
01:19:21,992 --> 01:19:25,464
These are fully materialized records.

821
01:19:25,500 --> 01:19:33,672
[Jamie thinks]

822
01:19:33,670 --> 01:19:37,368
The value of each loop must be an array, oh yes!

823
01:19:38,440 --> 01:19:42,312
I forgot to declare that
this is a computed property.

824
01:19:42,400 --> 01:19:46,216
There we go, so that's my sequel, so let's just...

825
01:19:46,460 --> 01:19:48,408
DN: Does that give us a passing acceptance test?

826
01:19:48,410 --> 01:19:50,504
JW: Well, let's find out.

827
01:19:50,520 --> 01:19:55,256
[Jamie thinks]

828
01:19:55,880 --> 01:20:00,048
I think I might have messed up my
link-to helper there, let's find out.

829
01:20:02,272 --> 01:20:06,184
sequel.challengeName "episode" sequel

830
01:20:06,856 --> 01:20:09,448
Interesting, lets see what...

831
01:20:09,448 --> 01:20:13,848
[Silence]

832
01:20:13,840 --> 01:20:16,000
So there's two, hmm...

833
01:20:16,950 --> 01:20:24,180
This may be a problem with my acceptance test.

834
01:20:42,780 --> 01:20:46,176
DN: Is it the exception that's failing
where it's checking the current URL?

835
01:20:46,180 --> 01:20:47,384
JW: Yes.

836
01:20:49,770 --> 01:20:51,320
I think it might be just my...

837
01:20:51,320 --> 01:20:59,008
[Silence]

838
01:20:59,040 --> 01:21:00,584
OK Cool.

839
01:21:00,608 --> 01:21:04,472
DN: That's why you have a commit.

840
01:21:05,028 --> 01:21:07,714
JW: So we see what happened there.

841
01:21:07,770 --> 01:21:10,290
We've added a computed property called sequels,

842
01:21:10,560 --> 01:21:15,776
that sets up a filter and these filters are live.

843
01:21:15,770 --> 01:21:19,420
So the idea is, if a
new episode entered the store,

844
01:21:20,240 --> 01:21:25,776
this filter should update
anywhere it's used in the template.

845
01:21:29,070 --> 01:21:35,720
CamelCase challenge name, and current
path apparently really means current root.

846
01:21:35,760 --> 01:21:38,936
Whereas what we want is the current URL.

847
01:21:39,480 --> 01:21:50,272
So add sequels computed property to episode.

848
01:21:53,700 --> 01:21:56,432
I feel that the acceptance test
has given me enough confidence

849
01:21:56,432 --> 01:21:59,168
that things are working on the whole.

850
01:21:59,160 --> 01:22:04,120
And I feel that it's going to
be more fun just to play in the UI,

851
01:22:04,120 --> 01:22:07,976
and see what other properties it has,
and see what other things we can do.

852
01:22:09,790 --> 01:22:11,528
So jump to episode two.

853
01:22:11,530 --> 01:22:13,800
We've already got the next sequel.

854
01:22:13,820 --> 01:22:17,368
This at the moment has no sequels
and we're not showing prequels just yet.

855
01:22:17,370 --> 01:22:19,448
So I'm going to...

856
01:22:22,976 --> 01:22:27,632
Let's give this a title.

857
01:22:27,790 --> 01:22:33,016
DN: Yes it would be nice to see
the title of the current episode as well.

858
01:22:33,016 --> 01:22:35,184
and maybe a poster frame.

859
01:22:50,830 --> 01:22:56,552
JW: That "Welcome to Peer to Peer" looks
surplus to requirements now, so let's ditch that.

860
01:22:56,550 --> 01:23:02,912
[Jamie thinks]

861
01:23:02,920 --> 01:23:09,448
I'm going to make a bunch of cosmetic changes
all at once, and then bundle them in to a commit.

862
01:23:14,500 --> 01:23:16,950
DN: So we've got an else branch for each

863
01:23:17,050 --> 01:23:17,620
JW: Yes.

864
01:23:19,030 --> 01:23:21,160
I forget where Ember inherited this from.

865
01:23:21,580 --> 01:23:23,160
It's not unique to Ember

866
01:23:25,980 --> 01:23:32,080
It's a little like a LISP, handlebars
templating language.

867
01:23:33,100 --> 01:23:36,050
It's not really capable
of doing multiple branches.

868
01:23:36,050 --> 01:23:38,550
in a conditional, it's only a binary.

869
01:23:38,550 --> 01:23:41,820
But it does mean you can do this kind of
thing with an each:

870
01:23:46,100 --> 01:23:51,760
I'm just going to
Make it look a little different.

871
01:23:57,070 --> 01:24:02,890
I'm going to add in the rudiments
of what the prequel looks like.

872
01:24:03,480 --> 01:24:05,770
Let's make a list as well
to make it symmetric.

873
01:24:13,450 --> 01:24:15,690
This could either be:
if prequel, render it...

874
01:24:18,560 --> 01:24:21,950
DN: Else you could say
"this episode starts a sequence".

875
01:24:22,540 --> 01:24:23,040
JW: Yes

876
01:24:24,220 --> 01:24:25,700
I'm going to use an each again.

877
01:24:30,880 --> 01:24:32,300
Semantically, that's wrong.

878
01:24:32,860 --> 01:24:36,900
You wouldn't have more prequels.
At least at the moment.

879
01:24:39,950 --> 01:24:43,600
The way we are going to filter, I think we
are going to use the same filter pattern.

880
01:24:45,020 --> 01:24:45,600
So: link-to prequel.challengeName
"episode" prequel

881
01:24:59,540 --> 01:25:03,570
Right now this shouldn't fail
in a spectacular way.

882
01:25:04,050 --> 01:25:07,748
It should just silently do not very much.

883
01:25:38,450 --> 01:25:42,114
Notice the silence there...

884
01:25:42,150 --> 01:25:43,760
That indicates to me a build error.

885
01:25:45,760 --> 01:25:46,870
But maybe it's OK.

886
01:26:03,500 --> 01:26:06,020
A bunch of cosmetic
stuff... Let's just add that.

887
01:26:14,050 --> 01:26:17,700
Let's see if we can get
a prequel implemented quickly.

888
01:26:17,700 --> 01:26:20,820
I'm not going to worry
about the acceptance test for this

889
01:26:21,500 --> 01:26:26,550
I have a feeling it will be extremely
similar to sequels.

890
01:26:46,080 --> 01:26:48,130
Here we're filtering on a guest instead.

891
01:26:48,890 --> 01:26:50,770
In the episode 2s guest is our host.

892
01:27:09,220 --> 01:27:10,080
DN: Looking good!

893
01:27:11,300 --> 01:27:18,400
So I guess the missing element now
is that list of root nodes.

894
01:27:19,730 --> 01:27:21,550
Those episodes without a prequel.

895
01:27:21,550 --> 01:27:21,970
JW: Yes.

896
01:27:24,480 --> 01:27:32,200
There is one little thing about this:
these prequels and sequels...

897
01:27:33,360 --> 01:27:36,990
If the host of either episode was changed
on the fly...

898
01:27:37,000 --> 01:27:44,000
If this became an editing interface, these
would stop being in sync with things.

899
01:27:44,210 --> 01:27:47,360
So I have to declare
that this is a computed property

900
01:27:47,360 --> 01:27:49,150
that depends on the value of host.

901
01:27:49,860 --> 01:27:52,350
And this one depends on the value of guest.

902
01:27:53,090 --> 01:27:56,210
Technically it depends on store
but store not going to change.

903
01:27:58,210 --> 01:27:59,680
That's very interesting.

904
01:28:01,010 --> 01:28:04,200
Oh, I know what I've done there, hold on.

905
01:28:04,990 --> 01:28:06,450
DN: So that second argument...

906
01:28:07,150 --> 01:28:10,970
JW: Yes, I think it's if you want to
send a different request off to the server.

907
01:28:10,970 --> 01:28:11,420
DN: I see.

908
01:28:12,900 --> 01:28:16,420
JW: It looks like it's
requesting back and forth repeatedly.

909
01:28:16,980 --> 01:28:18,720
Let's kill that off.

910
01:28:24,560 --> 01:28:25,690
That's better.

911
01:28:28,150 --> 01:28:29,100
Excellent.

912
01:28:32,450 --> 01:28:34,170
Right, so that second argument...

913
01:28:35,910 --> 01:28:43,840
[Jamie reads:] Optionally you can pass a
query which will be triggered at first.

914
01:28:44,000 --> 01:28:47,328
The results returned by the
server could then appear in the filter

915
01:28:47,328 --> 01:28:49,776
if they match the filter function.

916
01:28:49,820 --> 01:28:57,376
So it allows you to use the data you already
have and make a query in the background.

917
01:28:58,100 --> 01:29:00,848
Just covering all the bases I think.

918
01:29:05,410 --> 01:29:07,520
So let's add that:

919
01:29:07,860 --> 01:29:11,990
That's implements prequels.

920
01:29:14,104 --> 01:29:17,144
[New Chapter]

921
01:29:21,440 --> 01:29:28,530
Here, rather than looping over the episodes,

922
01:29:28,530 --> 01:29:32,360
we want to loop over
something like root episodes.

923
01:29:32,360 --> 01:29:33,440
DN: Yes.

924
01:29:34,030 --> 01:29:37,200
JW: I'm going to say that we're
going to loop over simply the model.

925
01:29:39,080 --> 01:29:41,072
This is going to fail at first.

926
01:29:41,080 --> 01:29:43,888
We'll go back to:

927
01:29:46,510 --> 01:29:53,512
So it's saying we're trying to
each over an object, just a hash.

928
01:29:55,920 --> 01:30:00,976
Right now, we are not in the application
route, we are one down in the index route.

929
01:30:00,984 --> 01:30:04,520
So if I generate a route:

930
01:30:04,790 --> 01:30:07,144
That's like  a real live route for that.

931
01:30:07,140 --> 01:30:14,592
[Silence]

932
01:30:14,610 --> 01:30:19,024
So by default a route will take a
model of its parent routes, as its own.

933
01:30:20,860 --> 01:30:26,480
So, if we say instead, the model for this is going to be...

934
01:30:27,680 --> 01:30:29,700
We'll get the model for the application.

935
01:30:31,100 --> 01:30:36,680
and then we want to pluck off the episodes

936
01:30:36,680 --> 01:30:39,912
let's see, that should be more
or less, back to where we started.

937
01:30:43,550 --> 01:30:46,904
I think the best way to
perform that transformation is here.

938
01:30:47,608 --> 01:30:50,000
And I think...

939
01:30:52,768 --> 01:30:55,760
Let's think... we could use that filter again.

940
01:30:55,776 --> 01:30:58,712
We can say...

941
01:31:00,800 --> 01:31:04,840
Actually, do you know what, at this
point these things are already loaded.

942
01:31:04,910 --> 01:31:11,864
Therefore we could do
something like this.store.filter episode.

943
01:31:11,860 --> 01:31:20,408
[Silence].

944
01:31:20,400 --> 01:31:28,336
return episode.get prequels.

945
01:31:28,330 --> 01:31:33,128
[Silence]

946
01:31:33,200 --> 01:31:35,720
It's this kind of thing.

947
01:31:35,720 --> 01:31:38,672
[Silence]

948
01:31:39,392 --> 01:31:44,830
I don't think we can quite call
that, so let's say prequels.length.

949
01:31:44,830 --> 01:31:53,176
[Silence]

950
01:31:53,200 --> 01:31:57,616
The problem with that is that this
is probably not quite what we think it is.

951
01:31:58,360 --> 01:32:02,272
This uhm... [Jamie thinks]

952
01:32:02,290 --> 01:32:04,032
Let's find out.

953
01:32:04,240 --> 01:32:10,680
At this point in time I've got a strong
feeling that if we ask for prequels.length,

954
01:32:10,680 --> 01:32:16,192
you wont get back an ordinary array of
ordinary length.

955
01:32:16,192 --> 01:32:26,530
So... [silence]

956
01:32:26,530 --> 01:32:31,352
This is a... [laughter].

957
01:32:31,440 --> 01:32:33,600
I don't know what it is.

958
01:32:33,620 --> 01:32:37,072
That seems OK.

959
01:32:37,090 --> 01:32:39,970
So that's true for at least one of them.

960
01:32:39,970 --> 01:32:52,600
[Silence]

961
01:32:52,600 --> 01:32:54,808
DN: It seems to be returning true every time.

962
01:32:54,820 --> 01:32:57,400
JW: It does doesn't it?

963
01:32:59,330 --> 01:33:02,304
So Ranking Poker Hands should not be in here.

964
01:33:02,312 --> 01:33:03,350
DN: Right.

965
01:33:03,350 --> 01:33:06,360
(Some sounds of confusion)

966
01:33:06,360 --> 01:33:10,192
DN: Ah, it's working! [laughter].

967
01:33:10,190 --> 01:33:15,024
JW: So that suggests... [Jamie thinks].

968
01:33:15,030 --> 01:33:21,440
It suggests you have to ask some
question before it completes the operation.

969
01:33:21,520 --> 01:33:25,144
Oh, yes right...

970
01:33:25,140 --> 01:33:32,744
I think you may well find
is that these prequels are...

971
01:33:33,370 --> 01:33:37,790
It might be returning something
asynchronous... some kind of promise.

972
01:33:37,790 --> 01:33:43,464
[Silence]

973
01:33:43,472 --> 01:33:46,050
Let's think, what's the best way to deal
with this?

974
01:33:46,050 --> 01:33:48,500
Let's go for...

975
01:33:48,500 --> 01:34:02,224
[Silence]

976
01:34:02,250 --> 01:34:05,664
I'm going to add...

977
01:34:07,240 --> 01:34:08,630
Let's just see what else is available.

978
01:34:08,630 --> 01:34:13,968
It might be there's another
primitive for doing this kind of thing.

979
01:34:15,690 --> 01:34:20,408
Maybe we ought to add a
computed property to the episode model

980
01:34:20,400 --> 01:34:23,976
[Silence]

981
01:34:23,984 --> 01:34:26,568
We'll call this isRoot.

982
01:34:28,620 --> 01:34:31,320
And this is true...

983
01:34:31,320 --> 01:34:36,560
[Silence]

984
01:34:36,632 --> 01:34:39,384
This is going to run into kind of the same problem.

985
01:34:39,400 --> 01:34:42,656
DN: it would be: if it has no prequels
rather than no sequels, wouldn't it?

986
01:34:42,680 --> 01:34:44,800
JW: Yes...

987
01:34:44,800 --> 01:34:49,504
[Silence]

988
01:34:49,500 --> 01:34:52,560
So let's see...

989
01:34:52,560 --> 01:35:12,896
[Silence]

990
01:35:13,040 --> 01:35:19,016
DN: I wasn't anticipating that this
would be the hard part. It's a surprise.

991
01:35:19,024 --> 01:35:25,064
[Silence]

992
01:35:25,070 --> 01:35:29,504
What is it... When we start with a
list and it's got all five episodes,

993
01:35:29,512 --> 01:35:32,960
and we click on one and then go back again.

994
01:35:32,960 --> 01:35:35,340
What is it that's changed at that point?

995
01:35:35,340 --> 01:35:40,472
[Silence as Jamie thinks]

996
01:35:40,480 --> 01:35:41,744
DN: And then if we go back...

997
01:35:41,751 --> 01:35:42,821
JW: Yes so...

998
01:35:43,030 --> 01:35:45,392
DN: Now it's OK.

999
01:35:45,700 --> 01:35:48,370
JW: At this point...

1000
01:35:48,370 --> 01:35:52,768
[Jamie thinks]

1001
01:35:52,768 --> 01:35:55,264
We've got these two computed properties...

1002
01:35:55,270 --> 01:35:59,384
And the way they are bound into
the DOM gives them a chance to fully resolve.

1003
01:35:59,390 --> 01:36:03,712
To turn from promise to a real value.

1004
01:36:03,890 --> 01:36:11,024
Whereas in our route,
(sort of) inherited route environment,

1005
01:36:12,520 --> 01:36:17,456
we're saying get host.
Sorry, rather we're saying...

1006
01:36:17,450 --> 01:36:21,864
[Silence]

1007
01:36:21,880 --> 01:36:24,624
I've still got all that to save.

1008
01:36:24,890 --> 01:36:28,368
I was expecting to see the full list at this point.

1009
01:36:28,360 --> 01:36:45,984
[Silence]

1010
01:36:46,000 --> 01:36:52,208
What we are not doing is giving
that promise a chance to resolve itself.

1011
01:36:52,200 --> 01:36:55,496
before we return the model data to the template.

1012
01:36:55,730 --> 01:37:02,784
I was hoping that this filter would change
dynamically, as new data becomes available.

1013
01:37:02,810 --> 01:37:03,480
DN: Right.

1014
01:37:03,490 --> 01:37:06,000
It seems that isn't quite the case.

1015
01:37:06,016 --> 01:37:09,376
[Silence]

1016
01:37:09,380 --> 01:37:12,734
DN: Is there some way you can
do something before the model loads?

1017
01:37:12,730 --> 01:37:15,032
Maybe on initialization or...?

1018
01:37:15,060 --> 01:37:17,056
JW: Yes, I think that would...

1019
01:37:17,090 --> 01:37:30,464
The dirty way to do it would be to do something
like this.store.all episode. mapBy sequels.

1020
01:37:30,460 --> 01:37:35,440
[Silence]

1021
01:37:35,440 --> 01:37:38,416
DN: And that forces the computed property to be...?

1022
01:37:39,140 --> 01:37:43,920
JW: It's going to kick start all those
promises. And change the state of all those models.

1023
01:37:43,920 --> 01:37:47,816
[Silence]

1024
01:37:47,825 --> 01:37:49,330
What's going on there?

1025
01:37:49,330 --> 01:37:53,504
Oh it's saying that I've
still got no model, so model dot...

1026
01:37:53,500 --> 01:38:18,792
[Silence]

1027
01:38:18,870 --> 01:38:20,768
DN: Oh that does it.

1028
01:38:20,800 --> 01:38:24,984
JW: Unfortunately, because
the model is a little state machine,

1029
01:38:26,580 --> 01:38:31,824
to account for the fact that
you may have data landing later on...

1030
01:38:33,469 --> 01:38:37,258
other models may change around
it, that it needs to know about.

1031
01:38:38,350 --> 01:38:42,712
In order to get this richness of
relationships, it can't be just a pure object.

1032
01:38:43,316 --> 01:38:45,447
You end up with these sort of situations,

1033
01:38:45,440 --> 01:38:49,792
where your having to wait
for a model to get into the right state.

1034
01:38:49,850 --> 01:38:54,184
Which is tricky, because in this case
we know that we have all the data up front.

1035
01:38:54,180 --> 01:38:59,112
But Ember Data is so geared up for the
idea that you don't know when data will arrive.

1036
01:39:00,820 --> 01:39:04,568
I have a feeling there probably is a way to...

1037
01:39:04,560 --> 01:39:10,768
[Silence]

1038
01:39:10,770 --> 01:39:16,552
There are extra properties you can add.

1039
01:39:17,860 --> 01:39:23,656
So you could say explicitly that
these are asynchronous dependencies.

1040
01:39:23,700 --> 01:39:28,208
But for us, because up in
the application route, we have...

1041
01:39:28,210 --> 01:39:31,696
very deliberately loaded
in an entire store of data.

1042
01:39:31,723 --> 01:39:34,072
We shouldn't need to ever worry about that.

1043
01:39:34,660 --> 01:39:40,904
It's a shame that we're having to
do that but... it gets us to the point we want,

1044
01:39:40,920 --> 01:39:43,376
which is to get these root episodes.

1045
01:39:43,380 --> 01:39:44,376
DN: Yes.

1046
01:39:44,370 --> 01:39:48,448
JW: So let's make that very explicit:

1047
01:39:48,440 --> 01:40:10,016
[Silence]

1048
01:40:10,050 --> 01:40:14,816
So, Solving Word Chain puzzles...
then it goes on to Building a Basic Calculator.

1049
01:40:15,110 --> 01:40:18,509
And back there and... For good measure:

1050
01:40:20,680 --> 01:40:22,548
DN: We can link back to the top one?

1051
01:40:22,574 --> 01:40:23,207
JW: Yes.

1052
01:40:50,180 --> 01:40:51,024
Something like that.

1053
01:40:51,520 --> 01:40:54,112
[New Chapter]

1054
01:40:54,410 --> 01:41:02,016
JW: So now I would be interested to
know... to see what we're getting for our money.

1055
01:41:02,380 --> 01:41:05,780
I'll quickly do this:

1056
01:41:05,780 --> 01:41:09,088
[Silence]

1057
01:41:09,104 --> 01:41:12,560
It would be interesting to add another episode in.

1058
01:41:12,560 --> 01:41:17,544
And see if our representation
updates as we expect it to.

1059
01:41:17,550 --> 01:41:24,296
DN: So how about we imagine an episode
where Tom sets a challenge for Steve Purcell?

1060
01:41:24,296 --> 01:41:26,290
JW: OK.

1061
01:41:28,218 --> 01:41:31,345
DN: That will mean we have
a single root in that case.

1062
01:41:31,340 --> 01:41:35,832
But there will be a branch where
Tom has interviewed Camille and also Steve.

1063
01:41:35,830 --> 01:41:38,744
JW: Yes, right, so...

1064
01:41:39,230 --> 01:41:41,796
I want to try and do this in the inspector.

1065
01:41:41,790 --> 01:41:46,960
It's a useful way to check that
your app is behaving as you want.

1066
01:41:47,500 --> 01:41:53,128
The Ember inspector gives you
introspection on everything in your living system.

1067
01:41:53,560 --> 01:41:59,640
These little $E buttons will emit an object
out into the global scope, so you can play with it.

1068
01:41:59,810 --> 01:42:02,550
So this is my store.

1069
01:42:02,550 --> 01:42:05,848
[Silence]

1070
01:42:06,760 --> 01:42:09,760
I could do createRecord...

1071
01:42:11,840 --> 01:42:15,328
I could use store.createRecord, let's try this.

1072
01:42:17,130 --> 01:42:21,032
Create record implies that you're
going to pass in other concrete objects.

1073
01:42:21,120 --> 01:42:22,720
Like if there's a relationship.

1074
01:42:22,720 --> 01:42:25,816
I'm going to literally give it Steve to work with.

1075
01:42:25,810 --> 01:42:29,176
But I think it might be more
interesting to push a new payload in.

1076
01:42:29,170 --> 01:42:35,168
This is a case where, you would have for
example, new data coming in over a socket.

1077
01:42:35,200 --> 01:42:38,992
Imagine that Peer to
Peer was produced so often,

1078
01:42:38,990 --> 01:42:45,392
that you had a web socket, telling the browser
that the episode... You can use, I believe it's pushPayload.

1079
01:42:45,410 --> 01:42:50,216
So this is the idea of imagining a
new chunk of data coming into the store.

1080
01:42:50,210 --> 01:42:54,040
[Jamie thinks]

1081
01:42:54,040 --> 01:42:57,288
Let's see...

1082
01:42:57,390 --> 01:43:01,880
We've got pushPayload there,
I think we can get it on store as well.

1083
01:43:02,448 --> 01:43:05,710
pushPayload, yes... type...

1084
01:43:05,710 --> 01:43:13,608
[Jamie thinks]

1085
01:43:13,640 --> 01:43:18,272
Let's pushPayload. What did
we say, Tom interviewing Steve?

1086
01:43:18,272 --> 01:43:19,710
DN: Yes.

1087
01:43:20,280 --> 01:43:24,672
JW: We'll go back to Counting Tree
Nodes, and we'll pushPayload which looks like:

1088
01:43:26,260 --> 01:43:28,992
DN: So the nice thing about this is
we don't have to create any new partners.

1089
01:43:29,000 --> 01:43:33,370
We can re-use the ones that exist.

1090
01:43:33,504 --> 01:43:36,984
JW: We're saying it will have an id of 6.

1091
01:43:38,376 --> 01:43:44,304
Challenge name: some challenge
that Tom would set for Steve

1092
01:43:44,300 --> 01:43:48,944
which would probably be
something really hard. (laughter).

1093
01:43:48,940 --> 01:43:51,400
[Jamie thinks]

1094
01:43:51,400 --> 01:43:53,968
Invent a new monad.

1095
01:43:53,970 --> 01:43:57,310
DN: Sounds interesting!

1096
01:43:57,310 --> 01:44:01,632
Guest name and host name we don't
really use, so I'm going to leave them be.

1097
01:44:01,960 --> 01:44:04,592
Let's just say there's no
poster image for this one.

1098
01:44:04,590 --> 01:44:08,760
So we'll say host_id is going to be Tom, who is 2.

1099
01:44:08,830 --> 01:44:11,368
and guest id is going to be Steve...

1100
01:44:13,440 --> 01:44:15,328
who is 4.
DN: Yes.

1101
01:44:16,520 --> 01:44:26,510
I think that to get this to work I'll have
to wrap it in an episode namespace.

1102
01:44:26,510 --> 01:44:28,504
DN: OK... you didn't just lose all that did you?

1103
01:44:28,584 --> 01:44:29,950
JW: I did.

1104
01:44:29,952 --> 01:44:31,950
DN: Oh dear.

1105
01:44:31,950 --> 01:44:34,688
pushPayLoad

1106
01:44:36,032 --> 01:44:40,504
I think it will be episode singular.
Maybe not, let's try episodes plural.

1107
01:44:41,024 --> 01:44:46,980
Shouldn't take too long...
id, challengeName...

1108
01:44:46,980 --> 01:44:57,936
[Silence]

1109
01:44:57,936 --> 01:45:00,420
That is the end of the array.

1110
01:45:00,420 --> 01:45:06,464
[Silence]

1111
01:45:08,648 --> 01:45:09,840
Tell it what it's expecting.

1112
01:45:09,848 --> 01:45:12,456
There we go: "Invent a New Monad".

1113
01:45:12,450 --> 01:45:15,976
DN: And it just fits right
into the sequence... very nice.

1114
01:45:15,984 --> 01:45:19,000
JW: And we should be able to have a look
in Data here.

1115
01:45:19,000 --> 01:45:21,464
There we go, yes.

1116
01:45:24,200 --> 01:45:26,640
These aren't the computed guest and host names,

1117
01:45:26,640 --> 01:45:31,080
these are the ones that are stored on the
objects that we're not really using in this case.

1118
01:45:31,088 --> 01:45:33,608
DN: We can probably ignore those.

1119
01:45:33,600 --> 01:45:39,816
JW: Yes, we genuinely have
Steve the guest and Tom the host.

1120
01:45:39,810 --> 01:45:44,192
[Jamie thinks]

1121
01:45:44,210 --> 01:45:50,632
I'm just going to add one more
little cosmetic thing to enrich this.

1122
01:45:50,656 --> 01:45:55,416
[Silence]

1123
01:45:55,420 --> 01:45:58,440
I'm going to drop...

1124
01:46:00,416 --> 01:46:03,448
Because this was all about
collaborations to begin with...

1125
01:46:03,808 --> 01:46:05,440
Let's say:

1126
01:46:05,440 --> 01:46:12,144
[Silence]

1127
01:46:12,140 --> 01:46:15,760
Sequel.challengeName

1128
01:46:17,440 --> 01:46:24,670
With sequel.guest

1129
01:46:24,670 --> 01:46:28,616
[Silence]

1130
01:46:28,620 --> 01:46:31,400
DN: I would say featuring guest name.

1131
01:46:34,656 --> 01:46:37,560
JW: There is a little thing
which is going to happen here

1132
01:46:37,560 --> 01:46:41,248
which is that guests don't
have a name, I don't think.

1133
01:46:41,248 --> 01:46:45,920
DN: Yes, that's right, first name and last name.

1134
01:46:46,768 --> 01:46:48,120
But we could compute that.

1135
01:46:48,120 --> 01:46:49,576
JW: Yes.

1136
01:46:51,760 --> 01:46:56,040
That's gone from memory now,
so I've lost that new episode.

1137
01:46:57,190 --> 01:47:00,632
Featuring... There's no name, so I'll add that.

1138
01:47:22,264 --> 01:47:24,568
DN: That one has two dependent keys then?

1139
01:47:24,576 --> 01:47:26,992
JW: Correct.

1140
01:47:27,990 --> 01:47:30,600
Then, with a little bit of luck ....

1141
01:47:31,888 --> 01:47:34,712
DN: Ahh.. very nice.

1142
01:47:34,776 --> 01:47:39,384
This gives us the other nicety which is if we...

1143
01:47:39,380 --> 01:47:44,360
[Silence]

1144
01:47:44,424 --> 01:47:48,248
How does Camille spell her name, is it CAMI?

1145
01:47:49,140 --> 01:47:52,608
DN: Good question, I don't know,
it's certainly pronounced Camille.

1146
01:47:54,240 --> 01:47:55,880
[Inaudible]

1147
01:47:55,880 --> 01:47:59,440
JW: We can now edit these
details in one central place.

1148
01:47:59,440 --> 01:48:04,304
[Silence]

1149
01:48:04,320 --> 01:48:05,820
DN: OK... Check it in.

1150
01:48:05,820 --> 01:48:08,360
JW: Yes.

1151
01:48:08,360 --> 01:48:18,400
[Silence]

1152
01:48:18,400 --> 01:48:21,144
I'll add the whole lot.

1153
01:48:22,800 --> 01:48:30,460
This is where we add featuring names.

1154
01:48:30,460 --> 01:48:34,264
[Silence]

1155
01:48:34,272 --> 01:48:38,280
DN: We've got the root, that's a major change.

1156
01:48:38,280 --> 01:48:45,528
Add... filter down to root episodes.

1157
01:48:55,680 --> 01:48:59,240
DN: You misspelled featuring I'm afraid (laughter)

1158
01:48:59,240 --> 01:49:06,208
[Silence]

1159
01:49:06,768 --> 01:49:09,544
[New Chapter]

1160
01:49:10,070 --> 01:49:14,152
DN: So we've reached a
good place to call it a day I think.

1161
01:49:14,168 --> 01:49:19,660
But if you had more time, how
would you like to continue with this?

1162
01:49:19,660 --> 01:49:22,104
It's interesting, this is...

1163
01:49:22,160 --> 01:49:28,656
For anyone familiar with building
this style of view on data in Rails

1164
01:49:28,656 --> 01:49:31,500
it probably seems relatively simplistic.

1165
01:49:32,860 --> 01:49:36,640
If wouldn't be too hard to do
this with Rails, but the point is we are...

1166
01:49:37,320 --> 01:49:41,728
getting these potentially
disparate data sources into memory

1167
01:49:42,400 --> 01:49:46,104
and turning them into a data structure
that we can then wander around in

1168
01:49:46,120 --> 01:49:50,312
all without having to do any
more re-loads or fetches of data.

1169
01:49:50,330 --> 01:49:55,062
So now we have these
relationships between these objects.

1170
01:49:55,097 --> 01:49:59,588
It wouldn't be too hard to
render them out in other ways.

1171
01:49:59,580 --> 01:50:03,737
The way we have it right
now, linking between them,

1172
01:50:03,740 --> 01:50:13,088
I feel like it's the... simplest way
to represent a graph of different entities.

1173
01:50:13,100 --> 01:50:19,428
That's (kind of) the web way, its most basic form.

1174
01:50:19,420 --> 01:50:24,120
But we could render out a visual graph of this stuff.

1175
01:50:24,240 --> 01:50:29,737
I would be inclined to reach for Graphviz.

1176
01:50:30,050 --> 01:50:37,584
Or potentially D3 which has some
modules in it for rendering directed graphs.

1177
01:50:38,308 --> 01:50:44,320
I know Graphviz and its dot
language better than I know D3.

1178
01:50:44,320 --> 01:50:48,537
So that's where I would err towards but...

1179
01:50:48,670 --> 01:50:52,928
The other thing I would like to get rid of,

1180
01:50:52,936 --> 01:50:59,400
but I just can't think of how you go about
it, is the reliance on this here.

1181
01:50:59,400 --> 01:51:02,448
I'm sure there is a way,
probably an idiomatic way,

1182
01:51:02,464 --> 01:51:07,320
but in essence it's because of this odd...

1183
01:51:09,771 --> 01:51:15,737
thing of needing to... in the
same way you want to carry a monad,

1184
01:51:15,900 --> 01:51:20,248
up until the final moment, to finally
unpack it, and get the value inside it.

1185
01:51:20,256 --> 01:51:24,850
Similarly here, we want to
be dealing just in terms of promises

1186
01:51:24,868 --> 01:51:28,857
until the last possible moment,
when they are put into the template,

1187
01:51:28,850 --> 01:51:32,352
and eventually allowed to
be unpacked and rendered.

1188
01:51:32,370 --> 01:51:34,344
So, I'm sure there's a way around this.

1189
01:51:34,354 --> 01:51:38,057
but, it probably doesn't hurt too much at this point.

1190
01:51:38,460 --> 01:51:42,712
DN: The idea will probably will spring into
your head just as we turn the camera off (laughter).

1191
01:51:42,712 --> 01:51:46,590
JW: In terms of the UI, it would be...

1192
01:51:48,860 --> 01:51:53,416
You could render a tree out
here of blobs connected by sticks.

1193
01:51:55,310 --> 01:51:59,352
DN: Well, it's been really interesting
watching you work and how you use Ember.

1194
01:51:59,382 --> 01:52:01,470
And thanks a lot for coming on the show.

1195
01:52:01,470 --> 01:52:03,352
JW: Thanks for inviting me.

1196
01:52:03,352 --> 01:52:09,000
Captions produced by Bonnie Roworth
