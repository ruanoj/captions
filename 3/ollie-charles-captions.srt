1
00:00:02,000 --> 00:00:03,920
NARRATOR: Welcome to Peer to Peer

2
00:00:03,930 --> 00:00:07,245
where you can hone your
skills by watching live coding videos

3
00:00:08,800 --> 00:00:11,097
Our guest today is Ollie Charles

4
00:00:11,140 --> 00:00:13,245
who's a Haskell developer at Fynder

5
00:00:13,250 --> 00:00:15,897
and the author of 24 days of Hackage.

6
00:00:16,800 --> 00:00:18,571
Our host is Steve Purcell

7
00:00:19,060 --> 00:00:21,314
and the challenge that we set for Ollie is called:

8
00:00:21,474 --> 00:00:23,640
Solving Word Chain Puzzles.

9
00:00:24,251 --> 00:00:26,354
Steve Purcell: So Ollie would you like to start

10
00:00:26,354 --> 00:00:28,190
by reading through the question description?

11
00:00:28,190 --> 00:00:31,897
Ollie Charles: So it's write a
program that solves word chain puzzles.

12
00:00:31,890 --> 00:00:35,314
A word chain puzzle starts with
one word and ends with another.

13
00:00:35,405 --> 00:00:38,754
Successive entries in the
chain must all be real words.

14
00:00:38,754 --> 00:00:42,160
And each can differ from the
previous word by just one letter.

15
00:00:42,160 --> 00:00:45,748
For example, you can get from
"dog to "cat" using the following chain:

16
00:00:45,740 --> 00:00:48,594
Dog to cog to cot to cat.

17
00:00:49,130 --> 00:00:52,628
Your program should accept
start and end words and a dictionary,

18
00:00:52,640 --> 00:00:54,491
and find word chains between them.

19
00:00:55,611 --> 00:00:58,310
OC: So that seems pretty straightforward to me.

20
00:00:58,310 --> 00:01:00,450
I guess that we've got a restriction there,

21
00:01:00,450 --> 00:01:03,314
that the start and the end words
will have to be the same length?

22
00:01:03,325 --> 00:01:05,051
SP: Yes they will.

23
00:01:08,285 --> 00:01:10,937
OC: You've given me this dictionary as well.

24
00:01:14,670 --> 00:01:17,382
And I see that some of these are different case.

25
00:01:17,874 --> 00:01:20,170
Is that going to have any impact on the problem?

26
00:01:20,180 --> 00:01:23,074
Do I need to preserve case
or or lower case everything?

27
00:01:23,085 --> 00:01:30,290
SP: I'd like the resulting chain to include
the original case of the word from this file.

28
00:01:30,560 --> 00:01:37,577
And if you ask for a chain between two particular
words they should be present with the same case

29
00:01:37,588 --> 00:01:40,582
in the word list file, in order to be considered valid.

30
00:01:40,620 --> 00:01:44,800
OC: OK.  And is changing case
going to be considered an operation?

31
00:01:45,090 --> 00:01:52,685
So if I have something that starts with a lower
case A and an upper case A is that a difference of one?

32
00:01:53,000 --> 00:02:02,182
SP: I think so, I think a word will
either be capitalized or not in the dictionary.

33
00:02:02,180 --> 00:02:08,011
I don't think you would find the same
word in there twice, once capitalized and once not.

34
00:02:08,080 --> 00:02:12,640
OC: OK, Yes. Well, I suppose we'll see what happens.

35
00:02:15,028 --> 00:02:19,462
The first thing to do is get my environment set up.

36
00:02:19,810 --> 00:02:24,262
I want to have a Cabal file so
I'll treat this like a proper project.

37
00:02:24,260 --> 00:02:28,502
I'm going to be using nix  shell to
work with that cabal file to do builds

38
00:02:28,540 --> 00:02:31,177
and bring down dependencies and stuff like that.

39
00:02:33,460 --> 00:02:38,434
OC: So I've got a terminal here,
I should be able to run cabal init

40
00:02:38,520 --> 00:02:41,360
So let's call this Word Puzzle.

41
00:02:42,697 --> 00:02:48,617
It doesn't really matter about the
version and I'll just use another license.

42
00:02:52,560 --> 00:02:56,594
I'll leave that blank... and all this blank.

43
00:02:57,908 --> 00:03:01,371
SP: Yes it will probably become executable

44
00:03:02,045 --> 00:03:07,200
OC: And we'll go with WordPuzzle.hs as the main part.

45
00:03:11,890 --> 00:03:21,840
So now I believe I have my cabal file
so I should be able to do some basic builds now.

46
00:03:30,880 --> 00:03:36,491
OC: I'm using the Emacs compile command
there to use the cabal file and do a build.

47
00:03:36,811 --> 00:03:38,902
I'm just going to see if that compiles.

48
00:03:38,902 --> 00:03:42,422
Hopefully it's configuring.

49
00:03:42,434 --> 00:03:45,028
And it looks like we've got something.

50
00:03:45,645 --> 00:03:49,257
I'm going to have to rename this to main.

51
00:03:54,090 --> 00:03:57,634
OK, so that seems to be happy
compiling and stuff like that

52
00:03:57,810 --> 00:04:05,291
and we can also switch over
to the terminal and run that... yes.

53
00:04:08,590 --> 00:04:13,062
OC: I think the first thing I'm going to
do is work with loading the dictionary words,

54
00:04:13,394 --> 00:04:15,760
just so we've got some data to play with.

55
00:04:15,970 --> 00:04:19,600
I'm going to start by making
a type alias for the dictionary

56
00:04:19,622 --> 00:04:25,394
and for our purposes the dictionary
is just going to be a list of text values.

57
00:04:25,417 --> 00:04:29,988
And the text there is the type from Data.Text.

58
00:04:32,570 --> 00:04:35,314
And I think I'll make a new function, readDictionary

59
00:04:35,310 --> 00:04:40,034
which will take the file path
and give me back a dictionary.

60
00:04:47,417 --> 00:04:49,108
I'll take that out for now.

61
00:04:53,900 --> 00:04:59,577
We're going to need the Data Text library
as well, so I'll add that to the Cabal file.

62
00:05:03,200 --> 00:05:06,914
And because I'm using nix I'm
going to need to add it to my nix file as well.

63
00:05:06,925 --> 00:05:11,428
so that's going to just pull down my dependencies.

64
00:05:19,234 --> 00:05:25,150
OK. We do need a main, so let's stub that out for now.

65
00:05:27,634 --> 00:05:30,445
SP: So the underscore
you're leaving there is the hole?

66
00:05:30,440 --> 00:05:36,205
OC: Yes, so if we expand the compilation buffern
it says that there are two holes in this program.

67
00:05:36,270 --> 00:05:38,708
We need to provide some type of computation

68
00:05:38,700 --> 00:05:41,680
that's going to be an io
action that will return a dictionary.

69
00:05:41,691 --> 00:05:43,910
And we also have another hole for main as well.

70
00:05:43,931 --> 00:05:46,280
SP: And this is a new feature in the latest GHC?

71
00:05:46,280 --> 00:05:48,571
OC: yes. I think this came in GHC 7.8.

72
00:05:50,140 --> 00:05:53,520
So  I'll leave the hole in main for now,

73
00:05:53,531 --> 00:05:56,660
because it's probably going to
be one of the last ones we fill in.

74
00:05:56,800 --> 00:05:59,645
I'll work on reading this dictionary.

75
00:06:01,490 --> 00:06:06,777
I think I'm going to switch over to Hackage now, and
look at the documentation from the Text Library.

76
00:06:08,610 --> 00:06:13,074
This module has all sorts of IO routines
that are going  to give us text values back,

77
00:06:13,110 --> 00:06:15,540
and the one that I'm interested in is readfile,

78
00:06:15,540 --> 00:06:18,914
which takes a file path that
gives us back a single text strength,

79
00:06:18,970 --> 00:06:21,820
and then we can split
that up into a dictionary later.

80
00:06:22,251 --> 00:06:24,834
The first thing I'm going to do...

81
00:06:33,710 --> 00:06:37,794
The text library tends to work
best if you use qualified imports.

82
00:06:37,851 --> 00:06:41,680
So I'm going to import Data.Text as T.

83
00:06:42,280 --> 00:06:46,788
SP: So you're just avoiding the confusion
of clobbering the built-ins in the prelude.

84
00:06:46,780 --> 00:06:50,091
OC: Yes, the prelude has things
like length, filter and stuff like that,

85
00:06:50,091 --> 00:06:52,530
but text also has length and filter.

86
00:06:52,537 --> 00:06:56,205
So to avoid ambiguous names
I'm going to import that entirely qualified.

87
00:06:57,610 --> 00:07:01,611
SP: So it's about hiding the
prelude symbols, explicitly?

88
00:07:01,620 --> 00:07:05,577
OC: Yes, I'm probably not going to be using the prelude stuff very much,

89
00:07:05,600 --> 00:07:07,540
but that will save me some hassle.

90
00:07:09,120 --> 00:07:13,211
I'm going to have a type hole in
there so I've got some well formed syntax.

91
00:07:14,010 --> 00:07:18,434
And now I have a hole that needs to be a dictionary.

92
00:07:18,434 --> 00:07:22,114
And I have available dictionary
contents which is a piece of text.

93
00:07:22,377 --> 00:07:26,480
So I need to split this
single text string into a list of lines.

94
00:07:26,490 --> 00:07:35,337
I believe we have a function to do that
in the Text Library as well, which is un-line. (Inaudible)

95
00:07:35,782 --> 00:07:38,685
Which is going to break
the text up into a list of texts.

96
00:07:38,685 --> 00:07:41,600
SP: It's the exact analogue
of the lines in the prelude.

97
00:07:41,610 --> 00:07:46,148
OC: Exactly. The Text type itself is very
similar to the String type in the prelude.

98
00:07:46,228 --> 00:07:48,542
Except the String type is quite inefficient.

99
00:07:48,542 --> 00:07:50,370
It's just a linked list of characters,

100
00:07:50,370 --> 00:07:53,820
whereas the Text type is more
efficient in terms of its representation.

101
00:07:53,820 --> 00:07:54,251
SP: So you make a point of defaulting to the Text type?
whereas the Text type is more
efficient in terms of its representation.

102
00:07:54,251 --> 00:07:57,200
SP: So you make a point of defaulting to the Text type?

103
00:07:57,211 --> 00:08:04,200
OC: Yes inaudible

104
00:08:04,200 --> 00:08:07,885
Now I can just take the lines of dictionary contents.

105
00:08:14,034 --> 00:08:17,737
Now I should have a way to read the dictionary.

106
00:08:18,220 --> 00:08:24,205
I'm going to switch back to my
terminal and load that up into GCHi

107
00:08:24,205 --> 00:08:26,200
and then we can have a play with that.

108
00:08:28,537 --> 00:08:34,902
I need to refresh my shell to
bring down that text dependency.

109
00:08:34,900 --> 00:08:37,931
(Ollie types).

110
00:08:38,000 --> 00:08:42,034
We've still got these holes here
which prevents me from using GHCi.

111
00:08:42,040 --> 00:08:47,782
But, I can use another feature of a
later version of GHC called defer-type errors.

112
00:08:47,980 --> 00:08:53,245
Which is going to let me load
code which doesn't strictly type check.

113
00:08:53,290 --> 00:08:57,794
But as long as I don't run something that
doesn't type check, I can still evaluate the program.

114
00:08:57,820 --> 00:09:01,314
I can work around the fact that
I've got an incomplete bit of code

115
00:09:01,310 --> 00:09:02,857
and I can run the bits I'm working on.

116
00:09:02,860 --> 00:09:08,297
SP: So does it effectively replace that code
with undefined and then compile it all anyway?

117
00:09:08,308 --> 00:09:13,890
OC: We can find out. It's the main
function that we haven't defined, so if I call main.

118
00:09:14,274 --> 00:09:17,340
Well actually it doesn't terminate at all (laughter).

119
00:09:17,720 --> 00:09:23,200
But we do have readDictionary.

120
00:09:24,500 --> 00:09:35,622
So why don't we try: readDictionary and "wordlist.txt".

121
00:09:35,748 --> 00:09:41,051
I'm going to bind that into - no I'm not

122
00:09:41,050 --> 00:09:48,102
When emacs cooperates, I'm going
to bind that into a variable called dict.

123
00:09:48,228 --> 00:09:50,285
SP: It's not going to print it straight off is it?

124
00:09:50,350 --> 00:09:53,828
OC: No, because of the size of the
dictionary, I want to put that in a variable

125
00:09:53,828 --> 00:09:57,314
so I can try and read out a few things from it.

126
00:09:57,314 --> 00:10:00,102
So we'll take the length of the dictionary.

127
00:10:08,200 --> 00:10:10,137
It's a pretty large dictionary.

128
00:10:10,420 --> 00:10:14,994
So we have to be quite efficient in
the way we search through this.

129
00:10:15,120 --> 00:10:18,560
But we do seem to have got some stuff.

130
00:10:18,570 --> 00:10:23,725
I guess we've got some windows line
endings there. Which is going to be annoying.

131
00:10:23,725 --> 00:10:24,971
I'll probably want to trim that stuff out.

132
00:10:24,980 --> 00:10:30,057
SP: Feel free to convert the file, If you want
to change the line endings that's fine with me.

133
00:10:32,540 --> 00:10:41,097
OC: Maybe if we just filter those carriage
returns out that might be easy enough.

134
00:10:51,250 --> 00:10:53,920
Let's see if that's any better.

135
00:10:53,980 --> 00:10:55,268
So I'm happy with that.

136
00:10:55,260 --> 00:10:59,920
We're just filtering out carriage
returns on the whole dictionary string.

137
00:11:03,660 --> 00:11:06,548
So it looks like the dictionary has loaded up fine.

138
00:11:06,720 --> 00:11:10,754
So now we're ready to start solving the problem.

139
00:11:12,434 --> 00:11:16,091
There's no real reason to
restrict ourselves to the IO monad here.

140
00:11:16,102 --> 00:11:19,508
This feels like it should be
solvable just with pure functions.

141
00:11:19,520 --> 00:11:19,960
SP: Yes.

142
00:11:19,970 --> 00:11:27,051
So I'm going to introduce a top level
function called... we'll go with word puzzle,

143
00:11:27,090 --> 00:11:33,897
which is going to take 2 text strings,
which are going to be our start and end strings.

144
00:11:37,340 --> 00:11:41,314
And the dictionary I think I'll
bring that in as the first argument.

145
00:11:44,080 --> 00:11:46,880
So a possible solution is going to be a list of words,

146
00:11:47,410 --> 00:11:50,902
But I imagine there are multiple
possible solutions for some of these problems.

147
00:11:50,900 --> 00:11:53,760
So I'm going to return a list of lists of words.

148
00:11:53,771 --> 00:11:58,594
And because that's getting a bit confusing
we'll introduce a type in there called solution.

149
00:11:58,690 --> 00:12:00,491
SP: Perhaps a word chain?

150
00:12:00,502 --> 00:12:03,702
OC: Yes, good we'll go with word chain.

151
00:12:04,960 --> 00:12:07,257
Which is going to be a list of text.

152
00:12:09,480 --> 00:12:14,194
SP: So you'll get back a list of possible
chains from the first word to the second word.

153
00:12:14,250 --> 00:12:18,274
OC: And if it's not possible to solve the
problem then we can just return the empty list.

154
00:12:18,274 --> 00:12:21,140
Which says there are no possible word chains at all.

155
00:12:29,028 --> 00:12:32,857
I'm going to try to solve this by pattern matching
basically and try to break the problem down slowly.

156
00:12:32,857 --> 00:12:34,910
And hopefully we'll get to the solution that way.

157
00:12:34,914 --> 00:12:36,942
And there's one really obvious pattern...

158
00:12:36,940 --> 00:12:40,080
you gave me the restriction that
the words have to be the same length.

159
00:12:40,090 --> 00:12:43,131
So if the words aren't the same length then
there's certainly no word chain between them.

160
00:12:43,130 --> 00:12:49,782
I'll get that case out of the way.
I'm going to use a pattern guard for that.

161
00:12:49,794 --> 00:12:57,180
If the length of a is not the lengt
of b then I'll just return nothing.

162
00:12:59,540 --> 00:13:04,628
Otherwise, I'll leave that to be solved.

163
00:13:07,480 --> 00:13:08,910
OK so what have we got there?

164
00:13:11,200 --> 00:13:12,740
It seems to be happy with that,

165
00:13:12,740 --> 00:13:16,434
We've got a hole on line 19 but that's
actually the problem we've got to solve.

166
00:13:16,434 --> 00:13:25,428
So if I try now and solve the word puzzle with
our dictionary, between Hello and Haskell.

167
00:13:26,205 --> 00:13:29,668
Whoops the dictionary
escaped, I'll just bring that back in.

168
00:13:31,710 --> 00:13:36,620
I need to use an extension here
for GHC called overloaded strings.

169
00:13:36,620 --> 00:13:36,662
Normally when we quote a
string, it has the type string,
I need to use an extension here
for GHC called overloaded strings.

170
00:13:36,662 --> 00:13:39,851
Normally when we quote a
string, it has the type string,

171
00:13:39,860 --> 00:13:42,034
but obviously we are working with text values.

172
00:13:42,034 --> 00:13:47,920
So the overloaded string extension
is going to let us use literal strings,

173
00:13:47,942 --> 00:13:49,310
but they will have a type text.

174
00:13:50,160 --> 00:13:54,674
And as we would expect- Hello and Haskell don't
have the same length so there's no solution at all.

175
00:13:54,690 --> 00:13:59,497
We can move on now to
actually try and find some solutions.

176
00:13:59,740 --> 00:14:05,360
SP: Might I suggest another case where
we might be able to rule out possible solutions?

177
00:14:05,370 --> 00:14:06,445
OC: Sure.

178
00:14:06,570 --> 00:14:09,851
SP: So if either of the
words are not in the dictionary.

179
00:14:09,885 --> 00:14:12,994
I don't know if you want to handle that now?

180
00:14:13,131 --> 00:14:14,960
OC: No that seems reasonable.

181
00:14:19,380 --> 00:14:23,394
I've just had a thought that I might
want to have a more efficient dictionary type,

182
00:14:23,394 --> 00:14:24,940
but we'll come to that later.

183
00:14:24,948 --> 00:14:27,325
So we're given two words A and B:

184
00:14:27,320 --> 00:14:48,354
Let's see inaudible

185
00:14:55,520 --> 00:14:56,845
I think that's what we want.

186
00:14:57,291 --> 00:15:00,765
See if that compiles.

187
00:15:02,450 --> 00:15:08,205
SP: You'll probably find that
Haskell will not be in the dictionary.

188
00:15:08,910 --> 00:15:11,794
OC: OK well we can check that...

189
00:15:17,600 --> 00:15:19,394
It is in the dictionary! (laughter)

190
00:15:19,960 --> 00:15:21,302
SP: It's a respectable word!

191
00:15:21,300 --> 00:15:23,508
OC: But inaudible isn't in the dictionary, so...

192
00:15:25,880 --> 00:15:32,560
I guess then we probably need to deal
with case, or maybe I should be case sensitive.

193
00:15:32,740 --> 00:15:38,034
Capital Hello is not in the dictionary.
Lower case however, will be... Yes.

194
00:15:38,710 --> 00:15:40,280
I think I'll leave that for now.

195
00:15:40,280 --> 00:15:42,834
SP: I think that's how it should work. Yes.

196
00:15:42,834 --> 00:15:43,600
OC: OK.

197
00:15:43,748 --> 00:15:47,497
SP: Let's presume that the input
would be exactly as it is in the dictionary

198
00:15:47,497 --> 00:15:49,930
or it's strictly considered invalid.

199
00:15:49,940 --> 00:15:51,668
OC: OK, seems reasonable.

200
00:15:53,950 --> 00:15:59,862
And I expect there's another obvious
pattern, which is regardless of the dictionary,

201
00:16:00,160 --> 00:16:03,897
we have two words A and B, and
they are the same, then we're done.

202
00:16:03,900 --> 00:16:09,874
So that has one possible solution, and I think
I'm still going to put that solution in the word chain.

203
00:16:09,970 --> 00:16:11,485
So if we go from hello to hello,

204
00:16:11,497 --> 00:16:15,634
the solution will be one word
chain which contains just the word hello.

205
00:16:16,710 --> 00:16:19,188
So we can try that one too.

206
00:16:19,180 --> 00:16:22,434
(Ollie types)

207
00:16:22,788 --> 00:16:24,660
Whoops! so let's see:

208
00:16:24,660 --> 00:16:30,742
Word puzzle, inaudible dictionary inaudible.

209
00:16:30,800 --> 00:16:35,577
It does indeed have one solution
which is the word chain hello. Good!

210
00:16:35,660 --> 00:16:41,702
So, beyond that we've ruled out the obvious
case and we need to start doing some real work.

211
00:16:41,960 --> 00:16:45,177
And I think a useful function that we're going to need

212
00:16:45,188 --> 00:16:49,154
is something that's going to
determine the distance between two words.

213
00:16:49,154 --> 00:16:53,540
Which is going to be the amount of
changes you have to make to get between two words.

214
00:16:53,540 --> 00:16:58,628
SP: Yes, or at least whether they
are one step apart from each other.

215
00:16:58,620 --> 00:17:03,840
OC: Yes because once we have a function
that gives us metric and distance between words

216
00:17:03,862 --> 00:17:08,891
I'm hoping I can map over all of these
words and find the neighbors of any word.

217
00:17:08,890 --> 00:17:13,085
The neighbors are going to be
words some distance away... by one.

218
00:17:13,150 --> 00:17:18,480
So let's have... distance which is going to
take two text values and give us back a number.

219
00:17:20,360 --> 00:17:24,274
So if they are the same then
of course, the distance is just zero.

220
00:17:27,340 --> 00:17:29,622
So how we going to do this next...let's see.

221
00:17:29,620 --> 00:17:30,640
(Ollie thinks).

222
00:17:33,074 --> 00:17:37,542
I'm probably going to break the
string apart and treat it as if it were a list.

223
00:17:37,620 --> 00:17:40,365
And I will compare the
head, and see if they're different.

224
00:17:40,365 --> 00:17:43,610
and if they're not the distance there is zero.

225
00:17:43,620 --> 00:17:45,782
But if they are different the difference will be one.

226
00:17:45,794 --> 00:17:49,097
SP: Are you once again assuming
that A and B are the same length?

227
00:17:49,130 --> 00:17:54,160
OC: Yes I'm going to assume
for this function they are the same length.

228
00:17:54,160 --> 00:18:00,530
And if not, well it might actually
work even if they're different lengths.

229
00:18:03,085 --> 00:18:06,765
SP:  What comes to my mind is
zipping the characters of the two together

230
00:18:06,770 --> 00:18:09,620
and seeing how many pairs are not identical.

231
00:18:09,620 --> 00:18:09,737
OC: Yes, that sounds like
the kind of thing we could do.
and seeing how many pairs are not identical.

232
00:18:09,737 --> 00:18:12,902
OC: Yes, that sounds like
the kind of thing we could do.

233
00:18:12,940 --> 00:18:15,920
I think now because we're
zipping, even if they're different lengths

234
00:18:15,920 --> 00:18:18,102
we can probably just drop the extra characters.

235
00:18:18,110 --> 00:18:24,022
And I think we have a zip
function already in the text library...

236
00:18:25,897 --> 00:18:29,620
We do... that's going to compare characters.

237
00:18:30,030 --> 00:18:37,908
It works on text so we can only use it to
zip two pieces of text, which is not so useful.

238
00:18:38,600 --> 00:18:44,331
So take A and B and we will zip A and B.

239
00:18:45,200 --> 00:18:49,170
So I'm going to use type (inaudible) here.

240
00:18:49,910 --> 00:18:56,560
OK, So we need to have a function which
takes a list of pairs of characters to a number.

241
00:19:02,377 --> 00:19:06,560
I think first thing we'll do is map over those,

242
00:19:06,674 --> 00:19:09,862
so we can consider each
pair of characters independently.

243
00:19:13,020 --> 00:19:20,205
Oh dear, I'll ignore that for now,
next type hole we have a pair of characters,

244
00:19:20,217 --> 00:19:21,910
which have to produce something.

245
00:19:30,620 --> 00:19:38,011
So if x is equal to y... then zero otherwise that's one.

246
00:19:38,022 --> 00:19:40,434
That's one possible correction we have to do.

247
00:19:44,710 --> 00:19:47,280
Now we need to take a list of things like a number.

248
00:19:47,280 --> 00:19:51,462
I don't know why it hasn't...
Oh, because B could be any type of numeric.

249
00:19:56,600 --> 00:19:58,457
Ok, so that's good.

250
00:19:58,600 --> 00:20:02,525
So it's hacking into our distance
functions we can switch back to GHCi

251
00:20:02,548 --> 00:20:04,430
and see what it makes of that.

252
00:20:05,740 --> 00:20:10,480
So let's see if the difference
between dog and cog is indeed one.

253
00:20:12,617 --> 00:20:15,794
That's what you would expect. A basic example.

254
00:20:18,765 --> 00:20:22,000
Let's see how we can fit this into our word puzzle.

255
00:20:22,971 --> 00:20:28,540
We're certainly going to
eed the dictionary and our two words.

256
00:20:32,080 --> 00:20:36,480
So I'm going to start with the word A
and we need to find the neighbors of word A.

257
00:20:37,211 --> 00:20:41,051
So I'm going to go over the dictionary, well I'm going to ...

258
00:20:42,068 --> 00:20:49,714
Let's filter the dictionary so we don't have A in it.

259
00:21:03,680 --> 00:21:07,211
That's going to give me a
dictionary that doesn't have A in it.

260
00:21:10,740 --> 00:21:14,240
Maybe if we pair every word with its distance...

261
00:21:14,760 --> 00:21:19,028
so I can take every word in the
dictionary and find its distance against word A.

262
00:21:19,302 --> 00:21:22,777
And then I can take the ones
that just have a distance of 1.

263
00:21:23,010 --> 00:21:26,022
And that again feels like
I'm zipping 2 lists together.

264
00:21:26,650 --> 00:21:28,217
SP: OK.

265
00:21:29,820 --> 00:21:34,525
OC: First we need to map that for every word.

266
00:21:34,770 --> 00:21:39,748
We're going to keep the word and I'm
also going to keep the distance between A and W.

267
00:21:43,510 --> 00:21:46,331
Actually this is like what I'm saying.

268
00:21:46,340 --> 00:21:53,680
Let's say neighbors takes the
dictionary and gives us back a list of words.

269
00:22:04,445 --> 00:22:07,085
And now we've got this map.

270
00:22:07,090 --> 00:22:11,874
And we need to filter this for all
things that have a distance of exactly 1.

271
00:22:11,980 --> 00:22:13,622
So let's filter...

272
00:22:13,620 --> 00:22:14,548
(Ollie types).

273
00:22:23,170 --> 00:22:28,091
It's a bit long there... I'll re-format that slightly.

274
00:22:37,000 --> 00:22:39,954
Bit of a hole there, we can come back to that.

275
00:22:39,970 --> 00:22:42,754
So does that build?

276
00:22:45,257 --> 00:22:47,120
OK, so what have we got here?

277
00:22:49,770 --> 00:22:56,571
Ah, OK, so I've filtered this but I also need
to map it just so it will take the word... so that's A.

278
00:22:57,280 --> 00:23:03,782
And once more, and take just
the word and ignore its distance.

279
00:23:03,988 --> 00:23:06,994
SP: Is there a function for that, is it fst?

280
00:23:07,680 --> 00:23:10,057
OC: Yes, we can use fst there.

281
00:23:23,400 --> 00:23:26,525
Good, so we're back to compiling once more.

282
00:23:27,600 --> 00:23:28,994
So I'll give that a try.

283
00:23:28,990 --> 00:23:29,942
(Ollie types).

284
00:23:41,600 --> 00:23:44,857
Let's find neighbors of dog.

285
00:23:44,868 --> 00:23:46,800
We need the dictionary there as well.

286
00:23:49,760 --> 00:23:52,000
It doesn't seem quite right to me (laughter).

287
00:23:52,010 --> 00:23:57,680
SP: I think this is probably a result
of zipping, and not taking into consideration

288
00:23:57,680 --> 00:24:03,382
that if the lengths of the two words are different,

289
00:24:04,137 --> 00:24:07,691
then zip would finish at the shortest sequence.

290
00:24:07,691 --> 00:24:08,520
OC: Right.

291
00:24:09,930 --> 00:24:16,570
SP: And so, all of these like 'downfall'
would be only one letter away from 'dog'.

292
00:24:16,570 --> 00:24:16,674
So maybe you should only look at the first one.
SP: And so, all of these like 'downfall'
would be only one letter away from 'dog'.

293
00:24:16,674 --> 00:24:19,040
So maybe you should only look at the first one.

294
00:24:19,051 --> 00:24:21,940
OC: Maybe we should be
filtering the dictionary first

295
00:24:21,942 --> 00:24:24,428
on getting words that are only the same length.

296
00:24:24,420 --> 00:24:26,240
We certainly have done that here.

297
00:24:26,240 --> 00:24:28,240
SP: Yes.

298
00:24:28,240 --> 00:24:29,302
(Ollie thinks).

299
00:24:35,874 --> 00:24:40,540
OC: I'm going to bring
in some smaller functions there.

300
00:24:53,570 --> 00:24:56,971
The idea here is I'm probably
going to use the Applicative Syntax

301
00:24:56,970 --> 00:24:59,417
to combine 2 boolean operations together.

302
00:24:59,450 --> 00:25:01,880
So I want to take
things that are not equal to A.

303
00:25:03,940 --> 00:25:06,331
SP: And also the /= operator?

304
00:25:06,450 --> 00:25:07,885
OC: Oh yes, of course.

305
00:25:09,740 --> 00:25:12,370
In fact we'll put that directly in there.

306
00:25:15,680 --> 00:25:18,697
So we need it to satisfy 2 conditions.

307
00:25:23,400 --> 00:25:34,285
We should be able to do this...
it's the length is equal to the length of A.

308
00:25:36,340 --> 00:25:40,194
I think we'll probably be
able to tidy that function up as well.

309
00:25:40,280 --> 00:25:47,154
So I'll take those back out, and we're
going to need to import Control.Applicative.

310
00:25:47,874 --> 00:25:50,662
SP: So I notice here that
even though you presumably knew

311
00:25:50,660 --> 00:25:55,085
that you were going to import Control.Applicative,

312
00:25:55,180 --> 00:26:00,914
your habit is to immediately try
compiling and have the compiler to tell you that.

313
00:26:00,925 --> 00:26:01,325
OC: Yes.

314
00:26:01,420 --> 00:26:07,325
SP: So this is really an analogue of the TDD
work-flow where you are going for the failing test?

315
00:26:07,400 --> 00:26:08,960
OC: That's right yes.

316
00:26:10,697 --> 00:26:18,274
In import Control.Applicative, I want that to
be the last step of this bit of code I'm doing

317
00:26:18,270 --> 00:26:22,400
inaudible import Control.Applicative, and find out I had another syntax

318
00:26:22,450 --> 00:26:24,280
and I have to context switch again.

319
00:26:26,370 --> 00:26:29,737
I've used length from the
prelude here, but we have text values

320
00:26:29,770 --> 00:26:33,862
and length cannot be used on text values.

321
00:26:33,862 --> 00:26:37,314
We're using strings so we need to use T.length.

322
00:26:40,540 --> 00:26:44,000
So hopefully we're back to compiling that.

323
00:26:44,400 --> 00:26:49,371
So let's try that one again,
and see if it makes more sense this time.

324
00:26:51,620 --> 00:26:53,080
That looks a lot better to me.

325
00:26:54,020 --> 00:26:54,925
OK!

326
00:26:59,097 --> 00:27:01,805
SP: Now Ollie could you explain this section here

327
00:27:01,817 --> 00:27:06,217
where you've used the
operators from Control.Applicative.

328
00:27:06,910 --> 00:27:10,262
OC:  We're working under the reader applicative here,

329
00:27:10,310 --> 00:27:15,200
which is basically an applicative
functor that works for function arrows.

330
00:27:15,250 --> 00:27:19,222
So what I want to do is, take the
same argument as I filter over the dictionary

331
00:27:19,280 --> 00:27:20,885
for every word in the dictionary.

332
00:27:20,914 --> 00:27:23,220
I need to check  that that word is not equal to A.

333
00:27:23,220 --> 00:27:27,051
And I also need to check that
its length is equal to the length of A.

334
00:27:27,080 --> 00:27:30,217
So I need to do an operation on the same value.

335
00:27:30,228 --> 00:27:31,165
SP: Right.

336
00:27:31,160 --> 00:27:35,462
OC: So I could have introduced a lambda
here and banged that to a variable called W

337
00:27:35,540 --> 00:27:41,348
and said W is not equal to A and
that the length of W is the length of A.

338
00:27:41,570 --> 00:27:44,902
But by using this syntax here, it's going to

339
00:27:44,902 --> 00:27:48,210
implicitly thread that argument
through to both the functions for me.

340
00:27:48,210 --> 00:27:51,040
So I don't have to worry
about passing the right argument in.

341
00:27:51,050 --> 00:27:54,331
By using the right structure
here that kind of comes for free.

342
00:27:55,280 --> 00:27:59,131
And there's one other thing I want
to tidy up, this is looking a bit weird,

343
00:27:59,210 --> 00:28:02,971
and we've got some helpful
functions in the Data.Function library,

344
00:28:02,980 --> 00:28:05,977
that comes in the base library of Haskell,

345
00:28:05,988 --> 00:28:08,370
so I'm wondering if we can use something there.

346
00:28:08,370 --> 00:28:12,914
I'm going to have a quick look at the base
library just to see if anything looks useful there.

347
00:28:15,540 --> 00:28:17,417
SP: Do you tend to use Hoogle?

348
00:28:18,300 --> 00:28:20,777
OC: I do use Hoogle occasionally but that's more

349
00:28:20,788 --> 00:28:23,310
when I know the function
that I'm going to work with.

350
00:28:23,310 --> 00:28:27,302
Whereas in this case I just want to look
at the types and see if anything stands out.

351
00:28:27,634 --> 00:28:29,910
SP: Because in Hoogle you can search by the type.

352
00:28:29,940 --> 00:28:35,965
OC: Right yes, but here I suppose I'm not
entirely sure what type I'm going to be looking for.

353
00:28:35,977 --> 00:28:39,170
I want to just look through it
and see if anything comes intuitively.

354
00:28:39,170 --> 00:28:41,611
But if we don't find anything
then I will leave it for now.

355
00:28:41,610 --> 00:28:45,800
But it's these combinates down here, like
'on' which is probably going to be the most useful.

356
00:28:45,800 --> 00:28:45,817
So, you can see that 'on' as a typical usage lets you
call the same function on two different arguments.
But it's these combinates down here, like
'on' which is probably going to be the most useful.

357
00:28:45,817 --> 00:28:52,057
So, you can see that 'on' as a typical usage lets you
call the same function on two different arguments.

358
00:28:52,057 --> 00:28:55,390
So let's see if we can use that.

359
00:28:55,870 --> 00:29:00,262
So we're certainly going to be
doing 'on'...well it takes 2 arguments and...

360
00:29:03,497 --> 00:29:06,365
It takes a function of two arguments
and also a function of one argument.

361
00:29:06,420 --> 00:29:09,622
Well our function one argument is T.length,

362
00:29:11,650 --> 00:29:14,605
and our function two arguments is just equality.

363
00:29:15,820 --> 00:29:19,028
So we need the check for equality on length.

364
00:29:19,020 --> 00:29:20,011
(Ollie types).

365
00:29:26,450 --> 00:29:31,691
So you can normally use it
with infix notation like this,

366
00:29:31,931 --> 00:29:35,060
but that's when you've got two arguments to supply.

367
00:29:35,062 --> 00:29:36,765
We're only going to supply one argument.

368
00:29:36,760 --> 00:29:41,245
so I think I'm actually going to switch
this back round and do a normal prefix notation.

369
00:29:41,280 --> 00:29:44,308
So 'on' equality, T.length against 'A',

370
00:29:44,340 --> 00:29:49,154
and it's going to supply us with a
second argument for each word in the dictionary.

371
00:29:49,170 --> 00:29:50,280
SP: Right.

372
00:29:50,860 --> 00:29:54,171
OC: So compile that and we're
going to be told that we need to import it.

373
00:29:54,240 --> 00:30:01,657
So let's bring that in... and that's in... Data.Function.

374
00:30:04,845 --> 00:30:06,800
Good! So that's back to compiling.

375
00:30:06,811 --> 00:30:08,994
And we're back in the hole here.

376
00:30:08,990 --> 00:30:12,937
So I think I'm happy with that,
it's a fairly clean readable description.

377
00:30:13,020 --> 00:30:16,857
We do have quite a lot of loops going on
there, but I'm going to ignore that for now,

378
00:30:16,880 --> 00:30:21,508
Maybe we can optimize that later, but
for now that's certainly solved the problem.

379
00:30:26,834 --> 00:30:31,280
For our actual word puzzle problem, we know
that the words are different, but the same length.

380
00:30:31,570 --> 00:30:34,340
I'm going to find all the neighbors around the word A,

381
00:30:34,340 --> 00:30:38,960
and then try and find all of the
solutions from all of the neighbors of A.

382
00:30:38,982 --> 00:30:40,640
See if any of them gets us to B.

383
00:30:40,800 --> 00:30:42,510
In which case those will be our possible solutions.

384
00:30:42,510 --> 00:30:47,531
So we'll start by taking the
neighbors of A, and the same dictionary.

385
00:30:47,530 --> 00:30:53,268
inaudible

386
00:30:53,540 --> 00:30:54,600
I've got a hole here.

387
00:30:54,600 --> 00:30:58,628
So I'm going to write some sort of
function that will take all these neighbors.

388
00:30:58,680 --> 00:31:00,510
Let's have a look at the type of that.

389
00:31:02,000 --> 00:31:06,137
We're going to have a list of text
and we need to go to a list of word chains.

390
00:31:07,177 --> 00:31:09,622
So that list of text is all the possible neighbors.

391
00:31:09,725 --> 00:31:17,965
So I'm going to map over that and now I
have the function that goes from  text to word chain.

392
00:31:20,600 --> 00:31:23,954
So how is best to do this?

393
00:31:23,950 --> 00:31:32,594
I feel like I probably need to go to a list of word chains inaudible, a new word puzzle again.

394
00:31:32,617 --> 00:31:35,880
and eventually we'll reach a base
case where the two words are equal.

395
00:31:38,940 --> 00:31:42,085
Even though this has the same
type, I want to see what we get to.

396
00:31:42,080 --> 00:31:44,285
We're going to be using the same dictionary.

397
00:31:44,777 --> 00:31:52,731
And were going to go to B and go on to N and N to B.

398
00:31:52,788 --> 00:31:55,120
That's probably not going to type check.

399
00:31:57,600 --> 00:31:59,970
We couldn't match a list of text with text.

400
00:32:01,040 --> 00:32:03,714
Oh! that's because the word chain is a list of text.

401
00:32:04,140 --> 00:32:07,840
It's expecting a single word chain
but we've actually got many word chains.

402
00:32:07,840 --> 00:32:10,045
So I think the problem here is that...

403
00:32:10,880 --> 00:32:15,382
if we put another type hole there,
we'll see that this could actually typecheck,

404
00:32:15,520 --> 00:32:18,491
provided we had a function that
went from a list of lists of word chains

405
00:32:18,502 --> 00:32:20,050
to just a list of word chains.

406
00:32:20,290 --> 00:32:22,251
Which is of course 'concat'.

407
00:32:22,800 --> 00:32:25,462
And we have a function in the standard library...

408
00:32:26,548 --> 00:32:29,000
I'm going to remove that hole.

409
00:32:29,000 --> 00:32:33,462
There's a function in the standard library
that does these two things together... concatMap,

410
00:32:33,485 --> 00:32:35,570
because it's such a common operation.

411
00:32:36,160 --> 00:32:38,697
ConcatMap that there...

412
00:32:41,451 --> 00:32:47,400
and I guess we'll leave that as a hole
for now and play with it in GHCi again.

413
00:32:47,400 --> 00:32:52,525
If I load the dictionary, I should be able
to now try of one of the example problems.

414
00:32:52,537 --> 00:32:59,314
Let's try word puzzle inaudible dog to cat.

415
00:33:04,450 --> 00:33:07,693
That is impressively slow right now (laughter)

416
00:33:07,817 --> 00:33:12,674
And I'm not sure if that's because this doesn't
terminate or because we're being so inefficient.

417
00:33:12,670 --> 00:33:19,657
SP: Now... By the time you go from dog
to dot one of the neighbors of dot is dog.

418
00:33:19,668 --> 00:33:22,460
OC: So we're actually
going back on ourselves probably.

419
00:33:22,460 --> 00:33:24,346
SP: That's potentially what's happening.

420
00:33:24,628 --> 00:33:26,777
OC: That sounds very reasonable to me. Yes.

421
00:33:28,370 --> 00:33:32,653
So we need to probably carry some extra state around.

422
00:33:33,986 --> 00:33:36,440
So I'm going to put this down here.

423
00:33:39,800 --> 00:33:43,946
We probably need to remove
something from the dictionary

424
00:33:43,970 --> 00:33:48,786
which I guess is going to be when we go here.

425
00:33:49,250 --> 00:33:53,268
It will probably want to be a
dictionary without the word N itself.

426
00:33:54,293 --> 00:33:56,213
And also not A.

427
00:33:59,650 --> 00:34:02,102
I've already removed A here,

428
00:34:02,114 --> 00:34:05,451
so I'm wondering if maybe that
should be done further up here.

429
00:34:07,800 --> 00:34:10,034
We'll try it anyway, let's just try it here.

430
00:34:10,034 --> 00:34:12,030
(Ollie types).

431
00:34:18,250 --> 00:34:23,314
So let's filter the dictionary
for stuff that's not equal to N.

432
00:34:23,310 --> 00:34:24,240
(Ollie types).

433
00:34:28,280 --> 00:34:31,880
It's still happy compiling... which is good.

434
00:34:38,080 --> 00:34:41,257
That's better but apparently
we now have no solutions at all.

435
00:34:41,250 --> 00:34:44,813
At least we do terminate. (laughter).

436
00:34:46,546 --> 00:34:49,680
SP: So termination but wrong
is better than no termination.

437
00:34:49,680 --> 00:34:53,325
OC: I think so. At least we know
that it will eventually deliver an answer

438
00:34:53,337 --> 00:34:54,811
even if it is the wrong answer.

439
00:34:55,097 --> 00:34:57,360
So what I want to check now...

440
00:34:57,380 --> 00:35:01,440
We expected this sort of chain dog, cog, cot to cat,

441
00:35:01,474 --> 00:35:05,497
so maybe if we just try cot to
cat and see if we get that solution.

442
00:35:05,530 --> 00:35:11,794
OC: For the smallest thing I
can think of that was cot to cat.

443
00:35:12,186 --> 00:35:14,800
Again that seems to have no solutions.

444
00:35:19,760 --> 00:35:24,605
It does indeed contain cat it's right there
at the start, so we should certainly be seeing that.

445
00:35:24,640 --> 00:35:30,868
So let's see ... take the neighbors around A...

446
00:35:32,582 --> 00:35:35,908
And for each of those we call a word puzzle.

447
00:35:35,942 --> 00:35:37,074
(Ollie ponders).

448
00:35:42,626 --> 00:35:43,986
The same target...

449
00:35:43,980 --> 00:35:45,120
(Ollie ponders).

450
00:35:50,880 --> 00:35:55,746
SP: So here you're excluding
words that are the neighbor?

451
00:35:56,020 --> 00:35:57,000
OC: Yes

452
00:35:57,026 --> 00:36:00,613
SP: Perhaps instead you should be excluding A.

453
00:36:03,337 --> 00:36:06,240
Because that's the one you
don't want to return to later.

454
00:36:09,000 --> 00:36:10,942
You know that you've got that one.

455
00:36:11,310 --> 00:36:12,662
OC: Great job!

456
00:36:15,880 --> 00:36:21,942
So we don't want to come back to where
we started that certainly does make sense.

457
00:36:21,940 --> 00:36:22,914
(Ollie types).

458
00:36:30,011 --> 00:36:33,005
And now we go from cot to cat.

459
00:36:35,330 --> 00:36:41,542
We're certainly finding some solutions
but never stopping the search (laughter).

460
00:36:41,650 --> 00:36:44,445
Which is interesting. So, what's going on there?

461
00:36:44,754 --> 00:36:46,440
I guess it's...

462
00:36:46,740 --> 00:36:48,845
When we loop over there this...

463
00:36:49,380 --> 00:36:52,533
Well I'm interested to see
if this will actually terminate

464
00:36:52,530 --> 00:36:55,600
and be the same length as all the neighbors of cot.

465
00:36:59,066 --> 00:37:00,733
But maybe this won't terminate.

466
00:37:00,730 --> 00:37:01,782
(Ollie thinks).

467
00:37:07,420 --> 00:37:09,497
OK, maybe not (laughter).

468
00:37:09,977 --> 00:37:13,554
SP: The fan indicated that some
work was being done (laughter).

469
00:37:13,565 --> 00:37:19,954
OC: Although, are we actually able to fully compute
all of the neighbors around "cot"? We certainly are OK.

470
00:37:20,020 --> 00:37:25,268
So, we're not hitting our base
case properly, which is interesting.

471
00:37:34,530 --> 00:37:39,794
We're certainly getting here
because that's where we return the result.

472
00:37:49,480 --> 00:37:54,053
Maybe if we take all
the solutions of neighbor.

473
00:37:54,050 --> 00:37:54,971
(Ollie types).

474
00:37:59,160 --> 00:38:05,462
So if we couldn't find any solutions there then
we won't be able to find any bigger solutions.

475
00:38:15,170 --> 00:38:20,365
If we did find a solution then
we should be able to go for it.

476
00:38:23,211 --> 00:38:26,010
Yes, that seems reasonable.

477
00:38:27,600 --> 00:38:30,800
So I think that's largely OK.

478
00:38:33,386 --> 00:38:35,213
We've got an error there somewhere.

479
00:38:36,220 --> 00:38:42,080
So N is expecting a word
chain that's actually a piece of text.

480
00:38:43,540 --> 00:38:45,577
That seems somewhat odd.

481
00:38:49,770 --> 00:38:53,600
SP: So the word puzzle
will return a list of solutions,

482
00:38:53,620 --> 00:38:59,897
so do you not need to prepend each
of the items in that list of solutions?

483
00:38:59,897 --> 00:39:01,337
OC: Ah! of course, yes.

484
00:39:02,050 --> 00:39:05,293
SP: So I think it would be just 'map of' prepend.

485
00:39:05,290 --> 00:39:10,045
OC: Yes. We could also use Applicative
Syntax which is not much different.

486
00:39:10,080 --> 00:39:12,450
But we could also do something like that.

487
00:39:12,651 --> 00:39:15,450
For every S we're going to prepend it with N.

488
00:39:15,462 --> 00:39:16,285
SP: Right.

489
00:39:18,973 --> 00:39:21,413
OC: OK, so we're back to compiling again.

490
00:39:21,410 --> 00:39:22,331
(Ollie types).

491
00:39:33,600 --> 00:39:37,346
Let's see if we can make any sense of that.

492
00:39:37,680 --> 00:39:40,891
Cat to cat and then
every other word in the dictionary.

493
00:39:40,891 --> 00:39:43,940
We're eventually getting to
cat. That's certainly happening.

494
00:39:45,826 --> 00:39:48,986
I guess that is a valid word chain (laughter).

495
00:39:49,080 --> 00:39:52,466
Is it just that there are this
many possible word chains I guess.

496
00:39:53,060 --> 00:39:57,485
The first one is certainly wrong though.
That's certainly not a chain from cat to cat.

497
00:39:57,485 --> 00:39:58,970
That should be cot to cat.

498
00:40:01,360 --> 00:40:04,080
I better start fixing that bug.

499
00:40:04,080 --> 00:40:04,777
(Silence).

500
00:40:08,450 --> 00:40:09,805
They are very long chains.

501
00:40:09,817 --> 00:40:11,920
SP: Cod to cat was the next one.

502
00:40:12,866 --> 00:40:15,110
OC: They're certainly valid chains though.

503
00:40:15,110 --> 00:40:15,640
SP: Yes.

504
00:40:15,640 --> 00:40:16,651
(Ollie thinks).

505
00:40:19,370 --> 00:40:26,080
OC: So what's going wrong on that first one though?

506
00:40:27,053 --> 00:40:28,386
We have cat.

507
00:40:30,773 --> 00:40:33,653
The problem is I think
we should have been prepending...

508
00:40:35,466 --> 00:40:38,906
A rather than N - or possibly both of them.

509
00:40:38,900 --> 00:40:40,034
Let's just see what that is,

510
00:40:40,040 --> 00:40:43,131
because we want to go from the word we're starting at.

511
00:40:43,131 --> 00:40:45,130
(Ollie types).

512
00:40:48,910 --> 00:40:52,080
And now we certainly have
the right solution at the front.

513
00:40:52,080 --> 00:40:54,506
And we can of course exploit laziness,

514
00:40:54,500 --> 00:40:58,114
hopefully just see the very
first solution and it terminates.

515
00:40:58,480 --> 00:41:01,851
And finally that's one word
chain that has certainly got us there.

516
00:41:01,940 --> 00:41:03,013
SP: OK.

517
00:41:03,737 --> 00:41:05,988
OC: So we need to decide
where we want to go next.

518
00:41:05,980 --> 00:41:09,348
If we want to find all possible
word chains in a short amount of time.

519
00:41:09,348 --> 00:41:12,980
Or if we want to make sure
that this is definitely the shortest chain.

520
00:41:15,220 --> 00:41:21,702
At this point, finding the shortest chain
we just need to sort by the length descending.

521
00:41:23,173 --> 00:41:26,000
But this now, because we're sorting the entire list,

522
00:41:26,000 --> 00:41:31,017
Is going to have to consider
the entire set of possible solutions.

523
00:41:31,060 --> 00:41:37,474
SP: We probably need to think
about expanding the chains progressively.

524
00:41:39,530 --> 00:41:44,480
And returning first the ones that are the shortest.

525
00:41:44,480 --> 00:41:44,697
OC: Right so a greedier search, as we go through.
And returning first the ones that are the shortest.

526
00:41:44,697 --> 00:41:47,573
OC: Right so a greedier search, as we go through.

527
00:41:50,250 --> 00:41:56,228
I'm going to try and see how long it
takes to solve the whole list of solutions.

528
00:41:56,380 --> 00:42:00,582
We have a function here,
'sort by' which takes a list of type A.

529
00:42:00,580 --> 00:42:04,262
And if we have a way to compare
them for an ordering we can do something.

530
00:42:04,386 --> 00:42:10,426
So Data.Function also has,
or it might be in Data.Ord

531
00:42:12,400 --> 00:42:14,200
We have comparing.

532
00:42:14,570 --> 00:42:21,453
So we can say comparing on length [inaudible]

533
00:42:22,680 --> 00:42:26,217
Which is just what we want,
a word chain as a list of texts.

534
00:42:27,490 --> 00:42:32,468
So sort by comparing length.

535
00:42:35,330 --> 00:42:37,588
And it's certainly not a good solution.

536
00:42:37,580 --> 00:42:43,120
In the original spec of the kata it said it
should be returning results in less than a second.

537
00:42:43,142 --> 00:42:44,970
But we're well over that.

538
00:42:59,080 --> 00:43:05,234
So I think we got our one solution
there from cog to cat, purely by chance.

539
00:43:05,245 --> 00:43:07,540
Because cat comes first in the dictionary

540
00:43:07,546 --> 00:43:10,866
and what we're doing here
is basically a depth first search.

541
00:43:10,860 --> 00:43:13,897
So the moment we hit that one
neighbor, we go as far away as we can

542
00:43:13,897 --> 00:43:18,194
to try and get all the way to cat which
is not really the most efficient use of our time.

543
00:43:18,200 --> 00:43:23,051
We're going to need to change this from
a depth first solution to a breadth first solution.

544
00:43:23,080 --> 00:43:25,933
What we're going to do is go over each of the neighbors

545
00:43:25,930 --> 00:43:29,348
and try to expand that word
chain of the neighbor to go one bigger,

546
00:43:29,640 --> 00:43:33,253
and hopefully we will eventually end at B.

547
00:43:33,810 --> 00:43:37,862
B is certainly in the dictionary, in which
case we've finished our breadth first search.

548
00:43:37,874 --> 00:43:40,000
At least to get the shortest path.

549
00:43:40,411 --> 00:43:42,420
SP: And since you're removing the word each time

550
00:43:42,420 --> 00:43:46,560
eventually you won't be
able to expand your search any further

551
00:43:46,580 --> 00:43:49,546
because you'll run out of
neighbors for the next word.

552
00:43:50,320 --> 00:43:53,706
OC, Yes. So I'm going to leave
word puzzle alone for the moment.

553
00:43:53,770 --> 00:43:58,697
Instead let's try and use
some kind of expand function.

554
00:43:58,720 --> 00:44:04,560
So that's going to take a word chain and give
us back all possible expansions of the word chain,

555
00:44:05,360 --> 00:44:07,746
We need the dictionary there as well.

556
00:44:09,337 --> 00:44:11,257
I think that's what I want to do.

557
00:44:20,840 --> 00:44:25,405
We're going to work from the head
of the chain and try to expand that.

558
00:44:26,600 --> 00:44:32,342
There is obviously the case where
we've got no words at all in the chain.

559
00:44:32,560 --> 00:44:35,702
That's not really an invariant
I want to have in the code.

560
00:44:35,720 --> 00:44:39,740
But we should probably deal with it anyway
in which case there's no expansions on that.

561
00:44:40,960 --> 00:44:47,920
Otherwise we have a word on some other words.

562
00:44:48,060 --> 00:44:56,822
And now by all the neighbors in the dictionary W
and put those on the word chain we've got so far.

563
00:44:56,820 --> 00:44:57,782
(Ollie types).

564
00:45:04,370 --> 00:45:11,005
So neighbors gives us a list of words
and that's already a list of word chains.

565
00:45:15,770 --> 00:45:23,577
I find the neighbors of w
but I need to use a list cons there.

566
00:45:34,000 --> 00:45:38,514
I'm going to move away from
putting this there... Just map over these.

567
00:45:41,965 --> 00:45:46,420
SP: That's not a bad example
of a case for a miscomprehension.

568
00:45:46,570 --> 00:45:47,805
OC: OK.

569
00:45:49,691 --> 00:45:53,440
OC: Sure well let's try
another one of those conventions.

570
00:45:53,480 --> 00:45:56,891
We need to... go over there.

571
00:45:56,910 --> 00:46:01,200
Neighbors and dict and w...

572
00:46:01,200 --> 00:46:01,874
(Silence).

573
00:46:08,370 --> 00:46:11,920
And we'll put that into binding n.

574
00:46:14,050 --> 00:46:17,613
Now I need to produce a single word chain here.

575
00:46:18,900 --> 00:46:22,400
That will be n, w, ws, I think.

576
00:46:26,340 --> 00:46:28,400
And we're back to compiling again - good.

577
00:46:29,920 --> 00:46:35,302
So I should be able to load the dictionary in...

578
00:46:39,370 --> 00:46:44,640
and expand and type that back up...

579
00:46:45,720 --> 00:46:49,520
And word chains, so why don't
I just start with the word cat.

580
00:46:50,620 --> 00:46:54,811
So that seems to be doing what
I would expect, the expansion is on the front.

581
00:46:55,740 --> 00:46:59,680
So now let's see if we can
feed this back in to our word puzzle.

582
00:47:01,620 --> 00:47:05,931
I think I'll leave this around for
now and just comment that out.

583
00:47:05,930 --> 00:47:06,868
(Ollie types).

584
00:47:09,880 --> 00:47:14,057
So we're going to start at word a
and we need to reach word b.

585
00:47:15,200 --> 00:47:20,571
So we'll start with a word
chain which is just the word a.

586
00:47:20,610 --> 00:47:26,274
That's a chain of one word, and I will
expand that to a list of possible word chains.

587
00:47:27,131 --> 00:47:29,980
Let's see what I need to do with that.

588
00:47:31,510 --> 00:47:36,022
Well that one actually works so far,
but it's certainly not going to be the solution.

589
00:47:38,173 --> 00:47:40,333
Now I should be able to...

590
00:47:40,330 --> 00:47:41,302
(Ollie types).

591
00:47:44,960 --> 00:47:47,291
That's fine inaudible.

592
00:47:47,880 --> 00:47:51,586
So that's just a one level breadth-first search.

593
00:47:51,580 --> 00:47:54,525
We need to go a bit further
than that to find something useful.

594
00:47:55,142 --> 00:48:08,182
So I think now we just need to keep
expanding until we have B at the front of the list.

595
00:48:08,182 --> 00:48:08,190
SP: Yes.
So I think now we just need to keep
expanding until we have B at the front of the list.

596
00:48:08,190 --> 00:48:08,960
SP: Yes.

597
00:48:11,110 --> 00:48:13,786
OC: We can probably use iterate to do that.

598
00:48:13,786 --> 00:48:16,213
SP: Or until you don't have any further expansions.

599
00:48:16,210 --> 00:48:22,125
OC: Ah! that's one thing we've
not done so far is reducing this dictionary.

600
00:48:26,493 --> 00:48:27,826
Where would I put that in?

601
00:48:27,820 --> 00:48:35,200
So after one expansion, this is probably
returning me a smaller dictionary as well.

602
00:48:36,020 --> 00:48:39,220
When I expand a word chain
the dictionary becomes smaller.

603
00:48:45,480 --> 00:48:46,940
SP: That would be reasonable.

604
00:48:46,940 --> 00:48:49,373
OC: Let's see what we get with that...

605
00:48:52,650 --> 00:48:55,226
So word chain and the dictionary.

606
00:49:00,777 --> 00:49:05,725
SP: The alternative is that you
keep the dictionary the same each time,

607
00:49:05,725 --> 00:49:10,240
but you don't allow the addition into
the chain of a word that's already in it.

608
00:49:11,310 --> 00:49:15,760
OC: Yes, but we're going to keep
searching through a word chain every time.

609
00:49:15,770 --> 00:49:20,982
It feels like we just make the dictionary smaller
then our neighbors gradually become smaller.

610
00:49:21,000 --> 00:49:24,373
So we return the list of
possible word chains as before.

611
00:49:27,940 --> 00:49:32,994
Now I'm thinking it would be nice
if we had a richer type for our dictionary.

612
00:49:33,053 --> 00:49:36,413
Like a set or something like
that, so I can do a set difference

613
00:49:36,413 --> 00:49:39,306
and easily remove a set of words from it.

614
00:49:39,306 --> 00:49:40,306
SP: Yes.

615
00:49:41,340 --> 00:49:45,291
OC: So that's going to be a bit of a
backtrace but I think it's going to be worth it.

616
00:49:45,333 --> 00:49:51,960
So I'm going to import the Data.Set library as well.

617
00:49:53,200 --> 00:49:57,040
And that also works best when you import qualified.

618
00:50:00,973 --> 00:50:03,946
We need to depend on
the containments library for that.

619
00:50:06,822 --> 00:50:09,120
And to get that I need to put that in there.

620
00:50:11,110 --> 00:50:13,893
Actually, it looks as if we already have that.

621
00:50:17,120 --> 00:50:18,786
Bit of a misnomer there I reckon.

622
00:50:21,588 --> 00:50:28,100
So now that we've got set
imported maybe we can make this...

623
00:50:28,320 --> 00:50:33,371
So rather than having a list
of text, let's go with a set text.

624
00:50:33,610 --> 00:50:38,891
And we'll just ask the compiler to tell
us everything we need to update, to change.

625
00:50:40,746 --> 00:50:43,260
The first thing we need to do
is return a set rather than a list.

626
00:50:43,260 --> 00:50:48,388
That's easy enough, we can just say S.fromList.

627
00:50:48,680 --> 00:50:50,820
Which takes a list and turns it into a set.

628
00:50:51,893 --> 00:50:57,373
Next, rather than checking
a list to see if an element's there,

629
00:50:57,420 --> 00:51:04,468
use S.member, which checks to see
if an element is a member of a set.

630
00:51:05,573 --> 00:51:07,600
Likewise going to do the same here...

631
00:51:17,640 --> 00:51:22,194
That has put a hole back there, we'll come back to that.

632
00:51:22,205 --> 00:51:23,211
(Ollie types).

633
00:51:25,820 --> 00:51:31,960
That should probably just return...

634
00:51:34,866 --> 00:51:36,493
like that...

635
00:51:41,440 --> 00:51:47,106
The filter is for lists but we have
a set so we ask S.filter to filter a set.

636
00:51:56,240 --> 00:51:58,306
I'll check the type of that in there.

637
00:52:05,370 --> 00:52:09,142
OK, I've some idea of where that error came up.

638
00:52:10,800 --> 00:52:15,920
Ah yes,  we can't map over a set like that.

639
00:52:17,813 --> 00:52:23,813
Do we have that... yes we do...
so we just change that to S.map

640
00:52:24,866 --> 00:52:29,510
and again to S.filter, S.map.

641
00:52:29,860 --> 00:52:33,828
Now this is not going to give us a list
of text, it's going to give us a set of text.

642
00:52:39,880 --> 00:52:46,893
SP: There are built in facilities like traversible.

643
00:52:48,057 --> 00:52:53,211
Does that help with this sort of code where
you change from one data type to another?

644
00:52:53,771 --> 00:52:57,474
There are some generalized forms
of some of these functions aren't there?

645
00:52:57,540 --> 00:53:01,908
OC: Right. We can't generalize map
I don't think because this is a set.

646
00:53:01,908 --> 00:53:05,862
and sets have the constraint that the
things inside the set must be order-able.

647
00:53:05,862 --> 00:53:06,213
SP: OK.

648
00:53:06,213 --> 00:53:06,240
OC: So we can't map between our 3 types because
SP: OK.

649
00:53:06,240 --> 00:53:08,480
OC: So we can't map between our 3 types because

650
00:53:08,493 --> 00:53:10,840
we wouldn't necessarily map
them to something that's order-able.

651
00:53:10,850 --> 00:53:14,640
For filter, there's probably some stuff in 

652
00:53:14,651 --> 00:53:18,468
Data.Foldable that will
probably let us filter the set.

653
00:53:18,540 --> 00:53:23,200
But I think I'm quite happy being explicit
that we're working with sets here.

654
00:53:23,710 --> 00:53:27,131
I don't think generalizing would
give us much of a benefit here.

655
00:53:27,170 --> 00:53:31,093
SP: Why I was wondering
is because I like to use that myself.

656
00:53:33,440 --> 00:53:38,280
OC: Now we may not be able to
use the list comprehension anymore.

657
00:53:38,280 --> 00:53:39,577
Because we certainly don't have the list.

658
00:53:39,588 --> 00:53:42,460
What we could do though is just go to a list.

659
00:53:44,770 --> 00:53:47,680
We could turn this into a list.

660
00:53:47,680 --> 00:53:48,605
(Ollie types).

661
00:53:52,190 --> 00:53:54,651
OK, and now we're back to trying to solve this.

662
00:53:55,417 --> 00:53:58,662
To recap where we were, we wanted to
have the dictionary become smaller and smaller.

663
00:54:00,220 --> 00:54:03,497
So we return the word chain and
now we need to return the dictionary.

664
00:54:04,480 --> 00:54:08,091
but without a set of words
that we've already considered.

665
00:54:09,300 --> 00:54:16,022
I believe those are going to be the
head of chains that we just expanded to,

666
00:54:16,022 --> 00:54:18,410
So that will be all the neighbors again.

667
00:54:19,570 --> 00:54:26,605
Although maybe it's more beneficial to bring
more neighbors out as a separate binding.

668
00:54:33,680 --> 00:54:36,274
So now we can take the
dictionary without any of the neighbors.

669
00:54:36,274 --> 00:54:39,020
I've got a slightly smaller dictionary now.

670
00:54:39,257 --> 00:54:41,405
And that still type checks.

671
00:54:45,794 --> 00:54:47,257
We certainly want to call expand.

672
00:54:47,250 --> 00:54:49,211
We need to work out what
were going to do with that result.

673
00:54:49,360 --> 00:54:53,737
We have to write a function that's going
to take a list of word chains in the dictionary,

674
00:54:53,771 --> 00:54:55,708
and eventually gets to a word chain.

675
00:54:59,371 --> 00:55:04,845
I think we'll end up using some
functions that are already in prelude anyway.

676
00:55:04,840 --> 00:55:08,525
But let's just follow the types
manually, and see what we end up with.

677
00:55:09,194 --> 00:55:11,491
OC: We have some function
f that's going to take a chain...

678
00:55:11,490 --> 00:55:18,434
and a new dictionary and it needs to
do something, and call f there as well.

679
00:55:22,720 --> 00:55:27,737
Now we want to expand every single one
of these chains using the smaller dictionary.

680
00:55:27,730 --> 00:55:34,034
So do something with chain
and chain is of course not...

681
00:55:34,060 --> 00:55:36,920
These type holes aren't really helping us anymore... 

682
00:55:37,030 --> 00:55:39,240
We just have to trust our intuition a bit more.

683
00:55:39,645 --> 00:55:41,885
But I should be able to map expand.

684
00:55:48,782 --> 00:55:50,725
I should bring this down a little bit.

685
00:55:54,920 --> 00:56:00,080
Expand takes the dictionary in first
position, and a word chain to expand second.

686
00:56:00,142 --> 00:56:02,102
So that's going to work quite nicely.

687
00:56:03,068 --> 00:56:04,668
Apart from Application.

688
00:56:05,382 --> 00:56:07,691
So that was a list of chains.

689
00:56:07,690 --> 00:56:08,354
(Silence).

690
00:56:16,085 --> 00:56:18,154
We're going in the right direction there.

691
00:56:20,210 --> 00:56:26,720
We need to go from a list of a list of
word chains, to probably a single word chain.

692
00:56:27,074 --> 00:56:30,994
OK, so expanded every chain.

693
00:56:32,080 --> 00:56:34,548
I'm going to have to call F on that again.

694
00:56:42,990 --> 00:56:48,457
So, I think we're struggling to find a nice kind
of way to repeatedly apply this expand function,

695
00:56:48,450 --> 00:56:51,954
and what comes to mind here is, it looks like an unfold

696
00:56:51,965 --> 00:56:55,348
which is like the dual to fold,
which a lot of people are familiar with.

697
00:56:55,380 --> 00:56:59,051
When you fold you have a list and
you keep reducing it into something smaller.

698
00:56:59,051 --> 00:57:02,045
Whereas in this case we actually have
something and want to get something bigger.

699
00:57:02,057 --> 00:57:05,405
Which as unfolding until the point where we maybe can't go any bigger.

700
00:57:06,200 --> 00:57:12,331
So we have a function in
the Prelude to do that which is unfoldr.

701
00:57:14,290 --> 00:57:19,188
But that requires for this function that we
have something that returns Maybe any value.

702
00:57:19,462 --> 00:57:23,302
But this actually looks quite a lot
like what we have in expand here.

703
00:57:23,565 --> 00:57:25,182
But we don't have a Maybe here.

704
00:57:25,750 --> 00:57:29,417
So the Maybe represents the fact
that you can't actually go any bigger.

705
00:57:29,417 --> 00:57:32,430
Which is what we were
modeling here with this pattern match,

706
00:57:32,690 --> 00:57:36,925
where we simply said we have an empty
list of word chains. But that felt a bit weird,

707
00:57:36,925 --> 00:57:40,970
So maybe let's try bringing in a Maybe there.

708
00:57:42,200 --> 00:57:44,171
SP: Maybe let's Maybe (laughter).

709
00:57:45,540 --> 00:57:51,405
OC: OK, so in this case there's
nothing we can do, so we just say nothing.

710
00:57:51,420 --> 00:57:56,834
Whereas in this case, we have
just that result of word chains.

711
00:57:57,691 --> 00:57:59,850
NARRATOR: We're going to speed through this section

712
00:57:59,850 --> 00:58:03,234
because Ollie and Steve found
themselves deep into a Rabbit hole.

713
00:58:03,860 --> 00:58:07,280
They eventually backtracked
on this idea of using unfoldr.

714
00:58:07,890 --> 00:58:11,120
So let's skip ahead to the
section where they changed course.

715
00:58:14,740 --> 00:58:17,725
SP: You are typing faster
than I can think (laughter).

716
00:58:18,370 --> 00:58:23,540
OC: Even though we're using unfold,
which does feel like the right tool to be using.

717
00:58:23,540 --> 00:58:23,874
I think we're getting
ourselves into a bit of a muddle here.
OC: Even though we're using unfold,
which does feel like the right tool to be using.

718
00:58:23,874 --> 00:58:26,388
I think we're getting
ourselves into a bit of a muddle here.

719
00:58:26,380 --> 00:58:30,240
And one of the big culprits is what
we're doing in this expand function.

720
00:58:30,605 --> 00:58:35,348
So I'm going to try and simplify that
and see if a nice solution comes out there.

721
00:58:35,348 --> 00:58:36,890
What I'm going to go with instead ...

722
00:58:38,160 --> 00:58:41,577
Expand's going to take a single
word chain and the dictionary.

723
00:58:42,100 --> 00:58:47,840
And it's going to expand that to a list of
possible word chains and smaller dictionaries.

724
00:58:48,160 --> 00:58:48,531
SP: OK.

725
00:58:48,540 --> 00:58:50,400
OC: So whenever I make one expansion,

726
00:58:50,400 --> 00:58:54,720
I consider all of the neighbors
around the first word of the word chain.

727
00:58:54,760 --> 00:58:58,091
And for each of those new word
chains, I'll have the neighbor at the front.

728
00:58:58,100 --> 00:59:02,982
And we will remove that word from the dictionary,
because we don't want to go back on ourselves.

729
00:59:03,730 --> 00:59:07,737
So I have a word chain with
nothing in but there's nothing I can do.

730
00:59:08,560 --> 00:59:10,457
We have seen this one before.

731
00:59:10,490 --> 00:59:15,154
but otherwise if we have a chain,
and it starts with the word w,

732
00:59:15,150 --> 00:59:24,777
We have the dictionary and then
we need to take the neighbors around w,

733
00:59:24,780 --> 00:59:28,000
which will equal n...
and put that on the front of the chain.

734
00:59:28,030 --> 00:59:36,194
So n is going to be the neighbors
using the same dictionary around w.

735
00:59:37,820 --> 00:59:41,045
But we also need to return
this slightly smaller dictionary.

736
00:59:43,740 --> 00:59:50,205
Tuple that up ... with the same dictionary.

737
00:59:52,485 --> 00:59:54,540
But we'll delete n from the dictionary.

738
00:59:54,720 --> 00:59:55,388
SP: Right.

739
00:59:56,417 --> 00:59:57,874
OC: Lets try that...

740
00:59:59,902 --> 01:00:01,451
Get rid of our old definition.

741
01:00:02,710 --> 01:00:05,657
You can see this is very similar
to what we had in expandOne.

742
01:00:05,657 --> 01:00:07,820
So breaking the problem into a smaller one.

743
01:00:07,820 --> 01:00:08,742
(Ollie types).

744
01:00:13,697 --> 01:00:15,194
So ignore this...

745
01:00:15,840 --> 01:00:19,542
Let's keep that.

746
01:00:22,050 --> 01:00:26,971
And that's expecting a list of text from
the other set, so we need to turn that into a list.

747
01:00:36,570 --> 01:00:37,828
We're back - good!

748
01:00:41,720 --> 01:00:49,542
I guess if we load the dictionary in
then we should be able to use expand with...

749
01:00:50,045 --> 01:00:52,765
Let's just look at the one expansion of cat.

750
01:00:53,051 --> 01:00:54,422
Oops...

751
01:00:54,860 --> 01:00:57,462
So what we're doing here is we
end up printing the out dictionary as well.

752
01:00:58,034 --> 01:01:00,110
SP: Yes, because it was in the Tuple.

753
01:01:02,000 --> 01:01:03,348
OC: Map first over that...

754
01:01:06,571 --> 01:01:08,777
and we see just the one level expansion.

755
01:01:08,771 --> 01:01:10,382
SP: Fantastic.

756
01:01:10,850 --> 01:01:15,668
OC: So we're going to repeatedly
apply this, but we'll keep the small chains.

757
01:01:15,668 --> 01:01:17,850
Then we will have the bigger chains on the end.

758
01:01:17,862 --> 01:01:22,720
So that's basically giving us a
flattening of a tree, of a breadth-first search.

759
01:01:22,770 --> 01:01:28,137
Which I think is going to be better than
the depth first search that we saw earlier.

760
01:01:28,142 --> 01:01:28,650
SP:  Yes.

761
01:01:30,788 --> 01:01:35,108
I'm going to do a little function up here called go.

762
01:01:38,620 --> 01:01:45,085
Go is going to take a list
of word chains and dictionaries.

763
01:01:46,817 --> 01:01:48,840
And this becomes apparent

764
01:01:48,931 --> 01:01:51,480
you can see how I'm
going to pull recursively.

765
01:01:51,480 --> 01:01:54,685
And it's going to give us back a
list of word chains and dictionaries.

766
01:01:54,685 --> 01:01:57,880
and that's going to let us
repeatedly apply this to ourselves.

767
01:01:57,880 --> 01:02:00,491
OC: So if we have nothing in the first [inaudible]

768
01:02:00,770 --> 01:02:03,220
There's nothing we can do, we simply return that

769
01:02:03,925 --> 01:02:08,308
Otherwise we have some
chains so what we can do...

770
01:02:08,697 --> 01:02:11,120
SP: We have some
combinations of chains and dictionaries.

771
01:02:11,302 --> 01:02:12,994
OC: Yes, some chains and dictionaries indeed.

772
01:02:12,994 --> 01:02:14,634
but for every word chain in the dictionary

773
01:02:14,634 --> 01:02:17,880
we want to expand that word
chain using its own dictionary.

774
01:02:17,880 --> 01:02:19,450
So I'm going to map over chains,

775
01:02:21,240 --> 01:02:23,491
and what we'll have here is a word chain

776
01:02:23,491 --> 01:02:25,697
and a dictionary, which we will expand

777
01:02:26,017 --> 01:02:27,497
in a chain and a dictionary.

778
01:02:28,217 --> 01:02:30,571
We're going to have
to concat like that because

779
01:02:30,577 --> 01:02:32,457
expand gives us a list of word chains and dictionaries.

780
01:02:35,794 --> 01:02:37,474
SP: Can we rename chains there?

781
01:02:37,868 --> 01:02:41,668
OC: Sure, anything you're up to, a tad smaller

782
01:02:42,000 --> 01:02:43,954
or did you want to drop it entirely?

783
01:02:43,954 --> 01:02:45,950
Because we could just...

784
01:02:47,250 --> 01:02:50,594
No, we cant because we've
pattern matched on one here.

785
01:02:50,668 --> 01:02:51,620
SP: Maybe in pairs.

786
01:02:51,770 --> 01:02:53,817
OC: Ok, because of the dictionary.

787
01:03:11,777 --> 01:03:12,897
So that's OK...

788
01:03:12,970 --> 01:03:16,502
But what we've done
now is, we've thrown away

789
01:03:16,502 --> 01:03:17,740
these original chains.

790
01:03:17,740 --> 01:03:19,325
we need to retain those as well.

791
01:03:19,325 --> 01:03:19,771
SP: Right.

792
01:03:25,110 --> 01:03:27,394
OC: So we'll keep the pairs,

793
01:03:27,770 --> 01:03:30,428
and then add on
the expansions afterwards.

794
01:03:30,422 --> 01:03:30,845
SP: Yes.

795
01:03:30,862 --> 01:03:33,114
So for the smaller chains
that might have already finished,

796
01:03:33,125 --> 01:03:33,977
we'll keep those.

797
01:03:35,360 --> 01:03:37,811
SP: And then later you
would look at all the chains

798
01:03:37,817 --> 01:03:39,862
starting with the smallest first,

799
01:03:42,834 --> 01:03:45,040
and try to select only the ones that

800
01:03:45,040 --> 01:03:46,485
finish on the target word.

801
01:03:46,480 --> 01:03:46,994
OC: Right.

802
01:03:47,148 --> 01:03:50,605
OC: And because in
expand we're putting neighbors

803
01:03:50,611 --> 01:03:52,925
at the front of the list, were going to need to

804
01:03:52,925 --> 01:03:55,714
filter word chains that start with our target

805
01:03:56,017 --> 01:03:59,588
It's a bit weird but
obviously cons is a lot more efficient

806
01:03:59,582 --> 01:04:01,674
than append,  because we don't

807
01:04:01,674 --> 01:04:03,337
have to traverse the list at all.

808
01:04:03,331 --> 01:04:05,200
SP: We can always reverse the solution.

809
01:04:05,200 --> 01:04:06,474
OC: We could yes.

810
01:04:08,880 --> 01:04:12,228
I'll just check that
that's all compiling, it does.

811
01:04:12,380 --> 01:04:14,702
We should be able
to have a play with this now.

812
01:04:14,700 --> 01:04:15,760
In our GHCi

813
01:04:15,820 --> 01:04:19,531
So we've got go so I'll try...

814
01:04:20,217 --> 01:04:22,331
to bring the dictionary back into scope.

815
01:04:24,308 --> 01:04:26,874
Word chains plus words, so I'll try cat

816
01:04:30,491 --> 01:04:32,714
and it needs a
dictionary in there as well.

817
01:04:35,280 --> 01:04:37,080
And we'll start with just that one.

818
01:04:37,410 --> 01:04:42,028
And that's going to expand forever,
so lets go one level into it with go

819
01:04:42,140 --> 01:04:42,485
SP: Ok.

820
01:04:42,491 --> 01:04:43,908
OC: And take the head of that.

821
01:04:45,262 --> 01:04:46,971
There's a lot of possibilities...

822
01:04:47,697 --> 01:04:49,085
because of the dictionary.

823
01:04:52,508 --> 01:04:54,777
We'll just take the word chains out of that.

824
01:04:54,770 --> 01:04:59,050
SP: Just the first of head
OC: Oh yes

825
01:05:09,420 --> 01:05:11,691
OC: So maybe,... rather than the head
SP: Now it's map first
OC: So every time we take one more

826
01:05:11,710 --> 01:05:13,114
our chains get a bit longer.

827
01:05:13,114 --> 01:05:14,491
SP: Can you see the next one?

828
01:05:16,542 --> 01:05:18,605
Oh! that's because we've flattened it, yes.

829
01:05:20,171 --> 01:05:23,691
SP: That's not the level
that's just the chains as they change.

830
01:05:23,691 --> 01:05:24,320
OC: Yes

831
01:05:24,325 --> 01:05:27,250
SP: How about the first ten

832
01:05:30,680 --> 01:05:34,565
OC: So gradually they're going
to start getting bigger at some point.

833
01:05:35,542 --> 01:05:37,250
[inaudible]

834
01:05:45,062 --> 01:05:46,314
That's not recursing.

835
01:05:47,165 --> 01:05:49,080
Actually go is never calling itself,

836
01:05:49,080 --> 01:05:50,480
which is the problem here.

837
01:05:50,554 --> 01:05:53,554
So were only ever
looking at one level expansion.

838
01:05:55,120 --> 01:05:57,325
so if we take the original pairs and what we

839
01:05:57,331 --> 01:06:02,450
need to do is go again on the concatMap.

840
01:06:03,085 --> 01:06:03,617
SP: Right

841
01:06:04,680 --> 01:06:07,280
So we're going to keep
going to bigger and bigger chains.

842
01:06:07,470 --> 01:06:10,697
But we're always putting these
chains on the end of the list.

843
01:06:18,880 --> 01:06:21,954
So if we go back to taking 20 we should be

844
01:06:21,954 --> 01:06:23,085
back to where we were.

845
01:06:23,400 --> 01:06:26,782
And as I take more, you can see we are

846
01:06:26,780 --> 01:06:29,114
starting to get bigger and bigger chains now.

847
01:06:29,110 --> 01:06:31,680
SP: Right, and all of them ending on cat.

848
01:06:31,857 --> 01:06:32,268
OC: Yes.

849
01:06:35,022 --> 01:06:36,891
SP: That's because that was our start.

850
01:06:36,902 --> 01:06:39,222
OC: Yes, were going out from cat

851
01:06:39,480 --> 01:06:43,000
SP: Suffering from the reverse order of reading

852
01:06:44,850 --> 01:06:48,554
OC: So now were ready
to put this back into the wordPuzzle

853
01:06:48,554 --> 01:06:50,525
to solve the puzzle properly... again!

854
01:06:52,880 --> 01:06:56,360
So we need to call
go and we're going to be

855
01:06:56,365 --> 01:06:58,377
using the input-dictionary.

856
01:06:58,771 --> 01:07:02,417
But were going to have
to delete our starting word

857
01:07:02,410 --> 01:07:03,508
from the dictionary.

858
01:07:03,502 --> 01:07:05,897
OC: Because we don't
want to go back to the start.

859
01:07:05,902 --> 01:07:08,045
And we're going to
start with a word chain

860
01:07:08,045 --> 01:07:09,765
that begins at the word a

861
01:07:11,582 --> 01:07:13,771
And this is going to give us all the chains

862
01:07:13,771 --> 01:07:14,514
that start from a

863
01:07:14,514 --> 01:07:16,902
But we're interested
in chains that start at a

864
01:07:16,908 --> 01:07:17,857
and finish at b

865
01:07:18,491 --> 01:07:21,234
So we filter the result of chains

866
01:07:21,370 --> 01:07:24,748
by  taking... for each chain.

867
01:07:26,257 --> 01:07:29,020
Sorry, first we should just throw away

868
01:07:29,022 --> 01:07:30,988
the extra dictionaries.

869
01:07:31,302 --> 01:07:33,897
SP: Because the tuples will come back from go.

870
01:07:33,891 --> 01:07:36,177
OC: Yes, so go will give us a tuple of word chains

871
01:07:36,171 --> 01:07:37,365
and dictionaries,

872
01:07:37,417 --> 01:07:39,805
whereas we're
only interested in word chains.

873
01:07:39,805 --> 01:07:42,080
So I'm mapping first over those.

874
01:07:42,200 --> 01:07:44,022
Now we've got a list of word chains.

875
01:07:44,080 --> 01:07:49,205
I can filter the list for
ones whose first element

876
01:07:50,434 --> 01:07:52,845
is equal to our target. [inaudible]

877
01:07:54,022 --> 01:07:57,205
And I think that's all we need

878
01:07:57,205 --> 01:07:59,988
to solve the puzzle... so that all compiles

879
01:08:04,651 --> 01:08:06,388
Read the dictionary back in

880
01:08:06,388 --> 01:08:08,942
I can do a wordPuzzle using the dictionary

881
01:08:08,948 --> 01:08:10,891
and we'll go from dog to cat.

882
01:08:15,742 --> 01:08:17,502
And we are indeed getting result.

883
01:08:19,000 --> 01:08:21,080
The interesting thing we're seeing here

884
01:08:21,080 --> 01:08:23,685
is as it's gradually printing results,

885
01:08:23,970 --> 01:08:27,714
we are seeing Haskells' lazy
evaluation works to our advantage.

886
01:08:27,850 --> 01:08:30,502
So if I only wanted
to get the very first result,

887
01:08:30,508 --> 01:08:33,074
I could simply take
the head of all the solutions

888
01:08:33,502 --> 01:08:35,131
and the result is already done,

889
01:08:35,131 --> 01:08:37,645
it didn't bother
computing all the extra values.

890
01:08:37,760 --> 01:08:39,748
But if I needed the extra results, maybe if I

891
01:08:39,742 --> 01:08:43,460
wanted to find
the first ten shortest chains

892
01:08:43,462 --> 01:08:46,434
I could just take10
and that's going to give you

893
01:08:46,434 --> 01:08:49,091
10 word chains and then terminate,

894
01:08:49,674 --> 01:08:50,868
which is really nice.

895
01:08:52,730 --> 01:08:56,337
OC: I think that solves
the problem that we had

896
01:08:57,370 --> 01:08:59,274
in the original problem spec.

897
01:08:59,910 --> 01:09:02,097
SP: Shall we try it on longer input?

898
01:09:02,400 --> 01:09:05,771
How about the words Ruby and Code.

899
01:09:05,988 --> 01:09:08,497
OC: OK so I'll take the first of those.

900
01:09:24,240 --> 01:09:26,120
It's certainly a lot slower but we do

901
01:09:26,120 --> 01:09:27,634
get a word chain in the end.

902
01:09:32,050 --> 01:09:34,948
So it might be worth trying to improve the forms

903
01:09:34,940 --> 01:09:36,022
of this next.

904
01:09:36,050 --> 01:09:39,314
SP: Absolutely, and there are longer examples

905
01:09:39,310 --> 01:09:41,182
such as from house to shout,

906
01:09:42,110 --> 01:09:43,982
we could see if that completes

907
01:09:43,988 --> 01:09:45,680
in a reasonable amount of time.

908
01:09:47,005 --> 01:09:49,542
This one's quite tricky
because the search space

909
01:09:49,540 --> 01:09:52,622
for it is quite large in the
dictionary that I've given you.

910
01:09:53,805 --> 01:09:56,857
OC: This doesn't look like
it's terminating any time soon.

911
01:09:58,274 --> 01:10:01,194
SP: Maybe we can have a look and see

912
01:10:01,194 --> 01:10:04,370
if we can determine where the bottleneck is?

913
01:10:04,657 --> 01:10:06,560
OC: Yes, well I'm going to leave that one

914
01:10:06,560 --> 01:10:09,085
running in the
background anyway, see if we get a result

915
01:10:09,091 --> 01:10:11,310
while we start looking for some optimizations.

916
01:10:11,310 --> 01:10:15,080
To me, the biggest source of expense

917
01:10:15,250 --> 01:10:16,902
feels like this neighbours function.

918
01:10:16,902 --> 01:10:20,620
We're filtering twice and we map twice

919
01:10:20,634 --> 01:10:22,280
and we are doing this repeatedly

920
01:10:22,280 --> 01:10:23,800
every single time we expand.

921
01:10:23,800 --> 01:10:26,965
And the set of neighbors around a word

922
01:10:27,325 --> 01:10:28,468
doesn't really change.

923
01:10:28,720 --> 01:10:31,434
There may be potential
neighbors that we can't consider

924
01:10:31,434 --> 01:10:33,620
because we've already looked at them once.

925
01:10:33,620 --> 01:10:35,370
and we would go back on ourselves.

926
01:10:36,565 --> 01:10:39,657
But we can probably prune
the set of neighbors afterwards

927
01:10:39,651 --> 01:10:43,600
I'm thinking maybe we can have an optimization

928
01:10:43,611 --> 01:10:45,331
where we have a map of neighbors

929
01:10:48,800 --> 01:10:54,257
It's going to be a map
from Text to its set of neighbors.

930
01:10:55,285 --> 01:10:56,485
And we should be able to

931
01:10:56,485 --> 01:10:58,714
pre-compute this against the dictionary.

932
01:10:59,340 --> 01:11:01,840
We're going to need the Map data type

933
01:11:01,850 --> 01:11:06,000
which comes from Data.Map.

934
01:11:06,617 --> 01:11:08,942
again I'll be importing this from qualified.

935
01:11:15,520 --> 01:11:19,925
Now we look up the list of neighbors.

936
01:11:21,891 --> 01:11:24,131
We can still take the Dictionary as input

937
01:11:24,137 --> 01:11:26,531
but rather than just taking that, we can also

938
01:11:26,531 --> 01:11:28,440
take in a NeighbourMap.

939
01:11:29,462 --> 01:11:30,628
And the word to look up

940
01:11:30,620 --> 01:11:33,142
and it's going to give
us a set of neighbors again.

941
01:11:33,360 --> 01:11:34,897
And the reason I'm taking the dictionary

942
01:11:34,891 --> 01:11:36,251
is because we keep making that dictionary

943
01:11:36,251 --> 01:11:38,331
smaller and smaller. We want to make sure

944
01:11:38,337 --> 01:11:41,510
the neighbors we look up from this map

945
01:11:41,510 --> 01:11:43,657
are actually in the dictionary because

946
01:11:43,650 --> 01:11:45,177
we might have made the dictionary smaller

947
01:11:45,171 --> 01:11:46,971
and removed possible neighbors.

948
01:11:46,971 --> 01:11:48,708
so we're going to filter those out.

949
01:11:48,708 --> 01:11:52,205
OK, so I'll call that m and w.

950
01:11:52,731 --> 01:11:54,370
And this becomes straightforward,

951
01:11:54,370 --> 01:12:01,080
we simply do a map look-up which is the exclamation operator

952
01:12:01,110 --> 01:12:04,634
which will throw up an error
if the word isn't in the map

953
01:12:04,885 --> 01:12:07,954
but we'll have to gloss
over that for now I guess.

954
01:12:08,420 --> 01:12:09,600
SP: Avoiding the Maybes.

955
01:12:10,200 --> 01:12:12,965
OC: If I was doing this production code

956
01:12:12,960 --> 01:12:14,291
I would probably want
to keep the Maybes

957
01:12:14,291 --> 01:12:16,320
and the chance of it possibly failing,

958
01:12:16,320 --> 01:12:18,542
and reflect that in the types better.

959
01:12:18,540 --> 01:12:21,628
But for our purposes this should be sufficient.

960
01:12:23,091 --> 01:12:25,691
So, this is saying in the map M

961
01:12:25,697 --> 01:12:27,011
look up the word w.

962
01:12:28,725 --> 01:12:31,474
We need to take the intersection

963
01:12:31,474 --> 01:12:33,840
of the set of possible neighbors.

964
01:12:37,170 --> 01:12:40,171
We take the set intersection...

965
01:12:41,380 --> 01:12:43,817
SP: Is it bang or double-bang for the
lookup operator? I can't remember.

966
01:12:44,205 --> 01:12:47,165
OC: From map I believe
it's just a single exclamation mark,

967
01:12:47,160 --> 01:12:49,520
whereas for lists it's two exclamation marks.

968
01:12:55,850 --> 01:12:58,020
So we don't seem to have any compile errors

969
01:12:58,020 --> 01:12:59,850
around this neighbours function.

970
01:13:00,680 --> 01:13:02,250
That's quite straightforward.

971
01:13:02,440 --> 01:13:05,440
We also need a way to precomputeNeighbours.

972
01:13:06,988 --> 01:13:11,817
So that takes the
dictionary and turns it into a NeighbourMap,

973
01:13:12,770 --> 01:13:15,540
SP: So here your
starting from saying; from right down

974
01:13:15,540 --> 01:13:18,594
in the lowest level of this computation

975
01:13:18,594 --> 01:13:21,622
you would like to have
that extra information available

976
01:13:21,622 --> 01:13:24,857
in that NeighbourMap and you're
working your way back up

977
01:13:24,965 --> 01:13:27,340
to the calling levels

978
01:13:27,340 --> 01:13:29,340
to see how to pass that down into it.

979
01:13:29,342 --> 01:13:34,325
OC: Yes. We've got a neighbours function.

980
01:13:34,320 --> 01:13:36,622
I would like to be able to test that in GHCi

981
01:13:36,622 --> 01:13:38,862
but we don't have a way
to build a NeighbourMap yet.

982
01:13:38,860 --> 01:13:41,937
So I'm going to work on this
precomputeNeighbours function

983
01:13:41,937 --> 01:13:43,794
then I can have a test from GHCi

984
01:13:43,790 --> 01:13:45,022
so I can actually see if

985
01:13:45,020 --> 01:13:47,262
the NeighbourMap seems to
be working as we would expect.

986
01:13:47,260 --> 01:13:50,011
Then we can work
through the rest of the compile errors

987
01:13:50,011 --> 01:13:54,370
And thread in the proper code as we need to.

988
01:13:55,777 --> 01:13:57,902
So this looks like it
should be straightforward,

989
01:13:57,902 --> 01:14:02,194
we just take our
dictionary, which is a set of words,

990
01:14:02,668 --> 01:14:04,800
so if we go from set to list.

991
01:14:05,885 --> 01:14:10,354
and for every word
in here we can map over...

992
01:14:12,370 --> 01:14:15,005
Ah! We did need our
original neighbours function

993
01:14:15,000 --> 01:14:17,142
which I have thrown away now (laughter)

994
01:14:17,160 --> 01:14:18,914
because we want to use that.

995
01:14:19,740 --> 01:14:21,620
OC: So let's see if I can go back to that.

996
01:14:26,450 --> 01:14:27,942
So I'll call this one...

997
01:14:31,925 --> 01:14:32,908
neighboursLookup.

998
01:14:37,748 --> 01:14:41,320
And this is back to how it was.

999
01:14:53,380 --> 01:14:57,422
SP: We could also call this
neighbours and have the old

1000
01:14:57,420 --> 01:15:01,680
neighbours function
simply be a function returning

1001
01:15:01,685 --> 01:15:05,171
a list of the words
with the neighbors and distances.

1002
01:15:06,388 --> 01:15:08,337
OC: In the neighbours function or...?

1003
01:15:09,257 --> 01:15:12,685
SP: Yes, so you could - at this level here

1004
01:15:12,685 --> 01:15:15,742
where your returning W with distance,

1005
01:15:18,817 --> 01:15:22,177
in order to avoid having two similarly named functions.

1006
01:15:22,348 --> 01:15:23,994
Maybe we should continue...

1007
01:15:23,994 --> 01:15:25,740
OC: It's probably worth renaming this though

1008
01:15:25,740 --> 01:15:27,194
because we want compile error,

1009
01:15:27,194 --> 01:15:30,140
we're going to get compile
errors anyway because the types are different.

1010
01:15:34,165 --> 01:15:38,417
I'm going to move this
into precomputeNeighbours,

1011
01:15:38,411 --> 01:15:39,474
as a where binding

1012
01:15:39,485 --> 01:15:42,110
because we don't
have any reason to ever call this

1013
01:15:42,110 --> 01:15:43,988
other than inside precomputeNeighbours.

1014
01:15:48,451 --> 01:15:50,450
SP: And it does mean
you can rename the top level.

1015
01:15:50,590 --> 01:15:51,822
OC: Exactly.

1016
01:15:53,542 --> 01:15:56,457
The dictionary is going
to be available up here anyway,

1017
01:16:00,937 --> 01:16:05,731
We need to turn our
dictionary into a list of words

1018
01:16:06,462 --> 01:16:10,165
and map neighbors over that.

1019
01:16:12,668 --> 01:16:16,382
So I need to pair them up
with the original word as well.

1020
01:16:17,982 --> 01:16:21,371
There's a fairly nice function
in the Control.Arrow module

1021
01:16:22,710 --> 01:16:26,257
which lets us run two
functions on the same argument.

1022
01:16:27,400 --> 01:16:29,668
I can say that id and neighbors,

1023
01:16:29,770 --> 01:16:33,110
so that's the identity
function and the neighbors function

1024
01:16:33,110 --> 01:16:35,497
and it's going to tuple those up for me.

1025
01:16:35,771 --> 01:16:36,285
SP: OK.

1026
01:16:37,400 --> 01:16:38,970
OC: I think I'll just import that...

1027
01:16:42,748 --> 01:16:44,497
We've got a lot of compile errors.

1028
01:17:12,110 --> 01:17:17,377
We apparently need the word A as well.

1029
01:17:17,925 --> 01:17:28,200
I think that's meant to be...
Oh, I must have originally called it A.

1030
01:17:31,548 --> 01:17:33,880
OC: So now we have
precomputeNeighbours but that's

1031
01:17:33,880 --> 01:17:36,050
not returning the neighbors now.

1032
01:17:42,320 --> 01:17:45,177
We don't really need to keep dict...
Oh we do

1033
01:17:45,170 --> 01:17:47,342
because were using that in neighbors

1034
01:17:48,910 --> 01:17:52,110
Now this is going to be a list of tuples.

1035
01:17:52,382 --> 01:17:54,257
OC: We can turn that into a map.

1036
01:17:58,537 --> 01:18:01,485
So we've turned our
dictionary into a list of text

1037
01:18:01,788 --> 01:18:04,251
and for every text value we turn that into

1038
01:18:04,491 --> 01:18:06,154
the text word itself

1039
01:18:06,154 --> 01:18:08,965
and its set of neighbors.

1040
01:18:09,371 --> 01:18:11,651
SP: And each word will
be distinct so you don't need

1041
01:18:11,650 --> 01:18:14,634
to worry about combining entries.

1042
01:18:14,634 --> 01:18:15,485
OC: Right, yes

1043
01:18:17,988 --> 01:18:19,657
OC: Let's see what we get from that.

1044
01:18:23,502 --> 01:18:27,805
neighbors is going to
be neighboursLookup,

1045
01:18:29,497 --> 01:18:33,805
so that's... well, yes
let's keep it as neighboursLookup.

1046
01:18:39,080 --> 01:18:42,537
OC: I'm just checking that's
the only compile error we've got,

1047
01:18:42,868 --> 01:18:44,188
and it looks like it is,

1048
01:18:44,188 --> 01:18:46,622
so we've just got two arrows up here.

1049
01:18:46,820 --> 01:18:49,691
That means expand rather
than just take the dictionary.

1050
01:18:49,697 --> 01:18:52,730
This also need to take a NeighbourMap.

1051
01:19:02,220 --> 01:19:05,240
The order here is dictionary, NeighbourMap.

1052
01:19:10,250 --> 01:19:11,650
I just had a thought there,

1053
01:19:11,650 --> 01:19:15,000
because we're always
passing these two things together maybe

1054
01:19:15,000 --> 01:19:16,520
I should be combining these.

1055
01:19:16,702 --> 01:19:18,657
SP: I was having the same thought.

1056
01:19:19,068 --> 01:19:20,600
OC: So I think maybe our NeighbourMap

1057
01:19:20,605 --> 01:19:24,325
could be a data type
containing the full pre-computed map,

1058
01:19:24,510 --> 01:19:27,240
but also a set of exclusions.

1059
01:19:27,245 --> 01:19:29,510
And every time we need
to drop something out of the

1060
01:19:29,510 --> 01:19:33,405
NeighbourMap we can
do that quite efficiently.

1061
01:19:33,645 --> 01:19:36,182
OC: Or we may not even need to carry
the dictionary around but we'll see.

1062
01:19:36,182 --> 01:19:37,651
I'll come back to that later.

1063
01:19:38,062 --> 01:19:40,634
but it certainly does feel suspect so far.

1064
01:19:42,805 --> 01:19:46,508
So I think I better put
this the right way round

1065
01:19:46,531 --> 01:19:48,565
it's dictionary and NeighbourMap

1066
01:19:50,188 --> 01:19:52,588
This is the dictionary and NeighbourMap

1067
01:19:59,740 --> 01:20:02,340
and now expand
needs that NeighbourMap as well.

1068
01:20:05,131 --> 01:20:08,034
But interestingly, this
doesn't have to be added to go.

1069
01:20:08,034 --> 01:20:10,370
Because the NeighbourMap doesn't ever change

1070
01:20:11,250 --> 01:20:14,640
from what we've got so
far. So that's just a constant.

1071
01:20:20,925 --> 01:20:22,600
SP: You could underscore it in the first one.

1072
01:20:22,748 --> 01:20:23,988
OC: Indeed, yes.

1073
01:20:28,280 --> 01:20:32,297
And, we need to call that recursively.

1074
01:20:36,262 --> 01:20:38,554
and we need to pass it in here as well.

1075
01:20:39,028 --> 01:20:43,200
So here, I think I'll use another let binding.

1076
01:20:58,970 --> 01:21:03,137
So now our word puzzle should
be using this precomputed NeighbourMap.

1077
01:21:03,154 --> 01:21:03,937

SP: Right.

1078
01:21:04,091 --> 01:21:07,222
And were using our more
efficient neighbors look-up function.

1079
01:21:07,230 --> 01:21:08,931
So hopefully...

1080
01:21:08,960 --> 01:21:10,594
we are going to see some results.

1081
01:21:10,594 --> 01:21:12,965
Impressively its still
trying to find solutions between

1082
01:21:12,960 --> 01:21:14,925
house and shout, on the old code.

1083
01:21:16,548 --> 01:21:19,880
So let's see what we get out of this.

1084
01:21:20,850 --> 01:21:24,942
We didn't really look
at seeing precomputeNeighbours work, so

1085
01:21:24,942 --> 01:21:30,577
let's have a quick look at that.

1086
01:21:38,725 --> 01:21:40,845
OK, so that certainly type checks.

1087
01:21:44,708 --> 01:21:46,800
Let's bind that to... something like that.

1088
01:21:47,420 --> 01:21:48,862
We can do nMap...

1089
01:21:54,440 --> 01:21:56,908
SP: Jellow and hells. (laughter).

1090
01:21:57,234 --> 01:21:59,420
OC: So precomputeNeighbours seems to be working.

1091
01:21:59,428 --> 01:22:01,510
We seem to be getting some actual neighbors,

1092
01:22:01,691 --> 01:22:05,860
so let's do ruby and code again.

1093
01:22:08,942 --> 01:22:11,628
It doesn't seem to
be a huge amount more efficient

1094
01:22:14,428 --> 01:22:17,142
But maybe we'll actually
get a result from this now

1095
01:22:24,400 --> 01:22:26,114
We've still got a little bit to go.

1096
01:22:30,000 --> 01:22:33,228
SP: Does it take long
to pre-compute the entire map?

1097
01:22:34,228 --> 01:22:36,480
can you force that computation and see?

1098
01:22:36,485 --> 01:22:39,382
OC: We can try forcing
that and see what happens.

1099
01:22:42,034 --> 01:22:44,840
SP: And of course here your
going to be pre-computing the neighbors

1100
01:22:45,600 --> 01:22:47,268
across the full dictionary,

1101
01:22:48,680 --> 01:22:51,834
not necessarily the dictionary
pruned down to only the the words

1102
01:22:51,902 --> 01:22:53,200
of the length we're interested in.

1103
01:22:53,571 --> 01:22:57,234
OC: Yes that's probably worth doing already.

1104
01:22:57,700 --> 01:23:00,897
Rather than precomputing
the dictionary of everything.

1105
01:23:01,531 --> 01:23:04,165
Though we're using a lazy map
here which means that

1106
01:23:05,857 --> 01:23:09,148
we'll get a map back that
contains all of the words as keys,

1107
01:23:09,340 --> 01:23:12,862
but the values underneath
that map won't be fully evaluated.

1108
01:23:13,205 --> 01:23:15,594
So it's only when we
look up those keys in the map

1109
01:23:15,600 --> 01:23:17,588
that we will do that work.

1110
01:23:17,620 --> 01:23:21,760
So hopefully having the full dictionary
in there doesn't make any difference.

1111
01:23:21,771 --> 01:23:26,262
But I think for clarity
that's slightly nicer if we

1112
01:23:26,262 --> 01:23:35,445
just say filter, length, equal to length of A.

1113
01:23:36,980 --> 01:23:40,194
SP: Of course, this way your run length across...

1114
01:23:40,257 --> 01:23:42,228
is it hundreds of thousands of words?

1115
01:23:42,570 --> 01:23:43,222
OC: Yes.

1116
01:23:44,777 --> 01:23:46,171
SP: So its a tradeoff.

1117
01:24:06,540 --> 01:24:08,194
OC. So we take the length...

1118
01:24:12,234 --> 01:24:15,331
I think that's
because we have text values here.

1119
01:24:16,220 --> 01:24:19,285
We've already seen this
type of function before anyway.

1120
01:24:22,525 --> 01:24:24,708
We still have it down here.

1121
01:24:24,708 --> 01:24:26,700
Maybe we could do something with that.

1122
01:24:29,020 --> 01:24:31,850
Maybe neighbors now
doesn't have to worry about that,

1123
01:24:31,850 --> 01:24:34,108
we've already done that once.

1124
01:24:34,102 --> 01:24:36,280
I think I'll just leave that duplication for now,
and see if that

1125
01:24:36,280 --> 01:24:37,565
has made a difference.

1126
01:24:44,770 --> 01:24:46,742
It seems a bit snappier doesn't it?
SP: Yes

1127
01:24:49,600 --> 01:24:51,462
SP: So the acid test. (laughter).

1128
01:24:55,970 --> 01:24:59,834
There's still no results
between house and shout.

1129
01:25:03,800 --> 01:25:05,942
SP: So that's great, we've reached a point now

1130
01:25:05,940 --> 01:25:09,251
were we're able to
find chains quite efficiently,

1131
01:25:09,320 --> 01:25:15,066
Not just from cat to dog
but also from ruby to code.

1132
01:25:15,370 --> 01:25:20,146
SP: Where do you think
you would go next with this?

1133
01:25:20,413 --> 01:25:25,680
OC: One thing that's always been sticking with
me quite a bit is

1134
01:25:25,840 --> 01:25:28,640
in go we are using ++,

1135
01:25:28,680 --> 01:25:32,680
which means that
because were always having

1136
01:25:32,706 --> 01:25:33,920
to put things on the end of the list.

1137
01:25:33,933 --> 01:25:35,733
We're always have to
walk through the start of the list

1138
01:25:35,733 --> 01:25:38,733
to get to the end. And we're
having to do that repeatedly.

1139
01:25:38,906 --> 01:25:41,573
There's a couple of
well known ways we can go about

1140
01:25:41,586 --> 01:25:43,310
optimising that at Haskell.

1141
01:25:43,310 --> 01:25:45,786
Difference lists are one possibility.

1142
01:25:45,940 --> 01:25:50,346
Which means that
appending has much less of a cost

1143
01:25:50,346 --> 01:25:53,720
provided we don't ever try
to inspect the front early on

1144
01:25:53,733 --> 01:25:55,186
but we don't need to do that, we only need

1145
01:25:55,186 --> 01:25:57,986
to start inspecting once
we've built up this big computation

1146
01:25:58,013 --> 01:26:00,160
of all possible solutions, and then we can

1147
01:26:00,170 --> 01:26:02,133
start pulling things off the front.

1148
01:26:02,133 --> 01:26:04,280
So that could be
an interesting optimization to see.

1149
01:26:04,280 --> 01:26:08,693
That maybe we'll be able to
allocate a bit less in the go function.

1150
01:26:08,693 --> 01:26:12,133
Beyond that I'd probably want
to look at doing some code profiling.

1151
01:26:12,130 --> 01:26:14,386
Try and work out if maybe something is being

1152
01:26:14,386 --> 01:26:15,920
hit a little too frequently.

1153
01:26:16,080 --> 01:26:19,453
And see if we can do something there.

1154
01:26:20,020 --> 01:26:22,933
Obvious strategies in
any graph search problem

1155
01:26:22,960 --> 01:26:24,866
would be memoisation.

1156
01:26:26,057 --> 01:26:28,085
Which works really nicely at Haskell.

1157
01:26:28,085 --> 01:26:29,885
That wouldn't be too hard to add in.

1158
01:26:29,885 --> 01:26:33,457
It's just a case of working out
exactly what needs to be optimised.

1159
01:26:33,880 --> 01:26:35,440
And a couple of other things.

1160
01:26:35,453 --> 01:26:37,466
Just in terms of the feel of this code,

1161
01:26:37,466 --> 01:26:38,740
that I'd want to clean up.

1162
01:26:38,740 --> 01:26:40,971
As I pointed out earlier, the NeighbourMap

1163
01:26:40,970 --> 01:26:44,106
always has to be paired
with the dictionary, so forcing

1164
01:26:44,100 --> 01:26:46,413
the user to pass the dictionary
and the NeighbourMap around,

1165
01:26:46,413 --> 01:26:47,986
felt a bit cumbersome.

1166
01:26:47,986 --> 01:26:51,880
It would be nice if we could work
out some sort of abstraction there.

1167
01:26:51,880 --> 01:26:54,293
A NeighbourMap data type that has an operation

1168
01:26:54,293 --> 01:26:56,680
like look-up and remove.

1169
01:26:56,693 --> 01:27:00,800
SP: Or the dictionary itself is more complex

1170
01:27:00,813 --> 01:27:05,666
and opaque structure which
can provide you with neighbors.

1171
01:27:05,666 --> 01:27:07,106
OC: Absolutely,

1172
01:27:07,106 --> 01:27:09,026
SP:  Because that's the only operation

1173
01:27:09,040 --> 01:27:09,840
we have on the [inaudible]

1174
01:27:09,853 --> 01:27:12,370
OC: Yes, it needs
efficient look up and efficient

1175
01:27:12,371 --> 01:27:14,400
removal of the things you've already seen.

1176
01:27:14,450 --> 01:27:17,840
Beyond that, we don't
have any other requirements.

1177
01:27:17,973 --> 01:27:22,560
I think were moved it to a Set...

1178
01:27:23,480 --> 01:27:24,360
we did yes.

1179
01:27:24,373 --> 01:27:27,893
so Set does have
efficient look up and deletion.

1180
01:27:27,893 --> 01:27:32,520
But if we were able to combine that with

1181
01:27:32,546 --> 01:27:34,026
the pre-computed NeighbourMap

1182
01:27:34,026 --> 01:27:36,466
we would probably get a much nicer API.

1183
01:27:36,466 --> 01:27:38,013
SP: And having worked through this,

1184
01:27:38,013 --> 01:27:42,600
the overall approach of using
lists to represent the word chains

1185
01:27:42,613 --> 01:27:46,080
and  expanding those lists.

1186
01:27:48,493 --> 01:27:51,040
Is that the approach you would use again?

1187
01:27:51,173 --> 01:27:53,440
OC: I think, now that we've got more familiar with

1188
01:27:53,440 --> 01:27:55,920
the problem, and it's clear
that it has this tree structure

1189
01:27:55,930 --> 01:27:57,786
and you're doing a breadth-first search.

1190
01:27:57,800 --> 01:27:59,426
It would have been
nice to make that explicit

1191
01:27:59,426 --> 01:28:00,720
in the types themselves.

1192
01:28:00,720 --> 01:28:04,560
So use some sort of tree structure
to represent the branching out,

1193
01:28:04,640 --> 01:28:07,360
because I think a couple of
times we've confused ourselves

1194
01:28:07,386 --> 01:28:10,400
with lists of lists of text,
when we actually wanted

1195
01:28:10,400 --> 01:28:12,142
a list of texts, and it was unclear

1196
01:28:12,142 --> 01:28:13,657
how we actually got from

1197
01:28:13,650 --> 01:28:15,813
that nested list to a single list.

1198
01:28:15,826 --> 01:28:18,040
Was concat the
right operation to be using

1199
01:28:18,050 --> 01:28:20,853
or have we made a
mistake somewhere else.

1200
01:28:20,853 --> 01:28:22,973
So we didn't really lean on the types there,

1201
01:28:22,980 --> 01:28:25,013
it would have  been nice if we could have taken more

1202
01:28:25,013 --> 01:28:27,110
advantage from the type system.

1203
01:28:27,110 --> 01:28:30,666
I think if I were to do
it again I would choose

1204
01:28:30,666 --> 01:28:33,306
a slightly better data structure for word chains

1205
01:28:33,306 --> 01:28:34,080
in the first place.

1206
01:28:34,080 --> 01:28:37,773
SP: So there's a built in tree type, isn't there, there?

1207
01:28:38,000 --> 01:28:39,986
OC: Yes, its not one
that I'm very familiar with.

1208
01:28:39,986 --> 01:28:42,906
It's in the same library
as Data.Set and Data.Map.

1209
01:28:42,910 --> 01:28:45,613
It doesn't have a hugh API,

1210
01:28:45,610 --> 01:28:48,893
but it does avoid me reinventing the wheel in terms of

1211
01:28:49,110 --> 01:28:50,857
just coming up with the data type.

1212
01:28:51,110 --> 01:28:54,050
And the other thing
that I might be interested in doing

1213
01:28:54,050 --> 01:28:58,266
there's a lot of hidden recursion here.

1214
01:28:58,320 --> 01:29:00,080
It's quite hard to follow this code,

1215
01:29:00,093 --> 01:29:01,973
it calls itself in different ways.

1216
01:29:03,066 --> 01:29:07,266
It's more of an advanced way of writing Haskell

1217
01:29:07,266 --> 01:29:09,320
but you can
split that recursion out

1218
01:29:09,340 --> 01:29:10,293
and make it very explicit.

1219
01:29:10,293 --> 01:29:13,266
So you pass around functions
that operate on just one thing,

1220
01:29:13,266 --> 01:29:15,906
and then you have a recursion scheme you can apply to that.

1221
01:29:16,080 --> 01:29:18,960
And that might come out
with some slightly cleaner code,

1222
01:29:18,986 --> 01:29:22,706
but it's going to take a
lot more work to get that.

1223
01:29:23,200 --> 01:29:25,226
But I think making that recursion clear

1224
01:29:25,226 --> 01:29:26,960
could clear up a lot of this code.

1225
01:29:27,480 --> 01:29:31,293
SP: Right, that seems like a successful session.

1226
01:29:31,293 --> 01:29:32,973
OC: I think so - got there in the end.

1227
01:29:32,973 --> 01:29:36,226
SP: Yes, thanks.

1228
01:29:36,226 --> 01:29:36,880
OC: OK.

