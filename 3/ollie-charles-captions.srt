1
00:00:02,000 --> 00:00:03,920
NARRATOR: Welcome to Peer to Peer

2
00:00:03,930 --> 00:00:07,245
where you can hone your
skills by watching live coding videos.

3
00:00:08,800 --> 00:00:11,097
Our guest today is Ollie Charles

4
00:00:11,140 --> 00:00:13,245
who's a Haskell developer at Fynder

5
00:00:13,250 --> 00:00:15,897
and the author of 24 days of Hackage.

6
00:00:16,800 --> 00:00:18,571
Our host is Steve Purcell

7
00:00:19,060 --> 00:00:21,314
and the challenge that we set for Ollie is called:

8
00:00:21,474 --> 00:00:23,640
Solving Word Chain Puzzles.

9
00:00:24,251 --> 00:00:26,354
Steve Purcell: So Ollie would you like to start

10
00:00:26,354 --> 00:00:28,190
by reading through the question description?

11
00:00:28,190 --> 00:00:31,897
Ollie Charles: So it's write a
program that solves word chain puzzles.

12
00:00:31,890 --> 00:00:35,314
A word chain puzzle starts with
one word and ends with another.

13
00:00:35,405 --> 00:00:38,754
Successive entries in the
chain must all be real words.

14
00:00:38,754 --> 00:00:42,160
And each can differ from the
previous word by just one letter.

15
00:00:42,160 --> 00:00:45,748
For example, you can get from
"dog to "cat" using the following chain:

16
00:00:45,740 --> 00:00:48,594
Dog to cog to cot to cat.

17
00:00:49,130 --> 00:00:52,628
Your program should accept
start and end words and a dictionary,

18
00:00:52,640 --> 00:00:54,491
and find word chains between them.

19
00:00:55,611 --> 00:00:58,310
OC: So that seems pretty straightforward to me.

20
00:00:58,310 --> 00:01:00,450
I guess that we've got a restriction there,

21
00:01:00,450 --> 00:01:03,314
that the start and the end words
will have to be the same length?

22
00:01:03,325 --> 00:01:05,051
SP: Yes they will.

23
00:01:08,285 --> 00:01:10,937
OC: You've given me this dictionary as well.

24
00:01:14,670 --> 00:01:17,382
And I see that some of these are different case.

25
00:01:17,874 --> 00:01:20,170
Is that going to have any impact on the problem?

26
00:01:20,180 --> 00:01:23,074
Do I need to preserve case
or or lower case everything?

27
00:01:23,085 --> 00:01:30,290
SP: I'd like the resulting chain to include
the original case of the word from this file.

28
00:01:30,560 --> 00:01:37,577
And if you ask for a chain between two particular
words they should be present with the same case

29
00:01:37,588 --> 00:01:40,582
in the word list file, in order to be considered valid.

30
00:01:40,620 --> 00:01:44,800
OC: OK.  And is changing case
going to be considered an operation?

31
00:01:45,090 --> 00:01:52,685
So if I have something that starts with a lower
case A and an upper case A is that a difference of one?

32
00:01:53,000 --> 00:02:02,182
SP: I think so, I think a word will
either be capitalized or not in the dictionary.

33
00:02:02,180 --> 00:02:08,011
I don't think you would find the same
word in there twice, once capitalized and once not.

34
00:02:08,080 --> 00:02:12,640
OC: OK, Yes. Well, I suppose we'll see what happens.

35
00:02:15,028 --> 00:02:19,462
The first thing to do is get my environment set up.

36
00:02:19,810 --> 00:02:24,262
I want to have a Cabal file so
I'll treat this like a proper project.

37
00:02:24,260 --> 00:02:28,502
I'm going to be using nix  shell to
work with that cabal file to do builds

38
00:02:28,540 --> 00:02:31,177
and bring down dependencies and stuff like that.

39
00:02:33,460 --> 00:02:38,434
OC: So I've got a terminal here,
I should be able to run cabal init

40
00:02:38,520 --> 00:02:41,360
So let's call this Word Puzzle.

41
00:02:42,697 --> 00:02:48,617
It doesn't really matter about the
version and I'll just use another license.

42
00:02:52,560 --> 00:02:56,594
I'll leave that blank... and all this blank.

43
00:02:57,908 --> 00:03:01,371
SP: Yes it will probably become executable

44
00:03:02,045 --> 00:03:07,200
OC: And we'll go with WordPuzzle.hs as the main part.

45
00:03:11,890 --> 00:03:21,840
So now I believe I have my cabal file
so I should be able to do some basic builds now.

46
00:03:30,880 --> 00:03:36,491
OC: I'm using the Emacs compile command
there to use the cabal file and do a build.

47
00:03:36,811 --> 00:03:38,902
I'm just going to see if that compiles.

48
00:03:38,902 --> 00:03:42,422
Hopefully it's configuring.

49
00:03:42,434 --> 00:03:45,028
And it looks like we've got something.

50
00:03:45,645 --> 00:03:49,257
I'm going to have to rename this to main.

51
00:03:54,090 --> 00:03:57,634
OK, so that seems to be happy
compiling and stuff like that

52
00:03:57,810 --> 00:04:05,291
and we can also switch over
to the terminal and run that... yes.

53
00:04:08,590 --> 00:04:13,062
OC: I think the first thing I'm going to
do is work with loading the dictionary words,

54
00:04:13,394 --> 00:04:15,760
just so we've got some data to play with.

55
00:04:15,970 --> 00:04:19,600
I'm going to start by making
a type alias for the dictionary

56
00:04:19,622 --> 00:04:25,394
and for our purposes the dictionary
is just going to be a list of text values.

57
00:04:25,417 --> 00:04:29,988
And the text there is the type from Data.Text.

58
00:04:32,570 --> 00:04:35,314
And I think I'll make a new function, readDictionary

59
00:04:35,310 --> 00:04:40,034
which will take the file path
and give me back a dictionary.

60
00:04:47,417 --> 00:04:49,108
I'll take that out for now.

61
00:04:53,900 --> 00:04:59,577
We're going to need the Data Text library
as well, so I'll add that to the Cabal file.

62
00:05:03,200 --> 00:05:06,914
And because I'm using nix I'm
going to need to add it to my nix file as well.

63
00:05:06,925 --> 00:05:11,428
so that's going to just pull down my dependencies.

64
00:05:19,234 --> 00:05:25,150
OK. We do need a main, so let's stub that out for now.

65
00:05:27,634 --> 00:05:30,445
SP: So the underscore
you're leaving there is the hole?

66
00:05:30,440 --> 00:05:36,205
OC: Yes, so if we expand the compilation buffern
it says that there are two holes in this program.

67
00:05:36,270 --> 00:05:38,708
We need to provide some type of computation

68
00:05:38,700 --> 00:05:41,680
that's going to be an io
action that will return a dictionary.

69
00:05:41,691 --> 00:05:43,910
And we also have another hole for main as well.

70
00:05:43,931 --> 00:05:46,280
SP: And this is a new feature in the latest GHC?

71
00:05:46,280 --> 00:05:48,571
OC: yes. I think this came in GHC 7.8.

72
00:05:50,140 --> 00:05:53,520
So  I'll leave the hole in main for now,

73
00:05:53,531 --> 00:05:56,660
because it's probably going to
be one of the last ones we fill in.

74
00:05:56,800 --> 00:05:59,645
I'll work on reading this dictionary.

75
00:06:01,490 --> 00:06:06,777
I think I'm going to switch over to Hackage now, and
look at the documentation from the Text Library.

76
00:06:08,610 --> 00:06:13,074
This module has all sorts of IO routines
that are going  to give us text values back,

77
00:06:13,110 --> 00:06:15,540
and the one that I'm interested in is readfile,

78
00:06:15,540 --> 00:06:18,914
which takes a file path that
gives us back a single text strength,

79
00:06:18,970 --> 00:06:21,820
and then we can split
that up into a dictionary later.

80
00:06:22,251 --> 00:06:24,834
The first thing I'm going to do...

81
00:06:33,710 --> 00:06:37,794
The text library tends to work
best if you use qualified imports.

82
00:06:37,851 --> 00:06:41,680
So I'm going to import Data.Text as T.

83
00:06:42,280 --> 00:06:46,788
SP: So you're just avoiding the confusion
of clobbering the built-ins in the prelude.

84
00:06:46,780 --> 00:06:50,091
OC: Yes, the prelude has things
like length, filter and stuff like that,

85
00:06:50,091 --> 00:06:52,530
but text also has length and filter.

86
00:06:52,537 --> 00:06:56,205
So to avoid ambiguous names
I'm going to import that entirely qualified.

87
00:06:57,610 --> 00:07:01,611
SP: So it's about hiding the
prelude symbols, explicitly?

88
00:07:01,620 --> 00:07:05,577
OC: Yes, I'm probably not going to be using the prelude stuff very much,

89
00:07:05,600 --> 00:07:07,540
but that will save me some hassle.

90
00:07:09,120 --> 00:07:13,211
I'm going to have a type hole in
there so I've got some well formed syntax.

91
00:07:14,010 --> 00:07:18,434
And now I have a hole that needs to be a dictionary.

92
00:07:18,434 --> 00:07:22,114
And I have available dictionary
contents which is a piece of text.

93
00:07:22,377 --> 00:07:26,480
So I need to split this
single text string into a list of lines.

94
00:07:26,490 --> 00:07:35,337
I believe we have a function to do that in
the Text Library as well, which is lines.

95
00:07:35,782 --> 00:07:38,685
Which is going to break
the text up into a list of texts.

96
00:07:38,685 --> 00:07:41,600
SP: It's the exact analogue
of the lines in the prelude.

97
00:07:41,610 --> 00:07:46,148
OC: Exactly. The Text type itself is very
similar to the String type in the prelude.

98
00:07:46,228 --> 00:07:48,542
Except the String type is quite inefficient.

99
00:07:48,542 --> 00:07:50,370
It's just a linked list of characters,

100
00:07:50,370 --> 00:07:53,820
whereas the Text type is more
efficient in terms of its representation.

101
00:07:53,820 --> 00:07:57,200
SP: So you make a point of defaulting to
the Text type?

102
00:07:57,211 --> 00:08:00,200
OC: Yes Whenever I'm working with
something that is human-readable text,

103
00:08:00,200 --> 00:08:04,200
Text is usually the type that I want to
represent that.

104
00:08:04,200 --> 00:08:07,885
Now I can just take the
lines of dictionary contents.

105
00:08:14,034 --> 00:08:17,737
Now I should have a way
to read the dictionary.

106
00:08:18,220 --> 00:08:24,205
I'm going to switch back to my
terminal and load that up into GCHi

107
00:08:24,205 --> 00:08:26,200
and then we can have a play with that.

108
00:08:28,537 --> 00:08:34,902
I need to refresh my shell to
bring down that text dependency.

109
00:08:34,900 --> 00:08:37,931
[Ollie types]

110
00:08:38,000 --> 00:08:42,034
We've still got these holes here
which prevents me from using GHCi.

111
00:08:42,040 --> 00:08:47,782
But, I can use another feature of a later
version of GHC called defer-type errors.

112
00:08:47,980 --> 00:08:53,245
Which is going to let me load
code which doesn't strictly type check.

113
00:08:53,290 --> 00:08:57,794
But as long as I don't run something that
doesn't type check, I can still evaluate the program.

114
00:08:57,820 --> 00:09:01,314
I can work around the fact that
I've got an incomplete bit of code

115
00:09:01,310 --> 00:09:02,857
and I can run the bits I'm working on.

116
00:09:02,860 --> 00:09:08,297
SP: So does it effectively replace that code
with undefined and then compile it all anyway?

117
00:09:08,308 --> 00:09:13,890
OC: We can find out. It's the main
function that we haven't defined, so if I call main.

118
00:09:14,274 --> 00:09:17,340
Well actually it doesn't terminate at all (laughter).

119
00:09:17,720 --> 00:09:23,200
But we do have readDictionary.

120
00:09:24,500 --> 00:09:35,622
So why don't we try: readDictionary and "wordlist.txt".

121
00:09:35,748 --> 00:09:41,051
I'm going to bind that into - no I'm not

122
00:09:41,050 --> 00:09:48,102
When emacs cooperates, I'm going
to bind that into a variable called dict.

123
00:09:48,228 --> 00:09:50,285
SP: It's not going to print it straight off is it?

124
00:09:50,350 --> 00:09:53,828
OC: No, because of the size of the
dictionary, I want to put that in a variable

125
00:09:53,828 --> 00:09:57,314
so I can try and read out a few things from it.

126
00:09:57,314 --> 00:10:00,102
So we'll take the length of the dictionary.

127
00:10:08,200 --> 00:10:10,137
It's a pretty large dictionary.

128
00:10:10,420 --> 00:10:14,994
So we have to be quite efficient in
the way we search through this.

129
00:10:15,120 --> 00:10:18,560
But we do seem to have got some stuff.

130
00:10:18,570 --> 00:10:23,725
I guess we've got some windows line
endings there. Which is going to be annoying.

131
00:10:23,725 --> 00:10:24,971
I'll probably want to trim that stuff out.

132
00:10:24,980 --> 00:10:30,057
SP: Feel free to convert the file, If you want
to change the line endings that's fine with me.

133
00:10:32,540 --> 00:10:41,097
OC: Maybe if we just filter those carriage
returns out that might be easy enough.

134
00:10:51,250 --> 00:10:53,920
Let's see if that's any better.

135
00:10:53,980 --> 00:10:55,268
So I'm happy with that.

136
00:10:55,260 --> 00:10:59,920
We're just filtering out carriage
returns on the whole dictionary string.

137
00:11:03,660 --> 00:11:06,548
So it looks like the dictionary has loaded up fine.

138
00:11:06,720 --> 00:11:10,754
So now we're ready to start solving the problem.

139
00:11:12,434 --> 00:11:16,091
There's no real reason to
restrict ourselves to the IO monad here.

140
00:11:16,102 --> 00:11:19,508
This feels like it should be
solvable just with pure functions.

141
00:11:19,520 --> 00:11:19,960
SP: Yes.

142
00:11:19,970 --> 00:11:27,051
So I'm going to introduce a top level
function called... we'll go with word puzzle,

143
00:11:27,090 --> 00:11:33,897
which is going to take 2 text strings,
which are going to be our start and end strings.

144
00:11:37,340 --> 00:11:41,314
And the dictionary I think I'll
bring that in as the first argument.

145
00:11:44,080 --> 00:11:46,880
So a possible solution is going to be a list of words,

146
00:11:47,410 --> 00:11:50,902
But I imagine there are multiple
possible solutions for some of these problems.

147
00:11:50,900 --> 00:11:53,760
So I'm going to return a list of lists of words.

148
00:11:53,771 --> 00:11:58,594
And because that's getting a bit confusing
we'll introduce a type in there called solution.

149
00:11:58,690 --> 00:12:00,491
SP: Perhaps a word chain?

150
00:12:00,502 --> 00:12:03,702
OC: Yes, good we'll go with word chain.

151
00:12:04,960 --> 00:12:07,257
Which is going to be a list of text.

152
00:12:09,480 --> 00:12:14,194
SP: So you'll get back a list of possible
chains from the first word to the second word.

153
00:12:14,250 --> 00:12:18,274
OC: And if it's not possible to solve the
problem then we can just return the empty list.

154
00:12:18,274 --> 00:12:21,140
Which says there are no possible word chains at all.

155
00:12:29,028 --> 00:12:32,857
I'm going to try to solve this by pattern matching
basically and try to break the problem down slowly.

156
00:12:32,857 --> 00:12:34,910
And hopefully we'll get to the solution that way.

157
00:12:34,914 --> 00:12:36,942
And there's one really obvious pattern...

158
00:12:36,940 --> 00:12:40,080
you gave me the restriction that
the words have to be the same length.

159
00:12:40,090 --> 00:12:43,131
So if the words aren't the same length then
there's certainly no word chain between them.

160
00:12:43,130 --> 00:12:49,782
I'll get that case out of the way.
I'm going to use a pattern guard for that.

161
00:12:49,794 --> 00:12:57,180
If the length of a is not the lengt
of b then I'll just return nothing.

162
00:12:59,540 --> 00:13:04,628
Otherwise, I'll leave that to be solved.

163
00:13:07,480 --> 00:13:08,910
OK so what have we got there?

164
00:13:11,200 --> 00:13:12,740
It seems to be happy with that,

165
00:13:12,740 --> 00:13:16,434
We've got a hole on line 19 but that's
actually the problem we've got to solve.

166
00:13:16,434 --> 00:13:25,428
So if I try now and solve the word puzzle with
our dictionary, between Hello and Haskell.

167
00:13:26,205 --> 00:13:29,668
Whoops the dictionary
escaped, I'll just bring that back in.

168
00:13:31,710 --> 00:13:36,620
I need to use an extension here
for GHC called overloaded strings.

169
00:13:36,630 --> 00:13:39,851
Normally when we quote a
string, it has the type string,

170
00:13:39,860 --> 00:13:42,034
but obviously we are working with text values.

171
00:13:42,034 --> 00:13:47,920
So the overloaded string extension
is going to let us use literal strings,

172
00:13:47,942 --> 00:13:49,310
but they will have a type text.

173
00:13:50,160 --> 00:13:54,674
And as we would expect- Hello and Haskell don't
have the same length so there's no solution at all.

174
00:13:54,690 --> 00:13:59,497
We can move on now to
actually try and find some solutions.

175
00:13:59,740 --> 00:14:05,360
SP: Might I suggest another case where
we might be able to rule out possible solutions?

176
00:14:05,370 --> 00:14:06,445
OC: Sure.

177
00:14:06,570 --> 00:14:09,851
SP: So if either of the
words are not in the dictionary.

178
00:14:09,885 --> 00:14:12,994
I don't know if you want to handle that now?

179
00:14:13,131 --> 00:14:14,960
OC: No that seems reasonable.

180
00:14:19,380 --> 00:14:23,394
I've just had a thought that I might
want to have a more efficient dictionary type,

181
00:14:23,394 --> 00:14:24,940
but we'll come to that later.

182
00:14:24,948 --> 00:14:27,320
So we're given two words A and B:

183
00:14:27,320 --> 00:14:45,354
A is an element in the dictionary
and we want the negation of that.

184
00:14:45,354 --> 00:14:54,354
Or B is not an element in the dictionary,
we'll return nothing as well.

185
00:14:55,520 --> 00:14:56,845
I think that's what we want.

186
00:14:57,291 --> 00:15:00,765
See if that compiles.

187
00:15:02,450 --> 00:15:08,205
SP: You'll probably find that
"Haskell" will not be in the dictionary.

188
00:15:08,910 --> 00:15:11,794
OC: OK well we can check that...

189
00:15:17,600 --> 00:15:19,394
It is in the dictionary! (laughter)

190
00:15:19,960 --> 00:15:21,302
SP: It's a respectable word list!

191
00:15:21,300 --> 00:15:23,508
OC: But "Haskello" isn't
in the dictionary, so...

192
00:15:25,880 --> 00:15:32,560
I guess then we probably need to deal with
case, or maybe I should be case sensitive.

193
00:15:32,740 --> 00:15:38,034
Capital "Hello" is not in the dictionary,
but lower case "hello" will be... Yes.

194
00:15:38,710 --> 00:15:40,280
I think I'll leave that for now.

195
00:15:40,280 --> 00:15:42,834
SP: I think that's how it should work. Yes.

196
00:15:42,834 --> 00:15:43,600
OC: OK.

197
00:15:43,748 --> 00:15:47,497
SP: Let's presume that the input
would be exactly as it is in the dictionary

198
00:15:47,497 --> 00:15:49,930
or it's strictly considered invalid.

199
00:15:49,940 --> 00:15:51,668
OC: OK, seems reasonable.

200
00:15:53,950 --> 00:15:59,862
And I expect there's another obvious
pattern, which is regardless of the dictionary,

201
00:16:00,160 --> 00:16:03,897
we have two words A and B, and
they are the same, then we're done.

202
00:16:03,900 --> 00:16:09,874
So that has one possible solution, and I think
I'm still going to put that solution in the word chain.

203
00:16:09,970 --> 00:16:11,485
So if we go from hello to hello,

204
00:16:11,497 --> 00:16:15,634
the solution will be one word
chain which contains just the word hello.

205
00:16:16,710 --> 00:16:19,188
So we can try that one too.

206
00:16:19,180 --> 00:16:22,434
[Ollie types]

207
00:16:22,788 --> 00:16:24,660
Whoops! so let's see:

208
00:16:24,660 --> 00:16:30,742
wordPuzzle, given a dictionary,
from "hello" to "hello"

209
00:16:30,800 --> 00:16:35,577
It does indeed have one solution
which is the word chain hello. Good!

210
00:16:35,660 --> 00:16:41,702
So, beyond that we've ruled out the obvious
case and we need to start doing some real work.

211
00:16:41,960 --> 00:16:45,177
And I think a useful function that we're going to need

212
00:16:45,188 --> 00:16:49,154
is something that's going to
determine the distance between two words.

213
00:16:49,154 --> 00:16:53,540
Which is going to be the amount of
changes you have to make to get between two words.

214
00:16:53,540 --> 00:16:58,628
SP: Yes, or at least whether they
are one step apart from each other.

215
00:16:58,620 --> 00:17:03,840
OC: Yes because once we have a function
that gives us metric and distance between words

216
00:17:03,862 --> 00:17:08,891
I'm hoping I can map over all of these
words and find the neighbors of any word.

217
00:17:08,890 --> 00:17:13,085
The neighbors are going to be
words some distance away... by one.

218
00:17:13,150 --> 00:17:18,480
So let's have... distance which is going to
take two text values and give us back a number.

219
00:17:20,360 --> 00:17:24,274
So if they are the same then
of course, the distance is just zero.

220
00:17:27,340 --> 00:17:29,622
So how we going to do this next...let's see.

221
00:17:29,620 --> 00:17:32,948
[Ollie thinks]

222
00:17:33,074 --> 00:17:37,542
I'm probably going to break the
string apart and treat it as if it were a list.

223
00:17:37,620 --> 00:17:40,365
And I will compare the
head, and see if they're different.

224
00:17:40,365 --> 00:17:43,610
and if they're not the distance there is zero.

225
00:17:43,620 --> 00:17:45,782
But if they are different the difference will be one.

226
00:17:45,794 --> 00:17:49,097
SP: Are you once again assuming
that A and B are the same length?

227
00:17:49,130 --> 00:17:54,160
OC: Yes I'm going to assume
for this function they are the same length.

228
00:17:54,160 --> 00:18:00,530
And if not, well it might actually
work even if they're different lengths.

229
00:18:03,085 --> 00:18:06,765
SP:  What comes to my mind is
zipping the characters of the two together

230
00:18:06,770 --> 00:18:09,620
and seeing how many pairs are not identical.

231
00:18:09,737 --> 00:18:12,902
OC: Yes, that sounds like
the kind of thing we could do.

232
00:18:12,940 --> 00:18:15,920
I think now because we're
zipping, even if they're different lengths

233
00:18:15,920 --> 00:18:18,102
we can probably just drop the extra characters.

234
00:18:18,110 --> 00:18:24,022
And I think we have a zip
function already in the text library...

235
00:18:25,897 --> 00:18:29,620
We do... that's going to compare characters.

236
00:18:30,030 --> 00:18:37,908
It works on text so we can only use it to
zip two pieces of text, which is not so useful.

237
00:18:38,600 --> 00:18:44,331
So take A and B and we will zip A and B.

238
00:18:45,200 --> 00:18:49,170
So I'm going to use type holes
quite a bit here.

239
00:18:49,910 --> 00:18:56,560
OK, So we need to have a function which
takes a list of pairs of characters to a number.

240
00:19:02,377 --> 00:19:06,560
I think first thing we'll do is map over those,

241
00:19:06,674 --> 00:19:09,862
so we can consider each
pair of characters independently.

242
00:19:13,020 --> 00:19:20,205
Oh dear, I'll ignore that for now,
next type hole we have a pair of characters,

243
00:19:20,217 --> 00:19:21,910
which have to produce something.

244
00:19:30,620 --> 00:19:38,011
So if x is equal to y... then zero otherwise that's one.

245
00:19:38,022 --> 00:19:40,434
That's one possible correction we have to do.

246
00:19:44,710 --> 00:19:47,280
Now we need to take a list of things like a number.

247
00:19:47,280 --> 00:19:51,462
I don't know why it hasn't...
Oh, because B could be any type of numeric.

248
00:19:56,600 --> 00:19:58,457
Ok, so that's good.

249
00:19:58,600 --> 00:20:02,525
So it's hacking into our distance
functions we can switch back to GHCi

250
00:20:02,548 --> 00:20:04,430
and see what it makes of that.

251
00:20:05,740 --> 00:20:10,480
So let's see if the difference
between dog and cog is indeed one.

252
00:20:12,617 --> 00:20:15,794
That's what you would expect. A basic example.

253
00:20:18,765 --> 00:20:22,000
Let's see how we can fit this into our word puzzle.

254
00:20:22,971 --> 00:20:28,540
We're certainly going to
eed the dictionary and our two words.

255
00:20:32,080 --> 00:20:36,480
So I'm going to start with the word A
and we need to find the neighbors of word A.

256
00:20:37,211 --> 00:20:41,051
So I'm going to go over the dictionary, well I'm going to ...

257
00:20:42,068 --> 00:20:49,714
Let's filter the dictionary so we don't have A in it.

258
00:21:03,680 --> 00:21:07,211
That's going to give me a
dictionary that doesn't have A in it.

259
00:21:10,740 --> 00:21:14,240
Maybe if we pair every word with its distance...

260
00:21:14,760 --> 00:21:19,028
so I can take every word in the
dictionary and find its distance against word A.

261
00:21:19,302 --> 00:21:22,777
And then I can take the ones
that just have a distance of 1.

262
00:21:23,010 --> 00:21:26,022
And that again feels like
I'm zipping 2 lists together.

263
00:21:26,650 --> 00:21:28,217
SP: OK.

264
00:21:29,820 --> 00:21:34,525
OC: First we need to map that for every word.

265
00:21:34,770 --> 00:21:39,748
We're going to keep the word and I'm
also going to keep the distance between A and W.

266
00:21:43,510 --> 00:21:46,331
Actually this is like what I'm saying.

267
00:21:46,340 --> 00:21:53,680
Let's say neighbors takes the
dictionary and gives us back a list of words.

268
00:22:04,445 --> 00:22:07,085
And now we've got this map.

269
00:22:07,090 --> 00:22:11,874
And we need to filter this for all
things that have a distance of exactly 1.

270
00:22:11,980 --> 00:22:13,622
So let's filter...

271
00:22:13,620 --> 00:22:22,845
[Ollie types]

272
00:22:23,170 --> 00:22:28,091
It's a bit long there... I'll re-format that slightly.

273
00:22:37,000 --> 00:22:39,954
Bit of a hole there, we can come back to that.

274
00:22:39,970 --> 00:22:42,754
So does that build?

275
00:22:45,257 --> 00:22:47,120
OK, so what have we got here?

276
00:22:49,770 --> 00:22:56,571
Ah, OK, so I've filtered this but I also need
to map it just so it will take the word... so that's A.

277
00:22:57,280 --> 00:23:03,782
And once more, and take just
the word and ignore its distance.

278
00:23:03,988 --> 00:23:06,994
SP: Is there a function for that, is it fst?

279
00:23:07,680 --> 00:23:10,057
OC: Yes, we can use fst there.

280
00:23:23,400 --> 00:23:26,525
Good, so we're back to compiling once more.

281
00:23:27,600 --> 00:23:28,994
So I'll give that a try.

282
00:23:28,990 --> 00:23:41,291
[Ollie types]

283
00:23:41,600 --> 00:23:44,857
Let's find neighbors of dog.

284
00:23:44,868 --> 00:23:46,800
We need the dictionary there as well.

285
00:23:49,760 --> 00:23:52,000
It doesn't seem quite right to me (laughter).

286
00:23:52,010 --> 00:23:57,680
SP: I think this is probably a result
of zipping, and not taking into consideration

287
00:23:57,680 --> 00:24:03,382
that if the lengths of the two words are different,

288
00:24:04,137 --> 00:24:07,691
then zip would finish at the shortest sequence.

289
00:24:07,691 --> 00:24:08,520
OC: Right.

290
00:24:09,930 --> 00:24:16,570
SP: And so, all of these like 'downfall'
would be only one letter away from 'dog'.

291
00:24:16,674 --> 00:24:19,040
So maybe you should only look at the first one.

292
00:24:19,051 --> 00:24:21,940
OC: Maybe we should be
filtering the dictionary first

293
00:24:21,942 --> 00:24:24,428
on getting words that are only the same length.

294
00:24:24,420 --> 00:24:26,240
We certainly have done that here.

295
00:24:26,240 --> 00:24:28,240
SP: Yes.

296
00:24:28,240 --> 00:24:35,200
[Ollie thinks]

297
00:24:35,874 --> 00:24:40,540
OC: I'm going to bring
in some smaller functions there.

298
00:24:53,570 --> 00:24:56,971
The idea here is I'm probably
going to use the Applicative Syntax

299
00:24:56,970 --> 00:24:59,417
to combine 2 boolean operations together.

300
00:24:59,450 --> 00:25:01,880
So I want to take
things that are not equal to A.

301
00:25:03,940 --> 00:25:06,331
SP: And also the /= operator?

302
00:25:06,450 --> 00:25:07,885
OC: Oh yes, of course.

303
00:25:09,740 --> 00:25:12,370
In fact we'll put that directly in there.

304
00:25:15,680 --> 00:25:18,697
So we need it to satisfy 2 conditions.

305
00:25:23,400 --> 00:25:34,285
We should be able to do this...
it's the length is equal to the length of A.

306
00:25:36,340 --> 00:25:40,194
I think we'll probably be
able to tidy that function up as well.

307
00:25:40,280 --> 00:25:47,154
So I'll take those back out, and we're
going to need to import Control.Applicative.

308
00:25:47,874 --> 00:25:50,662
SP: So I notice here that
even though you presumably knew

309
00:25:50,660 --> 00:25:55,085
that you were going to import Control.Applicative,

310
00:25:55,180 --> 00:26:00,914
your habit is to immediately try
compiling and have the compiler to tell you that.

311
00:26:00,925 --> 00:26:01,325
OC: Yes.

312
00:26:01,420 --> 00:26:07,325
SP: So this is really an analogue of the TDD
work-flow where you are going for the failing test?

313
00:26:07,400 --> 00:26:08,960
OC: That's right yes.

314
00:26:10,697 --> 00:26:18,274
In import Control.Applicative, I want that to
be the last step of this bit of code I'm doing

315
00:26:18,270 --> 00:26:22,400
I don't want to import Control.Applicative
and find out I had invalid syntax

316
00:26:22,450 --> 00:26:24,280
and then I have to context switch again.

317
00:26:26,370 --> 00:26:29,737
I've used length from the
prelude here, but we have text values

318
00:26:29,770 --> 00:26:33,862
and length cannot be used on text values.

319
00:26:33,862 --> 00:26:37,314
We're using strings so we need to use T.length.

320
00:26:40,540 --> 00:26:44,000
So hopefully we're back to compiling that.

321
00:26:44,400 --> 00:26:49,371
So let's try that one again,
and see if it makes more sense this time.

322
00:26:51,620 --> 00:26:53,080
That looks a lot better to me.

323
00:26:54,020 --> 00:26:54,925
OK!

324
00:26:59,097 --> 00:27:01,805
SP: Now Ollie could you explain this section here

325
00:27:01,817 --> 00:27:06,217
where you've used the
operators from Control.Applicative.

326
00:27:06,910 --> 00:27:10,262
OC:  We're working under the reader applicative here,

327
00:27:10,310 --> 00:27:15,200
which is basically an applicative
functor that works for function arrows.

328
00:27:15,250 --> 00:27:19,222
So what I want to do is, take the
same argument as I filter over the dictionary

329
00:27:19,280 --> 00:27:20,885
for every word in the dictionary.

330
00:27:20,914 --> 00:27:23,220
I need to check  that that word is not equal to A.

331
00:27:23,220 --> 00:27:27,051
And I also need to check that
its length is equal to the length of A.

332
00:27:27,080 --> 00:27:30,217
So I need to do an operation on the same value.

333
00:27:30,228 --> 00:27:31,165
SP: Right.

334
00:27:31,160 --> 00:27:35,462
OC: So I could have introduced a lambda
here and banged that to a variable called W

335
00:27:35,540 --> 00:27:41,348
and said W is not equal to A and
that the length of W is the length of A.

336
00:27:41,570 --> 00:27:44,902
But by using this syntax here, it's going to

337
00:27:44,902 --> 00:27:48,210
implicitly thread that argument
through to both the functions for me.

338
00:27:48,210 --> 00:27:51,040
So I don't have to worry
about passing the right argument in.

339
00:27:51,050 --> 00:27:54,331
By using the right structure
here that kind of comes for free.

340
00:27:55,280 --> 00:27:59,131
And there's one other thing I want
to tidy up, this is looking a bit weird,

341
00:27:59,210 --> 00:28:02,971
and we've got some helpful
functions in the Data.Function library,

342
00:28:02,980 --> 00:28:05,977
that comes in the base library of Haskell,

343
00:28:05,988 --> 00:28:08,370
so I'm wondering if we can use something there.

344
00:28:08,370 --> 00:28:12,914
I'm going to have a quick look at the base
library just to see if anything looks useful there.

345
00:28:15,540 --> 00:28:17,417
SP: Do you tend to use Hoogle?

346
00:28:18,300 --> 00:28:20,777
OC: I do use Hoogle occasionally but that's more

347
00:28:20,788 --> 00:28:23,310
when I know the function
that I'm going to work with.

348
00:28:23,310 --> 00:28:27,302
Whereas in this case I just want to look
at the types and see if anything stands out.

349
00:28:27,634 --> 00:28:29,910
SP: Because in Hoogle you can search by the type.

350
00:28:29,940 --> 00:28:35,965
OC: Right yes, but here I suppose I'm not
entirely sure what type I'm going to be looking for.

351
00:28:35,977 --> 00:28:39,170
I want to just look through it
and see if anything comes intuitively.

352
00:28:39,170 --> 00:28:41,610
But if we don't find anything
then I will leave it for now.

353
00:28:41,610 --> 00:28:45,800
But it's these combinators down here, like
'on' which is probably going to be the most useful.

354
00:28:45,817 --> 00:28:52,057
So, you can see that 'on' as a typical usage lets you
call the same function on two different arguments.

355
00:28:52,057 --> 00:28:55,390
So let's see if we can use that.

356
00:28:55,870 --> 00:29:00,262
So we're certainly going to be
doing 'on'...well it takes 2 arguments and...

357
00:29:03,497 --> 00:29:06,365
It takes a function of two arguments
and also a function of one argument.

358
00:29:06,420 --> 00:29:09,622
Well our function one argument is T.length,

359
00:29:11,650 --> 00:29:14,605
and our function two arguments is just equality.

360
00:29:15,820 --> 00:29:19,028
So we need the check for equality on length.

361
00:29:19,020 --> 00:29:26,320
[Ollie types]

362
00:29:26,450 --> 00:29:31,691
So you can normally use it
with infix notation like this,

363
00:29:31,931 --> 00:29:35,060
but that's when you've got two arguments to supply.

364
00:29:35,062 --> 00:29:36,765
We're only going to supply one argument.

365
00:29:36,760 --> 00:29:41,245
so I think I'm actually going to switch
this back round and do a normal prefix notation.

366
00:29:41,280 --> 00:29:44,308
So 'on' equality, T.length against 'A',

367
00:29:44,340 --> 00:29:49,154
and it's going to supply us with a
second argument for each word in the dictionary.

368
00:29:49,170 --> 00:29:50,280
SP: Right.

369
00:29:50,860 --> 00:29:54,171
OC: So compile that and we're
going to be told that we need to import it.

370
00:29:54,240 --> 00:30:01,657
So let's bring that in... and that's in... Data.Function.

371
00:30:04,845 --> 00:30:06,800
Good! So that's back to compiling.

372
00:30:06,811 --> 00:30:08,994
And we're back in the hole here.

373
00:30:08,990 --> 00:30:12,937
So I think I'm happy with that,
it's a fairly clean readable description.

374
00:30:13,020 --> 00:30:16,857
We do have quite a lot of loops going on
there, but I'm going to ignore that for now,

375
00:30:16,880 --> 00:30:21,508
Maybe we can optimize that later, but
for now that's certainly solved the problem.

376
00:30:26,834 --> 00:30:31,280
For our actual word puzzle problem, we know
that the words are different, but the same length.

377
00:30:31,570 --> 00:30:34,340
I'm going to find all the neighbors around the word A,

378
00:30:34,340 --> 00:30:38,960
and then try and find all of the
solutions from all of the neighbors of A.

379
00:30:38,982 --> 00:30:40,640
See if any of them gets us to B.

380
00:30:40,800 --> 00:30:42,510
In which case those will be our possible solutions.

381
00:30:42,510 --> 00:30:47,531
So we'll start by taking the
neighbors of A, and the same dictionary.

382
00:30:47,530 --> 00:30:53,268
And now, we'll ask GHC
what we need to do next.

383
00:30:53,540 --> 00:30:54,600
I've put a hole here.

384
00:30:54,600 --> 00:30:58,628
So I'm going to write some sort of
function that will take all these neighbors.

385
00:30:58,680 --> 00:31:00,510
Let's have a look at the type of that.

386
00:31:02,000 --> 00:31:06,137
We're going to have a list of text
and we need to go to a list of word chains.

387
00:31:07,177 --> 00:31:09,622
So that list of text is all the possible neighbors.

388
00:31:09,725 --> 00:31:17,965
So I'm going to map over that and now I
have the function that goes from  text to word chain.

389
00:31:20,600 --> 00:31:23,954
So how is best to do this?

390
00:31:23,950 --> 00:31:32,594
I probably want to go to a list of word
chains, because I want to recurse and use

391
00:31:32,617 --> 00:31:35,880
wordPuzzle again and eventually we'll reach
a base case where the two words are equal.

392
00:31:38,940 --> 00:31:42,080
Even though this has the same
type, I want to see what we get to.

393
00:31:42,080 --> 00:31:44,285
We're going to be using the same dictionary.

394
00:31:44,777 --> 00:31:52,731
And were going to go to B and go on to N and N to B.

395
00:31:52,788 --> 00:31:55,120
That's probably not going to type check.

396
00:31:57,600 --> 00:31:59,970
We couldn't match a list of text with text.

397
00:32:01,040 --> 00:32:03,714
Oh! that's because the word chain is a list of text.

398
00:32:04,140 --> 00:32:07,840
It's expecting a single word chain
but we've actually got many word chains.

399
00:32:07,840 --> 00:32:10,045
So I think the problem here is that...

400
00:32:10,880 --> 00:32:15,382
if we put another type hole there,
we'll see that this could actually typecheck,

401
00:32:15,520 --> 00:32:18,491
provided we had a function that
went from a list of lists of word chains

402
00:32:18,502 --> 00:32:20,050
to just a list of word chains.

403
00:32:20,290 --> 00:32:22,251
Which is of course 'concat'.

404
00:32:22,800 --> 00:32:25,462
And we have a function in the standard library...

405
00:32:26,548 --> 00:32:29,000
I'm going to remove that hole.

406
00:32:29,000 --> 00:32:33,462
There's a function in the standard library
that does these two things together... concatMap,

407
00:32:33,485 --> 00:32:35,570
because it's such a common operation.

408
00:32:36,160 --> 00:32:38,697
ConcatMap that there...

409
00:32:41,451 --> 00:32:47,400
and I guess we'll leave that as a hole
for now and play with it in GHCi again.

410
00:32:47,400 --> 00:32:52,525
If I load the dictionary, I should be able
to now try of one of the example problems.

411
00:32:52,537 --> 00:32:59,314
Let's try wordPuzzle dict dog to cat.

412
00:33:04,450 --> 00:33:07,693
That is impressively slow right now (laughter)

413
00:33:07,817 --> 00:33:12,674
And I'm not sure if that's because this doesn't
terminate or because we're being so inefficient.

414
00:33:12,670 --> 00:33:19,657
SP: Now... By the time you go from dog
to dot one of the neighbors of dot is dog.

415
00:33:19,668 --> 00:33:22,460
OC: So we're actually
going back on ourselves probably.

416
00:33:22,460 --> 00:33:24,346
SP: That's potentially what's happening.

417
00:33:24,628 --> 00:33:26,777
OC: That sounds very reasonable to me. Yes.

418
00:33:28,370 --> 00:33:32,653
So we need to probably carry some extra state around.

419
00:33:33,986 --> 00:33:36,440
So I'm going to put this down here.

420
00:33:39,800 --> 00:33:43,946
We probably need to remove
something from the dictionary

421
00:33:43,970 --> 00:33:48,786
which I guess is going to be when we go here.

422
00:33:49,250 --> 00:33:53,268
It will probably want to be a
dictionary without the word N itself.

423
00:33:54,293 --> 00:33:56,213
And also not A.

424
00:33:59,650 --> 00:34:02,102
I've already removed A here,

425
00:34:02,114 --> 00:34:05,451
so I'm wondering if maybe that
should be done further up here.

426
00:34:07,800 --> 00:34:10,034
We'll try it anyway, let's just try it here.

427
00:34:10,030 --> 00:34:17,954
[Ollie types]

428
00:34:18,250 --> 00:34:23,314
So let's filter the dictionary
for stuff that's not equal to N.

429
00:34:23,310 --> 00:34:28,171
[Ollie types]

430
00:34:28,280 --> 00:34:31,880
It's still happy compiling... which is good.

431
00:34:38,080 --> 00:34:41,257
That's better but apparently
we now have no solutions at all.

432
00:34:41,250 --> 00:34:44,813
At least we do terminate. (laughter).

433
00:34:46,546 --> 00:34:49,680
SP: So termination but wrong
is better than no termination.

434
00:34:49,680 --> 00:34:53,325
OC: I think so. At least we know
that it will eventually deliver an answer

435
00:34:53,337 --> 00:34:54,811
even if it is the wrong answer.

436
00:34:55,097 --> 00:34:57,360
So what I want to check now...

437
00:34:57,380 --> 00:35:01,440
We expected this sort of chain dog, cog, cot to cat,

438
00:35:01,474 --> 00:35:05,497
so maybe if we just try cot to
cat and see if we get that solution.

439
00:35:05,530 --> 00:35:11,794
OC: For the smallest thing I
can think of that was cot to cat.

440
00:35:12,186 --> 00:35:14,800
Again that seems to have no solutions.

441
00:35:19,760 --> 00:35:24,605
It does indeed contain cat it's right there
at the start, so we should certainly be seeing that.

442
00:35:24,640 --> 00:35:30,868
So let's see ... take the neighbors around A...

443
00:35:32,582 --> 00:35:35,908
And for each of those we call a word puzzle.

444
00:35:35,940 --> 00:35:41,600
[Ollie ponders]

445
00:35:42,626 --> 00:35:43,986
The same target...

446
00:35:43,980 --> 00:35:50,822
[Ollie ponders]

447
00:35:50,880 --> 00:35:55,746
SP: So here you're excluding
words that are the neighbor?

448
00:35:56,020 --> 00:35:57,000
OC: Yes

449
00:35:57,026 --> 00:36:00,613
SP: Perhaps instead you should be excluding A.

450
00:36:03,337 --> 00:36:06,240
Because that's the one you
don't want to return to later.

451
00:36:09,000 --> 00:36:10,942
You know that you've got that one.

452
00:36:11,310 --> 00:36:12,662
OC: Great job!

453
00:36:15,880 --> 00:36:21,942
So we don't want to come back to where
we started that certainly does make sense.

454
00:36:21,940 --> 00:36:29,645
[Ollie types]

455
00:36:30,011 --> 00:36:33,005
And now we go from cot to cat.

456
00:36:35,330 --> 00:36:41,542
We're certainly finding some solutions
but never stopping the search (laughter).

457
00:36:41,650 --> 00:36:44,445
Which is interesting. So, what's going on there?

458
00:36:44,754 --> 00:36:46,440
I guess it's...

459
00:36:46,740 --> 00:36:48,845
When we loop over there this...

460
00:36:49,380 --> 00:36:52,533
Well I'm interested to see
if this will actually terminate

461
00:36:52,530 --> 00:36:55,600
and be the same length as all the neighbors of cot.

462
00:36:59,066 --> 00:37:00,733
But maybe this won't terminate.

463
00:37:00,730 --> 00:37:07,188
[Ollie thinks]

464
00:37:07,420 --> 00:37:09,497
OK, maybe not (laughter).

465
00:37:09,977 --> 00:37:13,554
SP: The fan indicated that some
work was being done (laughter).

466
00:37:13,565 --> 00:37:19,954
OC: Although, are we actually able to fully compute
all of the neighbors around "cot"? We certainly are OK.

467
00:37:20,020 --> 00:37:25,268
So, we're not hitting our base
case properly, which is interesting.

468
00:37:34,530 --> 00:37:39,794
We're certainly getting here
because that's where we return the result.

469
00:37:49,480 --> 00:37:54,053
Maybe if we take all
the solutions of neighbor.

470
00:37:54,050 --> 00:37:58,628
[Ollie types]

471
00:37:59,160 --> 00:38:05,462
So if we couldn't find any solutions there then
we won't be able to find any bigger solutions.

472
00:38:15,170 --> 00:38:20,365
If we did find a solution then
we should be able to go for it.

473
00:38:23,211 --> 00:38:26,010
Yes, that seems reasonable.

474
00:38:27,600 --> 00:38:30,800
So I think that's largely OK.

475
00:38:33,386 --> 00:38:35,213
We've got an error there somewhere.

476
00:38:36,220 --> 00:38:42,080
So N is expecting a word
chain that's actually a piece of text.

477
00:38:43,540 --> 00:38:45,577
That seems somewhat odd.

478
00:38:49,770 --> 00:38:53,600
SP: So the word puzzle
will return a list of solutions,

479
00:38:53,620 --> 00:38:59,897
so do you not need to prepend each
of the items in that list of solutions?

480
00:38:59,897 --> 00:39:01,337
OC: Ah! of course, yes.

481
00:39:02,050 --> 00:39:05,293
SP: So I think it would be just 'map of' prepend.

482
00:39:05,290 --> 00:39:10,045
OC: Yes. We could also use Applicative
Syntax which is not much different.

483
00:39:10,080 --> 00:39:12,450
But we could also do something like that.

484
00:39:12,651 --> 00:39:15,450
For every S we're going to prepend it with N.

485
00:39:15,462 --> 00:39:16,285
SP: Right.

486
00:39:18,973 --> 00:39:21,413
OC: OK, so we're back to compiling again.

487
00:39:21,410 --> 00:39:32,548
[Ollie types]

488
00:39:33,600 --> 00:39:37,346
Let's see if we can make any sense of that.

489
00:39:37,680 --> 00:39:40,891
Cat to cat and then
every other word in the dictionary.

490
00:39:40,891 --> 00:39:43,940
We're eventually getting to
cat. That's certainly happening.

491
00:39:45,826 --> 00:39:48,986
I guess that is a valid word chain (laughter).

492
00:39:49,080 --> 00:39:52,466
Is it just that there are this
many possible word chains I guess.

493
00:39:53,060 --> 00:39:57,485
The first one is certainly wrong though.
That's certainly not a chain from cat to cat.

494
00:39:57,485 --> 00:39:58,970
That should be cot to cat.

495
00:40:01,360 --> 00:40:04,080
I better start fixing that bug.

496
00:40:04,080 --> 00:40:05,950
[Silence]

497
00:40:05,950 --> 00:40:08,274
SP: There are immediately some
very long chains.

498
00:40:08,450 --> 00:40:09,805
OC: They are very long chains.

499
00:40:09,817 --> 00:40:11,920
SP: Cod to cat was the next one.

500
00:40:12,866 --> 00:40:15,110
OC: They're certainly valid chains though.

501
00:40:15,110 --> 00:40:15,640
SP: Yes.

502
00:40:15,640 --> 00:40:19,142
[Ollie types]

503
00:40:19,337 --> 00:40:26,080
OC: So what's going wrong on that first one though?

504
00:40:27,053 --> 00:40:28,386
We have cat.

505
00:40:30,773 --> 00:40:33,653
The problem is I think
we should have been prepending...

506
00:40:35,466 --> 00:40:38,906
A rather than N - or possibly both of them.

507
00:40:38,900 --> 00:40:40,034
Let's just see what that is,

508
00:40:40,040 --> 00:40:43,131
because we want to go from the word we're starting at.

509
00:40:43,130 --> 00:40:48,342
[Ollie types]

510
00:40:48,910 --> 00:40:52,080
And now we certainly have
the right solution at the front.

511
00:40:52,080 --> 00:40:54,506
And we can of course exploit laziness,

512
00:40:54,500 --> 00:40:58,114
hopefully just see the very
first solution and it terminates.

513
00:40:58,480 --> 00:41:01,851
And finally that's one word
chain that has certainly got us there.

514
00:41:01,940 --> 00:41:03,013
SP: OK.

515
00:41:03,737 --> 00:41:05,988
OC: So we need to decide
where we want to go next.

516
00:41:05,980 --> 00:41:09,348
If we want to find all possible
word chains in a short amount of time.

517
00:41:09,348 --> 00:41:12,980
Or if we want to make sure
that this is definitely the shortest chain.

518
00:41:15,220 --> 00:41:21,702
At this point, finding the shortest chain
we just need to sort by the length descending.

519
00:41:23,173 --> 00:41:26,000
But this now, because we're sorting the entire list,

520
00:41:26,000 --> 00:41:31,017
Is going to have to consider
the entire set of possible solutions.

521
00:41:31,060 --> 00:41:37,474
SP: We probably need to think
about expanding the chains progressively.

522
00:41:39,530 --> 00:41:44,580
And returning first the ones that are the shortest.

523
00:41:44,697 --> 00:41:47,573
OC: Right so a greedier search, as we go through.

524
00:41:50,250 --> 00:41:56,228
I'm going to try and see how long it
takes to solve the whole list of solutions.

525
00:41:56,380 --> 00:42:00,582
We have a function here,
'sort by' which takes a list of type A.

526
00:42:00,580 --> 00:42:04,262
And if we have a way to compare
them for an ordering we can do something.

527
00:42:04,386 --> 00:42:10,426
So Data.Function also has,
or it might be in Data.Ord

528
00:42:12,400 --> 00:42:14,200
We have comparing.

529
00:42:14,570 --> 00:42:21,453
So we can say comparing on length.
That takes a list of a to a list of a.

530
00:42:22,680 --> 00:42:26,217
Which is just what we want,
a word chain as a list of texts.

531
00:42:27,490 --> 00:42:32,468
So sort by comparing length.

532
00:42:35,330 --> 00:42:37,588
And it's certainly not a good solution.

533
00:42:37,580 --> 00:42:43,120
In the original spec of the kata it said it
should be returning results in less than a second.

534
00:42:43,142 --> 00:42:44,970
But we're well over that.

535
00:42:59,080 --> 00:43:05,234
So I think we got our one solution
there from cog to cat, purely by chance.

536
00:43:05,245 --> 00:43:07,540
Because cat comes first in the dictionary

537
00:43:07,546 --> 00:43:10,866
and what we're doing here
is basically a depth first search.

538
00:43:10,860 --> 00:43:13,897
So the moment we hit that one
neighbor, we go as far away as we can

539
00:43:13,897 --> 00:43:18,194
to try and get all the way to cat which
is not really the most efficient use of our time.

540
00:43:18,200 --> 00:43:23,051
We're going to need to change this from
a depth first solution to a breadth first solution.

541
00:43:23,080 --> 00:43:25,933
What we're going to do is go over each of the neighbors

542
00:43:25,930 --> 00:43:29,348
and try to expand that word
chain of the neighbor to go one bigger,

543
00:43:29,640 --> 00:43:33,253
and hopefully we will eventually end at B.

544
00:43:33,817 --> 00:43:37,737
B is certainly in the dictionary, in which
case we've finished our breadth first search.

545
00:43:37,748 --> 00:43:40,000
At least to get the shortest path.

546
00:43:40,000 --> 00:43:42,420
SP: And since you're removing the word each time

547
00:43:42,420 --> 00:43:46,560
eventually you won't be
able to expand your search any further

548
00:43:46,580 --> 00:43:49,546
because you'll run out of
neighbors for the next word.

549
00:43:50,320 --> 00:43:53,706
OC, Yes. So I'm going to leave
word puzzle alone for the moment

550
00:43:53,770 --> 00:43:58,540
Instead let's try and use
some kind of expand function.

551
00:43:58,697 --> 00:44:02,320
So that's going to take a
word chain and give us back

552
00:44:02,346 --> 00:44:04,640
all possible expansions of the word chain,

553
00:44:05,360 --> 00:44:07,746
We need the dictionary there as well.

554
00:44:09,170 --> 00:44:10,770
I think that's what I want to do.

555
00:44:20,840 --> 00:44:22,820
We're going to work
from the head of the chain

556
00:44:22,820 --> 00:44:24,020
and try to expand that.

557
00:44:26,600 --> 00:44:29,546
There is obviously the
case where we've got

558
00:44:30,120 --> 00:44:32,346
no words at all in the chain.

559
00:44:32,560 --> 00:44:35,666
That's not really an
invariant I want to have in the code.

560
00:44:35,720 --> 00:44:39,740
But we should probably deal with it anyway
in which case there's no expansions on that.

561
00:44:40,960 --> 00:44:47,920
Otherwise we have a
word on some other words

562
00:44:48,026 --> 00:44:51,000
and now by all the
neighbors in the dictionary.

563
00:44:51,050 --> 00:44:56,920
W and put those on the
word chain we've got so far.

564
00:45:04,370 --> 00:45:08,400
So neighbors gives us a list of words and

565
00:45:08,680 --> 00:45:11,106
that's already a list of word chains.

566
00:45:15,770 --> 00:45:24,050
I find the neighbors of w
but I need to use a list cons there.

567
00:45:34,000 --> 00:45:40,453
I'm going to move away from
putting this there... Just map over these.

568
00:45:41,680 --> 00:45:46,426
SP: That's not a bad example
of a case for a list comprehension.

569
00:45:46,573 --> 00:45:47,373
OC: OK.

570
00:45:49,340 --> 00:45:52,280
OC: Sure well let's try
another one of those conventions

571
00:45:53,480 --> 00:45:56,910
we need to... go over there.

572
00:45:56,910 --> 00:46:01,200
the neighbors and dict and w

573
00:46:08,370 --> 00:46:11,920
and we'll put that into binding n.

574
00:46:14,050 --> 00:46:17,613
Now I need to
produce a single word chain here,

575
00:46:18,906 --> 00:46:22,173
that will be n, w, ws, I think.

576
00:46:26,340 --> 00:46:28,400
And we're back to compiling again - good.

577
00:46:31,493 --> 00:46:35,040
I should be able to load the dictionary in

578
00:46:39,370 --> 00:46:44,573
and expand and type that back up...

579
00:46:45,720 --> 00:46:49,520
And word chains, so why don't
I just start with the word cat.

580
00:46:50,620 --> 00:46:52,940
So that seems to be doing
what I would expect,

581
00:46:52,940 --> 00:46:54,770
the expansion is on the front.

582
00:46:55,740 --> 00:46:59,680
So now let's see if we can
feed this back in to our word puzzle.

583
00:47:01,620 --> 00:47:03,866
I think I'll leave this around for now
and just comment that out.

584
00:47:05,930 --> 00:47:06,868
[Ollie types]

585
00:47:09,880 --> 00:47:14,057
So we're going to start at word a
and we need to reach word b.

586
00:47:15,200 --> 00:47:20,571
So we'll start with a word
chain which is just the word a.

587
00:47:20,613 --> 00:47:21,933
That's a chain of one word.

588
00:47:22,280 --> 00:47:26,253
I will expand that to
a list of possible word chains.

589
00:47:27,050 --> 00:47:29,986
Let's see what I need to do with that.

590
00:47:31,510 --> 00:47:33,370
Well that one actually works so far,

591
00:47:33,370 --> 00:47:36,013
but it's certainly
not going to be the solution.

592
00:47:38,173 --> 00:47:40,320
Now I should be able to...

593
00:47:40,330 --> 00:47:45,302
[Ollie types]

594
00:47:47,880 --> 00:47:51,586
So that's just a one
level breadth-first search.

595
00:47:51,580 --> 00:47:54,533
We need to go a bit further
than that to find something useful,

596
00:47:54,546 --> 00:48:00,133
so I think now
we just need to keep expanding

597
00:48:00,946 --> 00:48:08,120
until we have B at the front of the list.

598
00:48:08,120 --> 00:48:08,786
SP: Yes.

599
00:48:11,110 --> 00:48:13,786
OC: We can probably use
iterate to do that.

600
00:48:13,786 --> 00:48:16,213
SP: Or until you don't
have any further expansions.

601
00:48:16,210 --> 00:48:22,125
OC: Ah! that's one thing we've not done so
far is reducing this dictionary.

602
00:48:26,493 --> 00:48:27,826
Where would I put that in?

603
00:48:27,820 --> 00:48:35,200
So after one expansion, this is probably
returning me a smaller dictionary as well.

604
00:48:36,020 --> 00:48:39,220
When I expand a word chain
the dictionary becomes smaller.

605
00:48:45,480 --> 00:48:46,940
SP: That would be reasonable.

606
00:48:46,940 --> 00:48:49,373
OC: Let's see what we get with that...

607
00:48:52,650 --> 00:48:55,226
So word chain and the dictionary.

608
00:49:00,777 --> 00:49:05,725
SP: The alternative is that you
keep the dictionary the same each time,

609
00:49:05,725 --> 00:49:10,240
but you don't allow the addition into
the chain of a word that's already in it.

610
00:49:11,310 --> 00:49:15,760
OC: Yes, but we're going to keep
searching through a word chain every time.

611
00:49:15,770 --> 00:49:17,946
it feels like we just
make the dictionary smaller

612
00:49:17,946 --> 00:49:20,910
then our neighbors
gradually become smaller.

613
00:49:21,000 --> 00:49:24,373
So we return the list of
possible word chains as before.

614
00:49:27,940 --> 00:49:31,280
Now I'm thinking
it would be nice if we had

615
00:49:31,280 --> 00:49:33,053
a richer type for our dictionary.

616
00:49:33,053 --> 00:49:36,413
Like a set or something like
that, so I can do a set difference

617
00:49:36,413 --> 00:49:39,306
and easily remove a set of words from it.

618
00:49:39,306 --> 00:49:40,306
SP: Yes.

619
00:49:41,346 --> 00:49:43,426
OC: So that's going to be
a bit of a backtrace

620
00:49:43,426 --> 00:49:45,226
but I think it's going to be worth it.

621
00:49:45,333 --> 00:49:51,960
so I'm going to import
the Data.Set library as well

622
00:49:54,080 --> 00:49:57,040
and that also works best
when you import qualified.

623
00:50:00,973 --> 00:50:03,946
We need to depend on
the containers library for that.

624
00:50:06,400 --> 00:50:08,946
And to get that
I need to put that in there.

625
00:50:11,110 --> 00:50:13,893
Actually, it looks as if
we already have that.

626
00:50:17,120 --> 00:50:18,786
Bit of a misnomer there I reckon.

627
00:50:21,588 --> 00:50:28,100
So now that we've got set
imported maybe we can make this...

628
00:50:28,320 --> 00:50:33,371
So rather than having a list
of text, let's go with a set text.

629
00:50:33,610 --> 00:50:38,891
And we'll just ask the compiler to tell us
everything we need to update, to change.

630
00:50:40,746 --> 00:50:43,260
The first thing we need to do
is return a set rather than a list.

631
00:50:43,260 --> 00:50:48,160
That's easy enough,
we can just say S.fromList.

632
00:50:48,680 --> 00:50:50,820
which takes a list
and turns it into a set.

633
00:50:51,893 --> 00:50:57,373
Next, rather than checking
a list to see if an element's there,

634
00:50:57,420 --> 00:51:04,468
use S.member, which checks to see
if an element is a member of a set.

635
00:51:05,573 --> 00:51:07,600
Likewise going to do the same here...

636
00:51:17,640 --> 00:51:22,194
That has put a hole back there,
we'll come back to that.

637
00:51:22,205 --> 00:51:24,211
[Ollie types]

638
00:51:25,820 --> 00:51:31,960
That should probably just return.

639
00:51:34,866 --> 00:51:36,493
like that...

640
00:51:41,440 --> 00:51:47,106
The filter is for lists but we have
a set so we ask S.filter to filter a set.

641
00:51:56,240 --> 00:51:58,306
I'll check the type of that in there.

642
00:52:05,370 --> 00:52:08,533
OK, I've some idea
of where that error came up.

643
00:52:10,800 --> 00:52:15,920
Ah yes, we can't map over a set like that.

644
00:52:17,813 --> 00:52:23,813
Do we have that... yes we do...
so we just change that to S.map

645
00:52:24,866 --> 00:52:29,510
and again to S.filter, S.map.

646
00:52:29,860 --> 00:52:33,828
Now this is not going to give us a list of
text, it's going to give us a set of text.

647
00:52:39,880 --> 00:52:46,893
SP: There are built in facilities
like traversible.

648
00:52:47,826 --> 00:52:49,866
Does that help with
this sort of code

649
00:52:49,866 --> 00:52:53,346
where you change
from one data type to another?

650
00:52:53,771 --> 00:52:57,474
There are some generalized forms
of some of these functions aren't there?

651
00:52:57,540 --> 00:53:01,908
OC: Right. We can't generalize map
I don't think because this is a set.

652
00:53:01,908 --> 00:53:05,862
and sets have the constraint that the
things inside the set must be order-able.

653
00:53:05,906 --> 00:53:06,200
SP: Ok

654
00:53:06,213 --> 00:53:08,480
OC: So we can't map between
our 3 types because

655
00:53:08,493 --> 00:53:10,840
we wouldn't necessarily
map them to something that's order-able.

656
00:53:10,850 --> 00:53:15,906
For filter, there's probably
some stuff in Data.Foldable

657
00:53:15,906 --> 00:53:18,026
that will probably let us filter the set.

658
00:53:18,546 --> 00:53:22,933
But I think I'm quite happy being explicit
that we're working with sets here.

659
00:53:22,933 --> 00:53:23,626
SP: That's fine.

660
00:53:23,710 --> 00:53:27,131
OC: I don't think generalizing would
give us much of a benefit here.

661
00:53:27,170 --> 00:53:31,093
SP: Why I was wondering
is because I like to use that myself.

662
00:53:33,440 --> 00:53:38,280
OC: Now we may not be able to
use the list comprehension anymore.

663
00:53:38,280 --> 00:53:39,160
because we certainly don't have the list.

664
00:53:39,170 --> 00:53:42,466
what we could do
though is just go to a list.

665
00:53:44,770 --> 00:53:47,680
We could turn this into a list.

666
00:53:47,680 --> 00:53:50,605
[Ollie types]

667
00:53:52,194 --> 00:53:54,500
OK, and now we're back to
trying to solve this.

668
00:53:55,417 --> 00:53:58,662
To recap where we were, we wanted to have
the dictionary become smaller and smaller.

669
00:54:00,220 --> 00:54:03,497
So we return the word chain and
now we need to return the dictionary.

670
00:54:04,480 --> 00:54:08,091
but without a set of words
that we've already considered.

671
00:54:09,300 --> 00:54:16,022
I believe those are going to be the
head of chains that we just expanded to,

672
00:54:16,022 --> 00:54:18,410
So that will be all the neighbors again.

673
00:54:19,570 --> 00:54:25,462
Although maybe it's more
beneficial to bring more neighbors out

674
00:54:25,462 --> 00:54:26,697
as a separate binding.

675
00:54:33,680 --> 00:54:36,702
So now we can take the
dictionary without any of the neighbors.

676
00:54:36,702 --> 00:54:39,020
I've got a slightly smaller
dictionary now.

677
00:54:39,330 --> 00:54:40,748
And that still type checks.

678
00:54:45,794 --> 00:54:47,257
We certainly want to call expand.

679
00:54:47,250 --> 00:54:49,211
We need to work out what
were going to do with that result.

680
00:54:49,360 --> 00:54:51,942
We have to write a
function that's going to take

681
00:54:51,942 --> 00:54:53,770
a list of word chains in the dictionary,

682
00:54:53,771 --> 00:54:55,708
and eventually gets to a word chain.

683
00:54:59,371 --> 00:55:04,840
I think we'll end up using some functions
that are already in prelude anyway.

684
00:55:04,840 --> 00:55:08,525
But let's just follow the types
manually, and see what we end up with.

685
00:55:09,194 --> 00:55:11,491
OC: We have some function
f that's going to take a chain...

686
00:55:11,491 --> 00:55:14,910
and a new dictionary
and it needs to do something,

687
00:55:16,850 --> 00:55:18,325
and call f there as well.

688
00:55:22,725 --> 00:55:26,102
Now we want to expand
every single one of these chains

689
00:55:26,102 --> 00:55:27,680
using the smaller dictionary.

690
00:55:30,200 --> 00:55:33,480
So do something with chain
and chain is of course not...

691
00:55:34,060 --> 00:55:36,920
These type holes
aren't really helping us anymore

692
00:55:37,030 --> 00:55:39,240
We just have to trust
our intuition a bit more.

693
00:55:39,450 --> 00:55:41,622
But I should be able to map expand.

694
00:55:48,782 --> 00:55:50,725
I should bring this down a little bit.

695
00:55:54,920 --> 00:55:57,280
Expand takes the dictionary
in first position,

696
00:55:57,285 --> 00:55:59,800
and a word chain to expand second,

697
00:56:00,142 --> 00:56:02,102
so that's going to work quite nicely.

698
00:56:03,068 --> 00:56:04,668
Apart from Application.

699
00:56:05,382 --> 00:56:07,691
So that was a list of chains.

700
00:56:07,690 --> 00:56:08,354
(Silence).

701
00:56:16,085 --> 00:56:18,154
We're going in the right direction there.

702
00:56:20,217 --> 00:56:23,205
We need to go from
a list of a list of word chains.

703
00:56:23,794 --> 00:56:26,537
to probably a single word chain.

704
00:56:27,880 --> 00:56:30,628
So, expanded every chain.

705
00:56:32,085 --> 00:56:34,348
I'm going to have to call F on that again.

706
00:56:42,994 --> 00:56:45,960
So, I think we're
struggling to find a nice kind of way

707
00:56:45,960 --> 00:56:48,320
to repeatedly apply this expand function,

708
00:56:49,010 --> 00:56:50,325
and what comes to mind here is,

709
00:56:50,325 --> 00:56:54,177
it looks like an unfold
which is like the dual to fold,

710
00:56:54,171 --> 00:56:55,382
which a lot of people are familiar with.

711
00:56:55,382 --> 00:56:56,668
When you fold you have a list

712
00:56:56,660 --> 00:56:59,051
and you keep reducing it
into something smaller.

713
00:56:59,125 --> 00:57:01,971
Whereas in this case we actually have
something and want to get something bigger.

714
00:57:02,045 --> 00:57:05,400
Which as unfolding until the point
where we maybe can't go any bigger.

715
00:57:06,200 --> 00:57:12,331
So we have a function in
the Prelude to do that which is unfoldr.

716
00:57:14,290 --> 00:57:16,897
But that requires for
this function that we have

717
00:57:16,891 --> 00:57:18,971
something that returns Maybe any value.

718
00:57:19,228 --> 00:57:21,514
OC: But this actually looks quite a lot

719
00:57:21,514 --> 00:57:23,285
like what we have in expand here.

720
00:57:23,565 --> 00:57:25,182
OC: But we don't have a Maybe here,

721
00:57:25,750 --> 00:57:29,131
So the Maybe represents the fact
that you can't actually go any bigger.

722
00:57:29,417 --> 00:57:32,434
which is what we were
modeling here with this pattern match,

723
00:57:32,691 --> 00:57:35,480
where we simply said
we have an empty list of word chains,

724
00:57:35,485 --> 00:57:37,650
but that felt a bit weird,

725
00:57:37,840 --> 00:57:40,971
so maybe let's try
bringing in a Maybe there.

726
00:57:42,200 --> 00:57:44,171
SP: Maybe let's Maybe (laughter).

727
00:57:45,540 --> 00:57:51,405
OC: OK, so in this case there's
nothing we can do, so we just say nothing.

728
00:57:51,420 --> 00:57:56,834
Whereas in this case, we have
just that result of word chains.

729
00:57:57,691 --> 00:57:59,850
NARRATOR: We're going to speed through
this section

730
00:57:59,850 --> 00:58:03,234
because Ollie and Steve found
themselves deep into a Rabbit hole.

731
00:58:03,860 --> 00:58:07,280
They eventually backtracked
on this idea of using unfoldr,

732
00:58:07,890 --> 00:58:11,120
So let's skip ahead to the
section where they changed course.

733
00:58:14,740 --> 00:58:17,725
SP: You are typing faster
than I can think (laughter).

734
00:58:18,370 --> 00:58:20,422
OC: Even though we're using unfold,

735
00:58:20,422 --> 00:58:23,542
which does feel
like the right tool to be using

736
00:58:23,540 --> 00:58:26,388
I think we're getting
ourselves into a bit of a muddle here.

737
00:58:26,380 --> 00:58:30,240
And one of the big culprits is what
we're doing in this expand function.

738
00:58:30,302 --> 00:58:32,171
so I'm going to try and simplify that

739
00:58:32,170 --> 00:58:34,834
and see if a nice
solution comes out there.

740
00:58:35,417 --> 00:58:36,891
What I'm going to go with instead...

741
00:58:38,160 --> 00:58:41,577
expand's going to take a single
word chain and the dictionary,

742
00:58:42,100 --> 00:58:44,365
and it's going to expand that to a list

743
00:58:44,360 --> 00:58:47,640
of possible word
chains and smaller dictionaries.

744
00:58:48,160 --> 00:58:48,531
SP:OK

745
00:58:48,540 --> 00:58:50,400
OC: So whenever I make one expansion,

746
00:58:50,400 --> 00:58:54,720
I consider all of the neighbors
around the first word of the word chain.

747
00:58:54,760 --> 00:58:56,582
And for each of those new word chains,

748
00:58:56,582 --> 00:58:58,080
I'll have the neighbor at the front.

749
00:58:58,080 --> 00:59:00,062
And we will remove
that word from the dictionary,

750
00:59:00,080 --> 00:59:02,354
because we don't want
to go back on ourselves.

751
00:59:03,730 --> 00:59:07,737
So I have a word chain with
nothing in but there's nothing I can do.

752
00:59:08,560 --> 00:59:10,457
We have seen this one before,

753
00:59:10,490 --> 00:59:15,154
but otherwise if we have a chain,
and it starts with the word w,

754
00:59:15,150 --> 00:59:24,777
We have the dictionary and then
we need to take the neighbors around w,

755
00:59:24,780 --> 00:59:28,000
which will equal n...
and put that on the front of the chain.

756
00:59:28,030 --> 00:59:36,194
So n is going to be the neighbors
using the same dictionary around w.

757
00:59:37,820 --> 00:59:41,045
But we also need to return
this slightly smaller dictionary.

758
00:59:43,740 --> 00:59:50,240
Tuple that up with the same dictionary,
whoops.

759
00:59:52,485 --> 00:59:54,540
But we'll delete n from the dictionary.

760
00:59:54,720 --> 00:59:55,388
SP: Right.

761
00:59:56,417 --> 00:59:57,874
OC: Lets try that...

762
00:59:59,902 --> 01:00:01,451
Get rid of our old definition.

763
01:00:02,710 --> 01:00:05,794
You can see this is very similar to
what we had in expandOne.

764
01:00:05,880 --> 01:00:08,114
So breaking the problem
into a smaller one.

765
01:00:08,110 --> 01:00:13,234
[Ollie types]

766
01:00:13,697 --> 01:00:15,194
So ignore this.

767
01:00:15,840 --> 01:00:19,542
Let's keep that.

768
01:00:22,050 --> 01:00:24,910
And that's expecting a list
of text from the other set.

769
01:00:24,910 --> 01:00:27,154
So we need to turn that into a list.

770
01:00:27,150 --> 01:00:36,331
[Ollie types]

771
01:00:36,570 --> 01:00:38,080
We're back - good!

772
01:00:38,080 --> 01:00:41,531
[Silence]

773
01:00:41,720 --> 01:00:49,531
I guess if we load the dictionary in
then we should be able to use expand with...

774
01:00:49,828 --> 01:00:52,811
Let's just look at the one
expansion of cat.

775
01:00:53,028 --> 01:00:54,810
Oops... Oh!

776
01:00:54,862 --> 01:00:55,880
So what we're doing here is

777
01:00:55,880 --> 01:00:58,080
we end up printing the
out dictionary as well.

778
01:00:58,085 --> 01:01:00,114
SP: Yes, because it was in the Tuple.

779
01:01:02,005 --> 01:01:03,222
OC: Map first over that,

780
01:01:06,571 --> 01:01:08,777
and we see just the one level expansion.

781
01:01:08,771 --> 01:01:10,382
SP: Fantastic.

782
01:01:10,850 --> 01:01:15,668
OC: So we're going to repeatedly
apply this, but keeping the small chains.

783
01:01:15,731 --> 01:01:17,850
Then we will have the
bigger chains on the end.

784
01:01:17,850 --> 01:01:22,365
So that's basically giving us a flattening
of a tree, of a breadth-first search.

785
01:01:22,770 --> 01:01:28,148
Which I think is going to be better than
the depth-first search we saw earlier.

786
01:01:28,142 --> 01:01:28,650
SP:  Yes.

787
01:01:30,680 --> 01:01:34,897
I'm going to do a little
function up here called go.

788
01:01:38,620 --> 01:01:44,371
Go is going to take a list
of word chains and dictionaries.

789
01:01:46,810 --> 01:01:51,462
And this becomes apparent... you can see
how I'm going to pull recursively.

790
01:01:51,480 --> 01:01:54,685
And it's going to give us back a
list of word chains and dictionaries.

791
01:01:54,685 --> 01:01:57,880
and that's going to let us
repeatedly apply this to ourselves.

792
01:01:57,880 --> 01:02:00,491
So if we have nothing in the first list

793
01:02:00,770 --> 01:02:03,220
There's nothing we can do,
we simply return that.

794
01:02:03,925 --> 01:02:08,308
Otherwise we have some
chains so what we can do...

795
01:02:08,690 --> 01:02:11,257
SP: We have some
combinations of chains and dictionaries.

796
01:02:11,302 --> 01:02:12,994
OC: Yes, some chains and
dictionaries indeed.

797
01:02:12,994 --> 01:02:14,634
But for every word chain
in the dictionary,

798
01:02:14,630 --> 01:02:17,885
we want to expand that
word chain using its own dictionary.

799
01:02:17,880 --> 01:02:19,450
So I'm going to map over chains,

800
01:02:21,240 --> 01:02:24,160
and what we'll have here
is a word chain and a dictionary,

801
01:02:24,171 --> 01:02:28,114
which we will expand in a chain
and a dictionary.

802
01:02:28,160 --> 01:02:30,570
We're going to have to concat
like that because

803
01:02:30,570 --> 01:02:33,508
expand gives us a list
of word chains and dictionaries.

804
01:02:35,794 --> 01:02:37,474
SP: Can we rename chains there?

805
01:02:38,468 --> 01:02:41,660
OC: Sure, anything you're up to,
a tad smaller

806
01:02:42,000 --> 01:02:46,834
or did you want to drop it entirely?
Because we could just...

807
01:02:47,250 --> 01:02:50,594
No, we cant because we've
pattern matched on one here.

808
01:02:50,660 --> 01:02:51,828
SP: Maybe in pairs.

809
01:02:51,828 --> 01:02:53,810
OC: OK, because of the dictionary.

810
01:02:53,810 --> 01:03:10,680
[Ollie types]

811
01:03:11,770 --> 01:03:13,485
So that's OK...

812
01:03:13,490 --> 01:03:17,725
But what we've done now is, we've
thrown away these original chains.

813
01:03:17,740 --> 01:03:19,325
We need to retain those as well.

814
01:03:19,320 --> 01:03:20,525
SP: Right.

815
01:03:25,110 --> 01:03:30,400
OC: So we'll keep the pairs, and
then add on the expansions afterwards.

816
01:03:30,422 --> 01:03:30,845
SP: Yes.

817
01:03:30,857 --> 01:03:33,451
So for the smaller chains
that might have already finished,

818
01:03:33,462 --> 01:03:35,314
we'll keep those.

819
01:03:35,360 --> 01:03:37,811
SP: And then later you
would look at all the chains

820
01:03:37,817 --> 01:03:39,862
starting with the smallest first,

821
01:03:42,765 --> 01:03:46,457
and try to select only the ones
that finish on the target word.

822
01:03:46,480 --> 01:03:47,222
OC: Right.

823
01:03:47,222 --> 01:03:51,645
And because in expand we're putting
neighbors at the front of the list,

824
01:03:51,660 --> 01:03:55,920
we're going to need to filter
word chains that start with our target.

825
01:03:56,010 --> 01:04:00,971
It's a bit weird but obviously cons
is a lot more efficient than append.

826
01:04:01,000 --> 01:04:03,302
Because we don't have to traverse
the list at all.

827
01:04:03,331 --> 01:04:05,200
SP: We can always reverse the solution.

828
01:04:05,200 --> 01:04:06,834
OC: We could yes.

829
01:04:08,880 --> 01:04:12,228
I'll just check that
that's all compiling, it does.

830
01:04:12,380 --> 01:04:15,588
We should be able to have
a play with this now in our GHCi.

831
01:04:15,820 --> 01:04:21,862
So we've got go so I'll try to
bring the dictionary back into scope.

832
01:04:24,308 --> 01:04:26,874
Word chains plus words, so I'll try cat.

833
01:04:26,870 --> 01:04:30,297
[Ollie thinks]

834
01:04:30,491 --> 01:04:32,714
And it needs a dictionary
in there as well.

835
01:04:35,280 --> 01:04:37,080
And we'll start with just that one.

836
01:04:37,410 --> 01:04:42,028
And that's going to expand forever,
so lets go one level into it with go

837
01:04:42,140 --> 01:04:42,485
SP: OK.

838
01:04:42,491 --> 01:04:43,908
OC: And take the head of that.

839
01:04:45,260 --> 01:04:49,748
There's a lot of possibilities...
Because of the dictionary.

840
01:04:52,508 --> 01:04:54,777
We'll just take the word chains
out of that.

841
01:04:54,770 --> 01:04:59,050
SP: Just the first of head
OC: Oh yes, thanks.

842
01:05:02,914 --> 01:05:05,131
OC: So maybe,... rather than the head

843
01:05:05,245 --> 01:05:08,510
SP: Now it's map first.
OC: Oh yes.

844
01:05:09,390 --> 01:05:12,948
OC: So every time we take one
more our chains get a bit longer.

845
01:05:12,970 --> 01:05:15,291
SP: Can you see the next one?

846
01:05:16,540 --> 01:05:20,080
Oh! that's because we've flattened it, yes.

847
01:05:20,171 --> 01:05:23,657
SP: That's not the level
that's just the chains as they change.

848
01:05:23,691 --> 01:05:24,320
OC: Yes.

849
01:05:25,428 --> 01:05:27,250
SP: How about the first ten?n\OC: Yes.

850
01:05:27,250 --> 01:05:30,114
[Silence]

851
01:05:30,680 --> 01:05:34,731
OC: So gradually they're going
to start getting bigger at some point.

852
01:05:35,540 --> 01:05:37,440
Let's take 50.

853
01:05:37,440 --> 01:05:44,240
[Silence]

854
01:05:44,628 --> 01:05:47,131
We seem to be, perhaps, not recursing?

855
01:05:47,160 --> 01:05:50,457
Actually go is never calling
itself, which is the problem here.

856
01:05:50,554 --> 01:05:53,554
So were only ever looking at one level expansion.

857
01:05:55,120 --> 01:06:03,085
So if we take the original pairs and what
we need to do is go again on the concatMap.

858
01:06:03,080 --> 01:06:04,640
SP: Right.

859
01:06:04,680 --> 01:06:07,474
So we're going to keep
going to bigger and bigger chains.

860
01:06:07,470 --> 01:06:10,697
But we're always putting
these chains on the end of the list.

861
01:06:18,880 --> 01:06:23,348
So if we go back to taking 20,
we should be back to where we were.

862
01:06:23,400 --> 01:06:28,468
And as I take more, you can see we
are starting to get bigger and bigger chains now.

863
01:06:28,480 --> 01:06:31,760
SP: Right, and all of them ending on cat.

864
01:06:31,850 --> 01:06:34,982
OC: Yes, all ending on cat.

865
01:06:35,022 --> 01:06:36,891
SP: That's because that was our start.

866
01:06:36,900 --> 01:06:39,485
OC: Yes, were going out from cat.

867
01:06:39,480 --> 01:06:43,000
SP: Suffering from the reverse order of reading.

868
01:06:44,850 --> 01:06:51,154
OC: So now were ready to put this back into the
wordPuzzle to solve the puzzle properly... again!

869
01:06:51,234 --> 01:06:58,400
So we need to call go and we're
going to be using the input-dictionary.

870
01:06:58,770 --> 01:07:03,131
But were going to have to delete
our starting word from the dictionary.

871
01:07:03,131 --> 01:07:05,890
OC: Because we don't want to go back to the start.

872
01:07:05,900 --> 01:07:09,965
And we're going to start with
a word chain that begins at the word a.

873
01:07:11,580 --> 01:07:14,514
And this is going to give us
all the chains that start from a.

874
01:07:14,510 --> 01:07:18,354
But we're interested in chains
that start at a and finish at b.

875
01:07:18,377 --> 01:07:25,620
So we filter the result of
chains by  taking, for each chain...

876
01:07:26,251 --> 01:07:31,080
Sorry, first we should just
throw away the extra dictionaries.

877
01:07:31,302 --> 01:07:33,897
SP: Because the tuples will come back from go.

878
01:07:33,890 --> 01:07:37,394
OC: Yes, so go will give us a tuple
of word chains and dictionaries.

879
01:07:37,410 --> 01:07:39,782
Whereas we're only interested in word chains.

880
01:07:39,805 --> 01:07:42,080
So I'm mapping first over those.

881
01:07:42,200 --> 01:07:44,022
Now we've got a list of word chains.

882
01:07:44,080 --> 01:07:53,817
I can filter the list for ones whose first
element is equal to our target end element.

883
01:07:54,020 --> 01:07:58,194
And I think that's all we need
to solve the puzzle.

884
01:07:58,582 --> 01:08:00,490
So that all compiles.

885
01:08:02,090 --> 01:08:05,782
and now if I Read the dictionary back in...

886
01:08:06,380 --> 01:08:11,440
I can do a wordPuzzle using
the dictionary and we'll go from dog to cat.

887
01:08:15,742 --> 01:08:17,502
And we are indeed getting result.

888
01:08:19,000 --> 01:08:23,965
The interesting thing we're seeing
here is as it's gradually printing results,

889
01:08:23,970 --> 01:08:27,828
we are seeing Haskells' lazy
evaluation works to our advantage.

890
01:08:27,850 --> 01:08:33,257
So if I only wanted to get the very first result,
I could simply take the head of all the solutions

891
01:08:33,500 --> 01:08:37,725
And the result is already done, it didn't
bother computing all the extra values.

892
01:08:37,760 --> 01:08:43,622
But if I needed the extra results, maybe if
I wanted to find the first ten shortest chains.

893
01:08:43,630 --> 01:08:49,611
I could just take10 and that's going to
give you 10 word chains and then terminate,

894
01:08:49,674 --> 01:08:50,868
which is really nice.

895
01:08:52,730 --> 01:08:59,691
OC: I think that solves the problem
that we had in the original problem spec.

896
01:08:59,910 --> 01:09:02,097
SP: Shall we try it on longer input?

897
01:09:02,400 --> 01:09:05,771
How about the words Ruby and Code.

898
01:09:05,980 --> 01:09:08,902
OC: OK so I'll take the first of those.

899
01:09:08,900 --> 01:09:24,228
[Ollie types and then thinks]

900
01:09:24,240 --> 01:09:28,525
It's certainly a lot slower but
we do get a word chain in the end.

901
01:09:32,050 --> 01:09:36,034
So it might be worth trying
to improve the forms of this next.

902
01:09:36,050 --> 01:09:41,908
SP: Absolutely, and there are longer
examples such as from house to shout.

903
01:09:42,110 --> 01:09:46,308
We could see if that completes
in a reasonable amount of time.

904
01:09:47,000 --> 01:09:52,811
This one's quite tricky, the search space for it
is quite large in the dictionary that I've given you.

905
01:09:53,800 --> 01:09:57,462
OC: This doesn't look like
it's terminating any time soon.

906
01:09:58,270 --> 01:10:04,342
SP: Maybe we can have a look and see
if we can determine where the bottleneck is?

907
01:10:04,650 --> 01:10:08,960
OC: Yes, well I'm going to leave that one running
in the background anyway, and see if we get a result,

908
01:10:08,971 --> 01:10:11,310
while we start looking for some optimizations.

909
01:10:11,310 --> 01:10:16,822
To me, the biggest source of expense
feels like this neighbors function.

910
01:10:16,902 --> 01:10:20,620
We're filtering twice and we map twice.

911
01:10:20,630 --> 01:10:23,840
And we are doing this
repeatedly every single time we expand.

912
01:10:23,870 --> 01:10:28,697
And the set of neighbors
around a word doesn't really change.

913
01:10:28,720 --> 01:10:33,257
There may be potential neighbors that we can't
consider because we've already looked at them once.

914
01:10:33,268 --> 01:10:35,370
And we would go back on ourselves.

915
01:10:36,565 --> 01:10:39,657
But we can probably prune
the set of neighbors afterwards.

916
01:10:39,650 --> 01:10:45,485
I'm thinking maybe we can have an
optimization where we have a map of neighbors.

917
01:10:48,800 --> 01:10:55,222
It's going to be a map
from Text to its set of neighbors.

918
01:10:55,280 --> 01:10:59,222
And we should be able to
pre-compute this against the dictionary.

919
01:10:59,340 --> 01:11:06,342
We're going to need the
Map data type which comes from Data.Map.

920
01:11:06,777 --> 01:11:10,537
Again I'll be importing this from qualified.

921
01:11:15,520 --> 01:11:20,342
Now we look up the list of neighbors.

922
01:11:21,891 --> 01:11:24,131
We can still take the Dictionary as input,

923
01:11:24,130 --> 01:11:29,302
but rather than just taking that,
we can also take in a NeighbourMap.

924
01:11:29,460 --> 01:11:33,108
And the word to look up...
and it's going to give us a set of neighbors again.

925
01:11:33,360 --> 01:11:37,531
And the reason I'm taking the dictionary is
because we keep making that dictionary smaller.

926
01:11:37,542 --> 01:11:43,200
We want to make sure the neighbors we look
up from this map are actually in the dictionary.

927
01:11:43,210 --> 01:11:46,571
because we might have made the dictionary
smaller and removed possible neighbors.

928
01:11:46,571 --> 01:11:48,700
So we're going to filter those out.

929
01:11:48,700 --> 01:11:54,217
So I'll call that m and w...
and this becomes straightforward.

930
01:11:54,217 --> 01:12:01,080
We simply do a map look-up
which is the exclamation operator,

931
01:12:01,110 --> 01:12:04,834
which will throw up an error
if the word isn't in the map.

932
01:12:04,880 --> 01:12:08,400
But we'll have to gloss over that for now I guess.

933
01:12:08,420 --> 01:12:10,160
SP: Avoiding the Maybes.

934
01:12:10,200 --> 01:12:14,285
OC: Yes, if I was doing this in production
code I would probably want to keep the Maybes,

935
01:12:14,290 --> 01:12:18,525
and the chance of it possibly failing,
and reflect that in the types better.

936
01:12:18,540 --> 01:12:22,491
But for our purposes this should be sufficient.

937
01:12:22,502 --> 01:12:27,097
So, this is saying in the map M, look up the word w.

938
01:12:28,720 --> 01:12:33,965
We need to take the intersection
of the set of possible neighbors.

939
01:12:33,960 --> 01:12:36,800
[Ollie types]

940
01:12:37,170 --> 01:12:40,971
We take the set intersection...

941
01:12:41,268 --> 01:12:44,171
SP: Is it bang or double-bang for
the lookup operator? I can't remember.

942
01:12:44,205 --> 01:12:47,165
OC: From map I believe it's
just a single exclamation mark,

943
01:12:47,160 --> 01:12:49,520
whereas for lists it's two exclamation marks.

944
01:12:49,520 --> 01:12:55,577
[Ollie types]

945
01:12:55,850 --> 01:13:00,000
So we don't seem to have any
compile errors around this neighbors function.

946
01:13:00,680 --> 01:13:02,434
That's quite straightforward.

947
01:13:02,440 --> 01:13:05,440
We also need a way to precomputeNeighbours.

948
01:13:06,980 --> 01:13:12,034
So that takes the dictionary
and turns it into a NeighbourMap.

949
01:13:12,770 --> 01:13:18,628
SP: So here your starting from saying; from
right down in the lowest level of this computation

950
01:13:18,628 --> 01:13:23,097
you would like to have that extra
information available in that NeighbourMap

951
01:13:23,100 --> 01:13:29,405
and you're working your way back up to the
calling levels to see how to pass that down into it.

952
01:13:29,400 --> 01:13:36,377
OC: Yes. We've got a neighbours function.
I would like to be able to test that in GHCi.

953
01:13:36,620 --> 01:13:38,857
But we don't have a way to build a NeighbourMap yet.

954
01:13:38,860 --> 01:13:41,920
So I'm going to work on
this precomputeNeighbours function.

955
01:13:41,931 --> 01:13:45,588
Then I can have a test from GHCi
so I can actually see if the NeighbourMap

956
01:13:45,588 --> 01:13:47,222
seems to be working as we would expect.

957
01:13:47,260 --> 01:13:52,754
Then we can work through the rest of the compile
errors and thread in the proper code as we need to.

958
01:13:55,777 --> 01:13:57,902
So this looks like it should be straightforward.

959
01:13:57,900 --> 01:14:02,651
We just take our dictionary, which is a set of words.

960
01:14:02,660 --> 01:14:05,154
So if we go from set to list.

961
01:14:05,880 --> 01:14:11,188
And for every word in here we can map over the...

962
01:14:12,370 --> 01:14:17,120
Ah! We did need our original neighbours
function which I have thrown away now. [laughter]

963
01:14:17,160 --> 01:14:18,914
Because we want to use that.

964
01:14:19,740 --> 01:14:22,285
OC: So let's see if I can go back to that.

965
01:14:22,280 --> 01:14:26,114
[Ollie types]

966
01:14:26,450 --> 01:14:30,617
So I'll call this one...

967
01:14:31,920 --> 01:14:34,365
neighboursLookup.

968
01:14:34,360 --> 01:14:37,531
[Ollie types]

969
01:14:37,740 --> 01:14:42,022
And this is back to how it was.

970
01:14:42,020 --> 01:14:51,885
[Ollie types]

971
01:14:53,380 --> 01:14:58,331
SP: We could also call this neighbors
and have the old neighbors function

972
01:14:58,342 --> 01:15:06,057
simply be a function returning a list of
the words with the neighbors and distances.

973
01:15:06,388 --> 01:15:08,337
OC: In the neighbours function or...?

974
01:15:09,250 --> 01:15:15,714
SP: Yes, so you could - at this level
here where your returning W with distance.

975
01:15:18,810 --> 01:15:22,342
In order to avoid having
two similarly named functions.

976
01:15:22,348 --> 01:15:23,994
Maybe we should continue...

977
01:15:23,990 --> 01:15:27,177
OC: It's probably worth renaming this
though, because we want compile error.

978
01:15:27,190 --> 01:15:31,051
We're going to get compile errors
anyway because the types are different.

979
01:15:31,748 --> 01:15:33,611
I think I'm going to go...

980
01:15:34,160 --> 01:15:39,451
I'm going to move this into
precomputeNeighbours, as a where binding.

981
01:15:39,480 --> 01:15:44,445
Because we don't have any reason to ever
call this other than inside precomputeNeighbours.

982
01:15:44,440 --> 01:15:48,388
[Ollie types]

983
01:15:48,388 --> 01:15:50,662
SP: And it does mean you can rename the top level.

984
01:15:50,660 --> 01:15:52,182
OC: Exactly, yes.

985
01:15:53,542 --> 01:15:56,457
The dictionary is going
to be available up here anyway.

986
01:16:00,930 --> 01:16:10,022
We need to turn our dictionary into a
list of words and map neighbors over that.

987
01:16:12,668 --> 01:16:16,382
So I need to pair them up
with the original word as well.

988
01:16:17,982 --> 01:16:21,371
There's a fairly nice function
in the Control.Arrow module

989
01:16:22,710 --> 01:16:26,605
which lets us run two
functions on the same argument.

990
01:16:27,400 --> 01:16:33,428
I can say that id and neighbors: so that's
the identity function and the neighbors function.

991
01:16:33,428 --> 01:16:35,730
and it's going to tuple those up for me.

992
01:16:35,737 --> 01:16:36,280
SP: OK.

993
01:16:37,400 --> 01:16:39,840
OC: I think I'll just import that...

994
01:16:42,685 --> 01:16:45,634
Ah, we've got a lot of compile errors.

995
01:16:45,630 --> 01:16:54,902
[Ollie types]

996
01:16:54,900 --> 01:16:59,314
OK, this is an easy one to fix.

997
01:16:59,310 --> 01:17:08,914
[Ollie types]

998
01:17:11,908 --> 01:17:17,520
We apparently need the word A as well.

999
01:17:17,885 --> 01:17:19,131
What's that word a?

1000
01:17:19,130 --> 01:17:21,714
[Silence]

1001
01:17:21,737 --> 01:17:28,200
I think that's meant to be...
Oh, I must have originally called it A.

1002
01:17:31,540 --> 01:17:35,965
OC: So now we have precomputeNeighbours
but that's not returning the neighbors now.

1003
01:17:35,960 --> 01:17:41,782
[Ollie types]

1004
01:17:42,102 --> 01:17:43,851
We don't really need to keep dict...

1005
01:17:43,874 --> 01:17:47,340
Oh we do, because were using that in neighbors.

1006
01:17:48,910 --> 01:17:52,217
Now this is going to be a list of tuples.

1007
01:17:52,217 --> 01:17:56,250
We can turn that into a map
by going fromList

1008
01:17:58,537 --> 01:18:01,485
So we've turned our
dictionary into a list of text.

1009
01:18:01,780 --> 01:18:09,074
And for every text value we turn that
into the text word itself and its set of neighbors.

1010
01:18:09,370 --> 01:18:14,868
SP: And each word will be distinct so you
don't need to worry about combining entries.

1011
01:18:14,868 --> 01:18:15,977
OC: Yes.

1012
01:18:17,980 --> 01:18:19,988
OC: Let's see what we get from that...

1013
01:18:23,500 --> 01:18:28,148
Neighbors is going to be... neighboursLookup.

1014
01:18:29,490 --> 01:18:34,000
So that's... well, yes let's keep it as neighboursLookup.

1015
01:18:39,080 --> 01:18:44,137
OC: I'm just checking that's the only
compile error we've got, and it looks like it is,

1016
01:18:44,180 --> 01:18:46,800
So we've just got two arrows up here.

1017
01:18:46,820 --> 01:18:49,691
That means expand rather
than just take the dictionary.

1018
01:18:49,690 --> 01:18:52,868
This also need to take a NeighbourMap.

1019
01:18:52,860 --> 01:19:01,680
[Ollie types]

1020
01:19:02,537 --> 01:19:05,417
The order here is dictionary, NeighbourMap.

1021
01:19:05,410 --> 01:19:09,805
[Ollie types]

1022
01:19:10,640 --> 01:19:13,771
I just had a thought there... because we're
always passing these two things together,

1023
01:19:13,782 --> 01:19:16,685
maybe I should be combining these.

1024
01:19:16,700 --> 01:19:19,040
SP: I was having the same thought.

1025
01:19:19,060 --> 01:19:24,251
OC: So I think maybe our NeighbourMap could be
a data type containing the full pre-computed map,

1026
01:19:24,510 --> 01:19:27,240
but also a set of exclusions.

1027
01:19:27,240 --> 01:19:30,685
And every time we need to
drop something out of the NeighbourMap,

1028
01:19:30,708 --> 01:19:33,611
then we can probably do that quite efficiently.

1029
01:19:33,645 --> 01:19:36,182
Or we may not even need to carry
the dictionary around but we'll see.

1030
01:19:36,180 --> 01:19:41,954
I'll come back to that later, but
it certainly does feel suspect so far.

1031
01:19:42,800 --> 01:19:48,617
So I think I better put this the right
way round, it's dictionary and NeighbourMap.

1032
01:19:50,180 --> 01:19:52,742
This is the dictionary and NeighbourMap.

1033
01:19:59,740 --> 01:20:02,742
And now expand needs that NeighbourMap as well.

1034
01:20:05,131 --> 01:20:08,034
But interestingly, this
doesn't have to be added to go.

1035
01:20:08,030 --> 01:20:12,742
Because the NeighbourMap doesn't
ever change from what we've got so far.

1036
01:20:12,742 --> 01:20:15,245
So that's just a constant.

1037
01:20:15,240 --> 01:20:20,651
[Ollie types]

1038
01:20:20,925 --> 01:20:22,600
SP: You could underscore it in the first one.

1039
01:20:22,748 --> 01:20:23,988
OC: Indeed, yes.

1040
01:20:23,980 --> 01:20:28,125
[Ollie types]

1041
01:20:28,280 --> 01:20:32,320
And, we need to call that recursively.

1042
01:20:36,260 --> 01:20:38,754
And we need to pass it in here as well.

1043
01:20:39,028 --> 01:20:43,200
So here, I think I'll use another let binding.

1044
01:20:43,200 --> 01:20:58,811
[Ollie types]

1045
01:20:58,970 --> 01:21:03,137
So now our word puzzle should
be using this precomputed NeighbourMap.

1046
01:21:03,154 --> 01:21:03,937
SP: Right.

1047
01:21:04,091 --> 01:21:07,222
OC: And were using our more
efficient neighbors look-up function.

1048
01:21:07,230 --> 01:21:10,594
So hopefully... we are going to see some results.

1049
01:21:10,590 --> 01:21:15,931
Impressively its still trying to find solutions
between house and shout, on the old code.

1050
01:21:16,548 --> 01:21:19,880
So let's see what we get out of this.

1051
01:21:21,780 --> 01:21:27,862
We didn't really look at
seeing precomputeNeighbours work.

1052
01:21:28,502 --> 01:21:30,788
So let's have a quick look at that.

1053
01:21:30,780 --> 01:21:38,640
[Ollie types]

1054
01:21:38,720 --> 01:21:41,485
OK, so that certainly type checks.

1055
01:21:44,400 --> 01:21:47,188
Let's bind that to... something like that.

1056
01:21:47,420 --> 01:21:48,862
We can do nMap...

1057
01:21:48,860 --> 01:21:53,885
[Ollie types]

1058
01:21:54,440 --> 01:21:57,234
SP: Jellow and hells. (laughter).

1059
01:21:57,230 --> 01:22:01,782
OC: So precomputeNeighbours seems to be working.
We seem to be getting some actual neighbors.

1060
01:22:01,782 --> 01:22:06,274
So let's do ruby and code again.

1061
01:22:08,940 --> 01:22:12,022
It doesn't seem to be a huge amount more efficient.

1062
01:22:14,428 --> 01:22:17,142
But maybe we'll actually
get a result from this now.

1063
01:22:17,140 --> 01:22:23,862
[Silence]

1064
01:22:24,400 --> 01:22:26,640
We've still got a little bit to go.

1065
01:22:30,000 --> 01:22:34,125
SP: Does it take long to pre-compute the entire map?

1066
01:22:34,220 --> 01:22:36,480
Can you force that computation and see?

1067
01:22:36,594 --> 01:22:40,022
OC: We can try forcing that and see what happens.

1068
01:22:42,030 --> 01:22:47,257
SP: And here your going to be precomputing
the neighbors across the full dictionary.

1069
01:22:47,280 --> 01:22:53,200
Not necessarily the dictionary pruned down
to only the words of the length we're interested in.

1070
01:22:53,570 --> 01:22:57,680
OC: Yes that's probably worth doing already.

1071
01:22:57,700 --> 01:23:00,897
Rather than precomputing
the dictionary of everything.

1072
01:23:00,902 --> 01:23:04,160
We're using a lazy map
here which means that

1073
01:23:05,850 --> 01:23:09,474
we'll get a map back that
contains all of the words as keys.

1074
01:23:09,782 --> 01:23:13,177
but the values underneath
that map won't be fully evaluated.

1075
01:23:13,200 --> 01:23:17,600
So it's only when we look up those
keys in the map that we will do that work.

1076
01:23:17,620 --> 01:23:21,760
So hopefully having the full dictionary
in there doesn't make any difference.

1077
01:23:21,770 --> 01:23:36,708
But I think for clarity that's slightly nicer
if we just say filter, length, equal to length of A.

1078
01:23:36,980 --> 01:23:40,194
SP: Of course, this way your run length across...

1079
01:23:40,582 --> 01:23:42,525
is it hundreds of thousands of words?

1080
01:23:42,570 --> 01:23:44,034
OC: Yes.

1081
01:23:44,034 --> 01:23:46,457
SP: So its a tradeoff.

1082
01:23:46,450 --> 01:24:06,137
[Ollie types]

1083
01:24:06,540 --> 01:24:08,194
OC. So we take the length...

1084
01:24:08,190 --> 01:24:11,977
[Ollie types]

1085
01:24:12,230 --> 01:24:15,405
I think that's because we have text values here.

1086
01:24:16,468 --> 01:24:19,737
We've already seen this
type of function before anyway.

1087
01:24:22,520 --> 01:24:26,640
We still have it down here.
Maybe we could do something with that.

1088
01:24:29,020 --> 01:24:34,102
Maybe neighbors now doesn't have to
worry about that, we've already done that once.

1089
01:24:34,100 --> 01:24:38,502
I think I'll just leave that duplication
for now, and see if that has made a difference.

1090
01:24:38,500 --> 01:24:43,920
[Ollie types]

1091
01:24:44,770 --> 01:24:48,491
It seems a bit snappier doesn't it?
SP: Yes

1092
01:24:49,600 --> 01:24:51,942
SP: So the acid test. (laughter).

1093
01:24:55,970 --> 01:25:00,182
There's still no results between house and shout.

1094
01:25:03,800 --> 01:25:09,211
SP: So that's great, we've reached a point now
were we're able to find chains quite efficiently.

1095
01:25:09,320 --> 01:25:15,066
Not just from cat to dog
but also from ruby to code.

1096
01:25:15,370 --> 01:25:19,451
SP: Where do you think
you would go next with this?

1097
01:25:20,410 --> 01:25:28,285
OC: One thing that's always been
sticking with me quite a bit is... in go we are using ++,

1098
01:25:28,680 --> 01:25:33,908
which means that because were
always having to put things on the end of the list.

1099
01:25:33,930 --> 01:25:36,857
We're always have to walk
through the start of the list to get to the end.

1100
01:25:36,868 --> 01:25:38,730
And we're having to do that repeatedly.

1101
01:25:38,742 --> 01:25:42,971
There's a couple of well known ways
we can go about optimising that at Haskell.

1102
01:25:43,070 --> 01:25:45,908
Difference lists are one possibility.

1103
01:25:45,940 --> 01:25:50,346
Which means that appending has much less of a cost,

1104
01:25:50,346 --> 01:25:53,720
provided we don't ever try
to inspect the front early on.

1105
01:25:53,730 --> 01:25:56,114
But we don't need to do that,
we only need to start inspecting

1106
01:25:56,114 --> 01:25:59,451
once we've built up this big
computation of all possible solutions,

1107
01:25:59,462 --> 01:26:01,885
and then we can start pulling things off the front.

1108
01:26:01,897 --> 01:26:04,280
So that could be an interesting optimization to see.

1109
01:26:04,280 --> 01:26:08,693
That maybe we'll be able to
allocate a bit less in the go function.

1110
01:26:08,693 --> 01:26:12,133
Beyond that I'd probably want
to look at doing some code profiling.

1111
01:26:12,130 --> 01:26:16,034
Try and work out if maybe
something is being hit a little too frequently.

1112
01:26:16,080 --> 01:26:19,453
And see if we can do something there.

1113
01:26:20,020 --> 01:26:24,731
Obvious strategies in any graph
search problem would be memoisation.

1114
01:26:26,050 --> 01:26:29,748
Which works really nicely at Haskell.
That wouldn't be too hard to add in.

1115
01:26:29,885 --> 01:26:33,457
It's just a case of working out
exactly what needs to be optimised.

1116
01:26:33,880 --> 01:26:35,497
And a couple of other things.

1117
01:26:35,508 --> 01:26:38,708
Just in terms of the feel of
this code, that I'd want to clean up.

1118
01:26:38,740 --> 01:26:43,360
As I pointed out earlier, the NeighbourMap
always has to be paired with the dictionary.

1119
01:26:43,380 --> 01:26:46,342
So forcing the user to pass the
dictionary and the NeighbourMap around,

1120
01:26:46,340 --> 01:26:51,485
felt a bit cumbersome, It would be nice if
we could work out some sort of abstraction there.

1121
01:26:51,880 --> 01:26:56,651
A NeighbourMap data type that
has an operation like look-up and remove.

1122
01:26:56,690 --> 01:27:02,674
SP: Or the dictionary itself is a more complex and opaque structure,

1123
01:27:02,685 --> 01:27:05,660
which can provide you with neighbors.

1124
01:27:05,666 --> 01:27:07,106
OC: Absolutely.

1125
01:27:07,100 --> 01:27:10,205
SP:  Because that's the only
operation we have on the [inaudible]

1126
01:27:10,228 --> 01:27:11,862
OC: Yes, it needs efficient look up

1127
01:27:11,862 --> 01:27:14,400
and efficient removal of
the things you've already seen.

1128
01:27:14,450 --> 01:27:17,840
Beyond that, we don't have any other requirements.

1129
01:27:17,970 --> 01:27:24,297
I think were moved it to a Set... we did yes.

1130
01:27:24,373 --> 01:27:27,893
So Set does have efficient look up and deletion.

1131
01:27:27,890 --> 01:27:33,977
But if we were able to combine that
with the pre-computed NeighbourMap,

1132
01:27:34,026 --> 01:27:36,466
we would probably get a much nicer API.

1133
01:27:36,466 --> 01:27:38,013
SP: And having worked through this,

1134
01:27:38,013 --> 01:27:42,600
the overall approach of using
lists to represent the word chains

1135
01:27:42,613 --> 01:27:46,080
and  expanding those lists.

1136
01:27:48,493 --> 01:27:51,040
Is that the approach you would use again?

1137
01:27:51,108 --> 01:27:54,030
OC: I think, now that we've
got more familiar with the problem,

1138
01:27:54,040 --> 01:27:57,405
and it's clear that it has this tree structure
and you're doing a breadth-first search.

1139
01:27:57,428 --> 01:28:00,685
It would have been nice to make
that explicit in the types themselves.

1140
01:28:00,720 --> 01:28:04,560
So use some sort of tree structure
to represent the branching out,

1141
01:28:04,640 --> 01:28:09,577
because I think a couple of times we've
confused ourselves with lists of lists of text,

1142
01:28:09,580 --> 01:28:11,222
when we actually wanted a list of texts,

1143
01:28:11,462 --> 01:28:15,770
and it was unclear how we actually
got from that nested list to a single list.

1144
01:28:16,194 --> 01:28:20,880
Was concat the right operation to be
using or have we made a mistake somewhere else.

1145
01:28:20,880 --> 01:28:22,970
So we didn't really lean on the types there.

1146
01:28:22,980 --> 01:28:27,097
It would have  been nice if we could have
taken more advantage from the type system.

1147
01:28:27,110 --> 01:28:28,845
I think if I were to do it again,

1148
01:28:30,660 --> 01:28:34,045
I would choose a slightly better data
structure for word chains in the first place.

1149
01:28:34,045 --> 01:28:37,954
SP: So there's a built in tree type, isn't there, there?

1150
01:28:38,000 --> 01:28:39,986
OC: Yes, its not one that I'm very familiar with.

1151
01:28:39,986 --> 01:28:42,906
It's in the same library as Data.Set and Data.Map.

1152
01:28:44,068 --> 01:28:48,674
It doesn't have a hugh API,
but it does avoid me reinventing the wheel

1153
01:28:48,674 --> 01:28:51,382
in terms of just coming up with the data type.

1154
01:28:52,182 --> 01:28:58,320
And the other thing that I might be interested
in doing is; there's a lot of hidden recursion here.

1155
01:28:58,365 --> 01:29:02,897
It's quite hard to follow this
code, it calls itself in different ways.

1156
01:29:03,066 --> 01:29:07,266
It's more of an advanced way of writing Haskell,

1157
01:29:07,260 --> 01:29:10,331
but you can split that recursion
out and make it very explicit.

1158
01:29:10,342 --> 01:29:13,260
So you pass around functions
that operate on just one thing,

1159
01:29:13,260 --> 01:29:16,114
and then you have a
recursion scheme you can apply to that.

1160
01:29:16,114 --> 01:29:18,960
And that might come out
with some slightly cleaner code.

1161
01:29:18,980 --> 01:29:23,188
But it's going to take a lot more work to get that.

1162
01:29:23,200 --> 01:29:26,880
But I think making that recursion
clear could clear up a lot of this code.

1163
01:29:27,480 --> 01:29:31,293
SP: Right, that seems like a successful session.

1164
01:29:31,293 --> 01:29:32,973
OC: I think so - got there in the end.

1165
01:29:32,973 --> 01:29:36,226
SP: Yes, thanks.

1166
01:29:36,226 --> 01:29:36,880
OC: OK.

1167
01:29:36,880 --> 01:29:42,000
Captions produced by Bonnie Roworth
