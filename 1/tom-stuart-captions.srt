1
00:00:01,450 --> 00:00:02,710
Welcome to Peer to Peer

2
00:00:02,820 --> 00:00:05,650
where you can watch how
experts solve tech problems.

3
00:00:06,480 --> 00:00:08,640
Our guest today is Tom Stuart,

4
00:00:08,680 --> 00:00:12,720
author of Understanding
Computation and veteran Rubyist.

5
00:00:13,140 --> 00:00:15,146
I'm your host Drew Neil,

6
00:00:15,170 --> 00:00:17,450
and the challenge
I've set for Tom is called

7
00:00:17,450 --> 00:00:19,450
Counting Tree Nodes.

8
00:00:21,940 --> 00:00:25,020
DN: So Tom would you like
to start by reading out the problem.

9
00:00:25,020 --> 00:00:26,493
TS: Sure, it says:

10
00:00:26,666 --> 00:00:28,906
Model a tree of max depth 5

11
00:00:29,200 --> 00:00:32,293
Given a collection of such trees,
let me sort by these properties:

12
00:00:32,293 --> 00:00:33,906
Total number of ancestors,

13
00:00:34,040 --> 00:00:35,760
Total number of terminals,

14
00:00:36,106 --> 00:00:40,573
These totals should be correct following
any operation that adds or removes a node.

15
00:00:40,573 --> 00:00:42,110
OK.

16
00:00:42,110 --> 00:00:43,240
DN: Is that clear?

17
00:00:43,240 --> 00:00:45,320
TS: Well... I'm not entirely sure

18
00:00:45,333 --> 00:00:48,386
what you mean by
either of those things.

19
00:00:48,386 --> 00:00:52,093
By terminals do you
mean leaves of the tree?

20
00:00:53,140 --> 00:00:56,253
DN: Ok, so a leaf can be
anything that has no children.

21
00:00:56,880 --> 00:01:00,000
By terminal I mean a
leaf at the maximum depth.

22
00:01:00,480 --> 00:01:02,826
It's a leaf that cannot have any children.

23
00:01:04,110 --> 00:01:07,200
In fact if you turn to the
next page there's an illustration.

24
00:01:11,000 --> 00:01:13,480
There we have the root at the center

25
00:01:13,510 --> 00:01:15,666
and then there's 4 concentric circles.

26
00:01:15,710 --> 00:01:19,840
I've said max depth 5, you might
prefer to call it max depth 4

27
00:01:21,600 --> 00:01:24,420
depending on whether you
call the root a level or not.

28
00:01:26,080 --> 00:01:28,186
In that picture the terminals are the ones

29
00:01:28,200 --> 00:01:30,400
farthest from the root, pictured in red.

30
00:01:31,940 --> 00:01:33,420
The blue ones are ancestors.

31
00:01:33,420 --> 00:01:34,970
Some of them happen to be leaves,

32
00:01:34,970 --> 00:01:36,746
some of them do have children

33
00:01:37,693 --> 00:01:41,080
but it's only a terminal if
it's on the outermost ring and

34
00:01:41,093 --> 00:01:44,280
it's not possible for it have any more children.

35
00:01:44,740 --> 00:01:47,080
TS: Well this answers
my other two questions.

36
00:01:47,080 --> 00:01:49,173
One was what you meant by depth

37
00:01:49,173 --> 00:01:52,880
because from the problem description

38
00:01:52,940 --> 00:01:57,573
I didn't know if you were
including the root in that.

39
00:01:57,600 --> 00:02:00,253
If I remember my
graph theory correctly,

40
00:02:01,013 --> 00:02:05,680
one of the measures in
any tree is depth but I think

41
00:02:05,706 --> 00:02:08,280
it's about how many
edges you have to traverse

42
00:02:08,280 --> 00:02:10,450
whereas that's not
exactly what you want.

43
00:02:10,450 --> 00:02:13,426
So you're talking about
how many fence posts there are

44
00:02:13,420 --> 00:02:15,973
not how many spaces
between the fence posts.

45
00:02:15,973 --> 00:02:17,310
DN: Yes.

46
00:02:17,310 --> 00:02:19,853
OC: And I was going to
ask you about ancestors.

47
00:02:19,866 --> 00:02:23,490
This here is not what I expected.

48
00:02:23,600 --> 00:02:25,600
I thought by ancestors you would mean

49
00:02:26,200 --> 00:02:27,826
nodes that had children

50
00:02:28,800 --> 00:02:33,733
since an ancestor is
your parents' parents etc.

51
00:02:33,893 --> 00:02:35,420
DN: So you're looking upward.

52
00:02:37,280 --> 00:02:41,466
OC: But this is looking
at the root as being...

53
00:02:45,680 --> 00:02:47,626
I'd use the word descendants for that.

54
00:02:47,626 --> 00:02:50,160
DN: Yes that's obviously a
better word. (laughter)

55
00:02:50,173 --> 00:02:53,440
It doesn't matter...

56
00:02:55,510 --> 00:02:57,370
TS: Do I need to
know what this is for.

57
00:02:57,370 --> 00:02:59,813
Is this the entire
scope of the problem?

58
00:03:02,140 --> 00:03:04,000
DN: Yes, but if you feel it's too much

59
00:03:04,020 --> 00:03:07,040
we can make it sortable by one of those fields.

60
00:03:07,600 --> 00:03:09,310
You can pick whichever you like.

61
00:03:09,320 --> 00:03:13,546
TS: One more question.
The count you've called ancestors

62
00:03:13,546 --> 00:03:17,346
is how many nodes
there are in the tree

63
00:03:17,786 --> 00:03:19,000
apart from the root.

64
00:03:19,020 --> 00:03:19,893
DN: Yes.

65
00:03:21,910 --> 00:03:23,850
TS: I'm hoping that that will always be

66
00:03:24,340 --> 00:03:27,013
the number of nodes
in the tree minus one

67
00:03:27,173 --> 00:03:29,546
because you're not considering the root.

68
00:03:29,546 --> 00:03:30,213
DN: Exactly.

69
00:03:31,620 --> 00:03:35,013
TS: Is the absolute value
of that number important

70
00:03:35,080 --> 00:03:36,680
or is just its relative values?

71
00:03:36,680 --> 00:03:39,620
For example if we did
count the root would that matter,

72
00:03:39,620 --> 00:03:41,820
or is the only reason
to count this number

73
00:03:41,820 --> 00:03:43,140
so you can sort the trees?

74
00:03:45,650 --> 00:03:47,850
DN: Yes, it is so that
you can sort the trees.

75
00:03:48,650 --> 00:03:50,940
TS: Presumably it's not
going to be a problem

76
00:03:50,940 --> 00:03:53,350
to subtract one from
whatever that number is.

77
00:03:53,360 --> 00:03:55,130
DN: I've used the word ancestors but

78
00:03:55,130 --> 00:03:57,430
if you want to call them descendants,

79
00:03:57,440 --> 00:04:00,430
forget that I ever called
them ancestors (laughter).

80
00:04:01,190 --> 00:04:03,730
TS: It's tempting to
go with the terminology

81
00:04:03,850 --> 00:04:05,260
that you've presented here

82
00:04:05,260 --> 00:04:06,850
unless you feel uncomfortable with it.

83
00:04:06,870 --> 00:04:09,880
If you want to change
the problem then do so.

84
00:04:10,020 --> 00:04:11,650
DN: Yes, let's change the problem

85
00:04:11,680 --> 00:04:12,970
and call them descendants.

86
00:04:15,780 --> 00:04:16,750
TS: Shall we get started then?

87
00:04:16,760 --> 00:04:18,140
DN: Let's do that.

88
00:04:22,220 --> 00:04:23,680
OK, I'm going to make a...

89
00:04:23,820 --> 00:04:25,630
let's call it trees.

90
00:04:34,310 --> 00:04:36,170
I would like to start by...

91
00:04:40,410 --> 00:04:43,310
clarifying what we want in here

92
00:04:43,310 --> 00:04:44,940
by writing an acceptance test.

93
00:04:45,020 --> 00:04:47,020
So I'm going to use cucumber for that.

94
00:04:47,810 --> 00:04:51,530
Let me be strange about this...

95
00:04:57,650 --> 00:05:00,000
This might take a
while to install cucumber.

96
00:05:00,000 --> 00:05:02,310
I should have done
it before we started.

97
00:05:11,480 --> 00:05:13,770
Ordinary I would use cucumber

98
00:05:13,770 --> 00:05:15,650
when I'm building a web application.

99
00:05:15,650 --> 00:05:17,220
It's an obvious
benefit for me

100
00:05:17,220 --> 00:05:18,940
to have all that
stuff written down.

101
00:05:18,950 --> 00:05:20,550
More tenuous here I think

102
00:05:21,370 --> 00:05:22,970
but I'm just
going to go with it

103
00:05:23,000 --> 00:05:25,080
because it will give
me an opportunity

104
00:05:25,080 --> 00:05:27,080
to write down the problem

105
00:05:27,080 --> 00:05:28,800
before I start thinking about it.

106
00:05:29,600 --> 00:05:32,390
So to crystallize that
conversation we just had...

107
00:05:32,390 --> 00:05:33,420
about what you mean.

108
00:05:35,450 --> 00:05:38,500
So I'm going to run Cucumber.

109
00:05:43,850 --> 00:05:48,400
And now it will
hopefully run zero scenarios.

110
00:05:48,710 --> 00:05:49,830
I'm going to make...

111
00:05:52,570 --> 00:05:55,120
what shall we call it, a trees feature?

112
00:05:55,540 --> 00:05:57,620
I suppose the actual feature that we're

113
00:05:57,620 --> 00:05:59,880
talking about is the ability to sort them.

114
00:05:59,900 --> 00:06:01,880
So I'll call that sorting feature.

115
00:06:03,080 --> 00:06:05,510
So feature sorting trees...

116
00:06:05,730 --> 00:06:07,490
and I suppose I'm
going to be writing this

117
00:06:07,500 --> 00:06:08,860
from the point of view of.....

118
00:06:10,570 --> 00:06:13,080
ordinarily, if you're writing an
acceptance test for a web application

119
00:06:13,080 --> 00:06:16,100
you would be thinking
about a particular kind of user,

120
00:06:16,200 --> 00:06:22,880
But the problem you've given me is from
the perspective of a client of an API.

121
00:06:22,930 --> 00:06:26,120
You haven't said there has
to be buttons to be clicked on.

122
00:06:26,130 --> 00:06:27,420
So I'm going to say:

123
00:06:27,420 --> 00:06:32,180
"as a user of the tree data structure".

124
00:06:33,450 --> 00:06:36,960
I want to be able to sort collections of trees.

125
00:06:36,960 --> 00:06:39,420
by various criteria.

126
00:06:40,940 --> 00:06:42,150
so that...

127
00:06:42,150 --> 00:06:43,650
I don't really know why,

128
00:06:43,820 --> 00:06:45,910
it's just part of
the problem statement.

129
00:06:45,930 --> 00:06:46,800
I'm going to say:

130
00:06:46,800 --> 00:06:51,440
So that my collections are in the right order.

131
00:06:51,660 --> 00:06:54,310
In a real situation I
would interrogate you further

132
00:06:54,310 --> 00:06:57,140
about why you want these
trees to be in the right order.

133
00:07:02,760 --> 00:07:04,510
TS: So one of your scenarios was

134
00:07:08,940 --> 00:07:13,170
sort by total
number of descendants.

135
00:07:24,170 --> 00:07:31,820
Your other one was sort
by total number of terminals.

136
00:07:38,800 --> 00:07:41,410
Given that I have a collection of trees

137
00:07:54,140 --> 00:07:58,200
Let's say when I sort it by
total number of descendants,

138
00:07:58,200 --> 00:08:01,530
then it should be ordered by...

139
00:08:01,540 --> 00:08:04,320
DN: 'It' being the collection
rather than an individual tree?

140
00:08:04,340 --> 00:08:06,220
TS: Does that make sense?

141
00:08:06,226 --> 00:08:07,333
DN: Yes it does.

142
00:08:07,400 --> 00:08:09,080
TS: That pronoun is referring to

143
00:08:09,080 --> 00:08:11,110
the thing I was talking about before.

144
00:08:11,850 --> 00:08:14,910
So this is going to be exactly the same,

145
00:08:15,850 --> 00:08:21,960
but this will say sorted
by total number of terminals.

146
00:08:22,680 --> 00:08:24,940
And this will be total
number of terminals.

147
00:08:25,370 --> 00:08:26,600
Are you happy with that?

148
00:08:26,600 --> 00:08:27,480
DN: Yes that's fine.

149
00:08:32,220 --> 00:08:34,680
TS: think I will
change this to 'the collection'

150
00:08:34,680 --> 00:08:39,990
just because... Are we sorting the
nodes of the tree or the collection?

151
00:08:40,340 --> 00:08:42,540
DN: The collection
is what we are sorting.

152
00:08:49,820 --> 00:08:53,550
TS: So that's slightly more
verbose but hopefully clearer,

153
00:08:54,910 --> 00:08:56,020
which is what we want.

154
00:08:56,420 --> 00:08:57,930
I'll run that feature.

155
00:09:03,650 --> 00:09:06,740
It has complained that I
haven't defined these steps

156
00:09:06,750 --> 00:09:08,520
and it has given me everything I need

157
00:09:08,530 --> 00:09:15,320
so I will make a features step definitions.

158
00:09:16,980 --> 00:09:19,440
Tree steps file.

159
00:09:22,000 --> 00:09:24,420
DN: You're using Control P
there to create a file.

160
00:09:24,420 --> 00:09:26,890
TS: Yes. By hitting control Y.

161
00:09:29,140 --> 00:09:33,390
And it creates all
the parent directories.

162
00:09:33,650 --> 00:09:36,520
It saves me
dropping to the terminal.

163
00:09:36,890 --> 00:09:39,000
DN: Yes a good user interface.

164
00:09:42,540 --> 00:09:44,910
Before I start
implementing these, I can see

165
00:09:45,740 --> 00:09:47,540
that I've got a couple of when steps

166
00:09:47,710 --> 00:09:49,310
that are essentially the same.

167
00:09:49,650 --> 00:09:51,600
They differ only
in their final word.

168
00:09:52,140 --> 00:09:53,600
And ditto these.

169
00:09:53,600 --> 00:09:55,820
It's bothering me
that I don't know

170
00:09:55,820 --> 00:09:59,160
what the correct
spelling of descendants is.

171
00:10:00,420 --> 00:10:02,030
I'm going to look it up.

172
00:10:03,420 --> 00:10:06,630
I'm sure that's
right but to be sure...

173
00:10:06,740 --> 00:10:10,350
Yes that's right.

174
00:10:11,800 --> 00:10:13,410
I am much more confident now.

175
00:10:17,740 --> 00:10:20,800
When I write this I want
there to be a block argument here

176
00:10:20,820 --> 00:10:26,150
that says something
like 'order by' and then,

177
00:10:26,940 --> 00:10:29,280
to keep this compact, I'm going to say

178
00:10:29,290 --> 00:10:31,400
case order by and I'm expecting

179
00:10:31,400 --> 00:10:34,220
there to be a descendants case,

180
00:10:34,280 --> 00:10:37,740
and a terminals
case, so I don't end up

181
00:10:37,970 --> 00:10:41,260
duplicating what I'm doing here.

182
00:10:41,600 --> 00:10:44,090
This will just be anything...

183
00:10:44,110 --> 00:10:46,080
Oh! well I should
have done that here.

184
00:10:48,530 --> 00:10:51,650
So when I sort my collection
by total number of 'something',

185
00:10:51,650 --> 00:10:53,430
and then I can
put my code in there.

186
00:10:53,440 --> 00:10:56,340
There's going to be
something very similar here I think.

187
00:10:59,600 --> 00:11:02,650
This is going to be 'Something'.

188
00:11:04,000 --> 00:11:04,450
and then:

189
00:11:06,620 --> 00:11:08,600
So that's the
skeleton of what we want.

190
00:11:10,850 --> 00:11:14,413
In here I want to have
trees be equal to something.

191
00:11:16,740 --> 00:11:18,200
So that's my first challenge.

192
00:11:22,220 --> 00:11:24,940
I suppose here I will
write the code that I wish I had.

193
00:11:26,880 --> 00:11:29,653
Although that's not
terribly straight forward.

194
00:11:33,370 --> 00:11:36,080
In order for us to
verify that this code is working.

195
00:11:36,080 --> 00:11:38,080
what I don't want to do is things like

196
00:11:39,200 --> 00:11:41,050
make a random collection of trees,

197
00:11:41,050 --> 00:11:43,680
and then ask the API to sort them.

198
00:11:43,706 --> 00:11:45,650
and then go through
and say, "when I ask each

199
00:11:45,650 --> 00:11:48,570
of those trees what
their total number of ancestors is"

200
00:11:48,570 --> 00:11:50,510
then it's increasing because that would not

201
00:11:50,510 --> 00:11:52,540
tell me that my code is working correctly.

202
00:11:52,540 --> 00:11:54,820
It would just verify that
the code that I've written

203
00:11:54,820 --> 00:11:56,650
did the same as the code that I've written.

204
00:11:56,650 --> 00:11:59,000
I would like you and I to agree on

205
00:11:59,000 --> 00:12:01,020
some representative collection of trees,

206
00:12:01,020 --> 00:12:04,310
which to begin with is in an
arbitrary order that we determine.

207
00:12:04,800 --> 00:12:09,600
And then for us to decide what
order that collection SHOULD be in

208
00:12:09,613 --> 00:12:11,306
after it's been sorted..

209
00:12:11,300 --> 00:12:12,906
DN: Yes, OK.

210
00:12:17,940 --> 00:12:22,000
I would like to initialize
a few representative trees,

211
00:12:22,000 --> 00:12:23,973
and then put them into the collection.

212
00:12:23,986 --> 00:12:28,026
So I would like this to be something like trees equals

213
00:12:28,020 --> 00:12:30,826
small tree, large tree...

214
00:12:30,826 --> 00:12:32,770
DN:  We could also have a shallow tree,

215
00:12:32,770 --> 00:12:35,226
one that has no terminals or...

216
00:12:35,310 --> 00:12:38,440
TS: And then with the intention being that

217
00:12:38,710 --> 00:12:41,333
down here, we would say:

218
00:12:41,650 --> 00:12:49,693
"expect trees to be equal to
things that are in a different order".

219
00:12:49,706 --> 00:12:50,280
DN: Yes.

220
00:12:50,280 --> 00:12:54,600
TS: And that will hopefully
verify that things are working.

221
00:12:56,400 --> 00:12:58,200
DN: Three seems like a good number.

222
00:12:58,200 --> 00:12:59,626
TS: Are you sure, OK.

223
00:13:01,250 --> 00:13:03,050
TS: Let's see how many we can think of.

224
00:13:06,450 --> 00:13:10,386
So you want them to be of maximum depth,

225
00:13:10,400 --> 00:13:14,773
and have, at most 5 nodes,
counting from the root node.

226
00:13:14,800 --> 00:13:15,770
DN: Yes that's right.

227
00:13:15,770 --> 00:13:20,760
So that's 4 edges in the path
from the root to the most distant leaf.

228
00:13:25,540 --> 00:13:28,420
So they don't have to go
all the way out to the periphery.

229
00:13:28,420 --> 00:13:29,370
DN: They don't.

230
00:13:29,850 --> 00:13:33,213
Those would be unfinished fences, if you like.

231
00:13:34,333 --> 00:13:38,280
TS: Fences! (laughter)

232
00:13:41,250 --> 00:13:47,200
Let's just say the simplest
possible tree is just one node.

233
00:13:50,910 --> 00:13:52,640
DN: Yes, which would be a root.

234
00:13:58,770 --> 00:14:01,420
TS: I'm trying to speak
through my hesitation here!

235
00:14:02,970 --> 00:14:05,110
I'm going to have to make
a decision about...

236
00:14:05,110 --> 00:14:07,800
what's the class called
and how it's instantiated.

237
00:14:07,826 --> 00:14:11,110
I'm concerned about baking
that into my step definition here

238
00:14:11,110 --> 00:14:15,160
because although I am
prepared to make a decision now,

239
00:14:15,160 --> 00:14:17,620
I don't know if I want
to live with that decision.

240
00:14:19,600 --> 00:14:22,453
I'm going to write a helper
method outside the step definition

241
00:14:22,453 --> 00:14:24,293
which I used to build trees.

242
00:14:24,340 --> 00:14:27,120
So here I can call build tree and give it

243
00:14:27,140 --> 00:14:30,533
something that's a little bit agnostic.

244
00:14:30,533 --> 00:14:31,600
DN: Yes.

245
00:14:31,600 --> 00:14:36,208
That doesn't talk about
the actual name of the class

246
00:14:36,200 --> 00:14:37,493
or how it's instantiated.

247
00:14:37,490 --> 00:14:40,586
Do you pass in an options
hash or positional arguments.

248
00:14:40,586 --> 00:14:43,813
Or do you create an empty
one and mutate it or whatever?

249
00:14:44,120 --> 00:14:46,080
I can try and keep this step definition

250
00:14:46,080 --> 00:14:48,140
to just stuff that we're interested in.

251
00:15:02,510 --> 00:15:09,160
My instinct here is to think of each node
of a tree as being a collection of its children

252
00:15:09,200 --> 00:15:12,586
and a leaf is a node that has no children.

253
00:15:12,770 --> 00:15:13,800
DN: Correct.

254
00:15:17,540 --> 00:15:19,620
I don't know yet if we are going to need to

255
00:15:19,620 --> 00:15:23,146
distinguish between parent nodes and leaves.

256
00:15:23,480 --> 00:15:26,280
Your problem statement
didn't say anything about

257
00:15:26,280 --> 00:15:28,880
storing values on the node.

258
00:15:30,620 --> 00:15:34,240
In a binary tree you might
only store values at the leaves,

259
00:15:34,250 --> 00:15:36,710
and the nodes are just a collection of children.

260
00:15:38,420 --> 00:15:41,386
For now, since you didn't
mention it in the statement.

261
00:15:41,386 --> 00:15:45,293
I'm going to assume that what
we want to represent is the structure

262
00:15:45,293 --> 00:15:48,440
with no values stored within it.

263
00:15:48,480 --> 00:15:53,146
And if we want to add to
it later I want it to be flexible.

264
00:15:54,770 --> 00:15:56,620
If we finish this and then you say

265
00:15:56,620 --> 00:15:59,050
I want you to add up all the numbers in the tree

266
00:15:59,050 --> 00:16:01,250
we will find a way to store them in the tree.

267
00:16:01,250 --> 00:16:05,813
DN:  I don't want to add
requirements at this stage.

268
00:16:06,840 --> 00:16:10,400
TS: OK so what I was saying
was, I think of a node as being

269
00:16:10,400 --> 00:16:12,770
a possible empty collection of children.

270
00:16:12,770 --> 00:16:14,850
So for me, the obvious representation here

271
00:16:14,850 --> 00:16:15,933
is to give it an array.

272
00:16:15,940 --> 00:16:18,000
And say "I want you to build a tree",

273
00:16:18,000 --> 00:16:21,826
and here are the children of the root node

274
00:16:21,826 --> 00:16:23,420
which in that case is nothing.

275
00:16:23,420 --> 00:16:26,773
So if I just want a root, node it will be like that.

276
00:16:26,773 --> 00:16:28,280
What else could we do?

277
00:16:28,310 --> 00:16:35,333
I can think of a 'wide tree'
that would be something like

278
00:16:36,093 --> 00:16:42,173
it's only one deep but
has lots of direct descendants.

279
00:16:42,200 --> 00:16:44,220
That would be a node in the center and

280
00:16:44,220 --> 00:16:46,666
then 5 emanating from it.

281
00:16:46,666 --> 00:16:49,493
DN: So that would have
many descendants but no terminals.

282
00:16:49,490 --> 00:16:51,026
TS: Yes, exactly.

283
00:16:53,600 --> 00:16:56,200
TS: Do you have any other
suggestions, as the owner?

284
00:16:56,200 --> 00:17:00,333
DN: I guess we could do something that is deep.

285
00:17:00,680 --> 00:17:02,773
TS: Would that be deep and narrow?

286
00:17:02,773 --> 00:17:05,080
We could have one that's just got 5 children.

287
00:17:10,050 --> 00:17:11,310
Like this...

288
00:17:11,310 --> 00:17:13,310
DN: Yes, right.

289
00:17:13,800 --> 00:17:19,426
TS: I'm already liking this because you
can almost see the structure of the tree.

290
00:17:20,280 --> 00:17:22,510
Each set of brackets is one node I think.

291
00:17:23,000 --> 00:17:24,680
This is just one node,

292
00:17:24,710 --> 00:17:26,420
this is one node with 5 children,

293
00:17:26,420 --> 00:17:28,973
and this 12345.

294
00:17:29,020 --> 00:17:31,066
So that's what you meant by a tree?

295
00:17:31,093 --> 00:17:32,226
DN: Yes.

296
00:17:35,820 --> 00:17:38,340
I'm going to write a comment next to each of these

297
00:17:38,340 --> 00:17:41,280
to keep track of what we think
the metric is for each of them.

298
00:17:41,290 --> 00:17:49,480
This one would have no descendants, and no terminals.

299
00:17:49,490 --> 00:17:51,200
DN: Yes.

300
00:17:51,250 --> 00:17:54,200
TS: This one would have 5 descendants.

301
00:17:54,226 --> 00:17:55,280
(I'll write that down).

302
00:17:56,910 --> 00:17:58,386
And no terminals.

303
00:17:59,370 --> 00:18:03,400
This one has I think, 4 descendants.

304
00:18:03,920 --> 00:18:04,820
Is that correct?

305
00:18:04,820 --> 00:18:07,626
DN: Yes it is because we don't count the root.

306
00:18:08,200 --> 00:18:10,466
TS: And one terminal?

307
00:18:10,480 --> 00:18:12,066
DN: Exactly, yes.

308
00:18:12,140 --> 00:18:15,853
TS: It's frustrating that we have two trees

309
00:18:15,866 --> 00:18:19,080
that have no terminals, but that's fine,

310
00:18:19,080 --> 00:18:20,360
we can cope with that.

311
00:18:20,360 --> 00:18:24,760
Thinking ahead, because
the sort in Ruby isn't stable

312
00:18:24,760 --> 00:18:29,266
There's a chance that if two
trees tie on the number of terminals

313
00:18:29,266 --> 00:18:31,220
the sort is going to put
them in an arbitrary order.

314
00:18:31,220 --> 00:18:34,226
But, we'll just have to cross
that bridge when we come to it.

315
00:18:34,226 --> 00:18:36,220
That's absolutely fine.

316
00:18:36,320 --> 00:18:38,360
What other kinds of tree could we have?

317
00:18:38,373 --> 00:18:43,106
DN: We could have a deep wide
tree that has...

318
00:18:43,106 --> 00:18:45,440
perhaps 2 descendants...

319
00:18:46,890 --> 00:18:50,373
in two entirely different branches,

320
00:18:50,373 --> 00:18:51,910
that go as far as the terminal.

321
00:18:56,080 --> 00:18:57,906
TS: Like this?
DN: That's right.

322
00:18:57,910 --> 00:18:59,480
TS: We can have...

323
00:19:03,080 --> 00:19:05,333
So I think that's...
I don't know why...

324
00:19:05,333 --> 00:19:08,493
DN: Your missing the final...

325
00:19:09,373 --> 00:19:11,120
TS: I don't know why vim isn't...

326
00:19:11,140 --> 00:19:12,800
That threw me, I was expecting

327
00:19:12,800 --> 00:19:15,786
to see a highlight on the first [bracket]

328
00:19:15,880 --> 00:19:19,306
DN: But if you put your cursor
on the first opening bracket.

329
00:19:19,306 --> 00:19:21,250
TS: Yes it highlights the closing one.

330
00:19:25,970 --> 00:19:28,040
What are our metrics for this?

331
00:19:28,053 --> 00:19:32,680
DN: We have 3 terminals and lots of descendants.

332
00:19:32,960 --> 00:19:34,540
TS: Maybe that doesn't matter.

333
00:19:36,340 --> 00:19:37,693
That's certainly got the most.

334
00:19:37,693 --> 00:19:39,053
DN: It's going to be the winner.

335
00:19:39,050 --> 00:19:42,080
TS: My expectation would be that there are 12,

336
00:19:42,620 --> 00:19:44,310
because there were 4 in this one.

337
00:19:44,310 --> 00:19:46,540
And we have basically tripled that one up.

338
00:19:47,620 --> 00:19:49,226
Just a sanity check this!

339
00:19:49,250 --> 00:19:51,733
Would we expect that
these two things would...

340
00:19:52,110 --> 00:19:55,280
that sorting them by
descendants versus by terminals

341
00:19:55,293 --> 00:19:56,880
is going to produce a different order

342
00:19:56,880 --> 00:19:58,600
otherwise it isn't a useful test case.

343
00:19:58,613 --> 00:20:01,293
If we sort them by the number of descendants

344
00:20:01,306 --> 00:20:05,066
then we have none... 4, 5 many.

345
00:20:05,080 --> 00:20:08,746
So that would be just one
deep tree, wide tree, deep wide tree.

346
00:20:08,746 --> 00:20:09,450
DN: Yes.

347
00:20:11,050 --> 00:20:13,000
Whereas if we sort them by terminals,

348
00:20:13,013 --> 00:20:15,120
we would expect them to be in this order.

349
00:20:15,140 --> 00:20:18,146
Like none, none, one and three.

350
00:20:18,510 --> 00:20:21,426
Bearing that in mind....

351
00:20:21,450 --> 00:20:24,786
I will not put them in in that order.

352
00:20:25,620 --> 00:20:28,986
I'll put them in yet another
order so we can see the sort work.

353
00:20:32,220 --> 00:20:33,293
So let's say...

354
00:20:36,120 --> 00:20:39,306
Deep tree, just one...

355
00:20:39,320 --> 00:20:41,720
this is an instance variable.

356
00:20:41,810 --> 00:20:44,170
and the reason why they are
instance variables is so I can

357
00:20:44,170 --> 00:20:47,053
refer to them in there
outside of this lexical scope.

358
00:20:47,053 --> 00:20:49,173
Deep tree, just one node.

359
00:20:51,540 --> 00:20:54,320
Deep wide tree, wide tree.

360
00:20:54,333 --> 00:20:54,970
DN: Yes.

361
00:20:54,970 --> 00:21:00,626
TS: I'm hoping that's enough to get us started.

362
00:21:00,680 --> 00:21:02,640
I'll just check that, by running...

363
00:21:03,853 --> 00:21:06,986
Oh! Undefined method: build tree. OK, fine.

364
00:21:06,986 --> 00:21:08,940
That's the failure I was expecting.

365
00:21:09,970 --> 00:21:18,413
I will quickly make a features...

366
00:21:20,880 --> 00:21:23,000
I need to define that method somewhere.

367
00:21:23,000 --> 00:21:27,733
I will make a file and put it in support.

368
00:21:27,880 --> 00:21:32,213
I'll call it trees helper.

369
00:21:37,902 --> 00:21:41,155
And put build tree method in here.

370
00:21:41,370 --> 00:21:46,586
And so I don't forget, I'm also going
to make that method available to Cucumber,

371
00:21:46,620 --> 00:21:50,786
so I will remember to put a file in features.

372
00:21:54,570 --> 00:21:57,050
The names of these files
are of no consequence,

373
00:21:57,050 --> 00:21:59,020
it's just what I'm used to calling them.

374
00:21:59,200 --> 00:22:01,533
So in here I want to require...

375
00:22:05,650 --> 00:22:07,760
just trying to think...

376
00:22:09,140 --> 00:22:13,146
I think I will need to require relative.

377
00:22:13,340 --> 00:22:16,786
I'm trying to work out if this file is
going to run before or after the other one

378
00:22:16,786 --> 00:22:19,733
because cucumber will load
all of the files in the directory.

379
00:22:19,746 --> 00:22:22,493
Just to be safe I will require it.

380
00:22:22,493 --> 00:22:25,066
I will do require relative trees helper

381
00:22:25,110 --> 00:22:27,080
then if it hasn't already been loaded,

382
00:22:27,080 --> 00:22:29,310
it will load it because
I want to say world...

383
00:22:32,050 --> 00:22:38,053
and say make that available
in all of my step definitions.

384
00:22:38,940 --> 00:22:41,026
This needs an argument, children.

385
00:22:43,340 --> 00:22:46,880
It takes an array of children.

386
00:22:48,600 --> 00:22:53,453
Now I have to make a decision
about how to instantiate these things.

387
00:22:54,346 --> 00:22:57,560
For now I'll assume we just have a single class

388
00:22:57,600 --> 00:23:00,680
and I'll call it node because
that's a word we've been using.

389
00:23:01,680 --> 00:23:04,640
I'm assuming this will
ultimately return a new node,

390
00:23:05,170 --> 00:23:07,910
but we need to know
what children it's going to have.

391
00:23:07,910 --> 00:23:09,540
If that children array is empty...

392
00:23:10,400 --> 00:23:12,973
let me think in code...

393
00:23:12,973 --> 00:23:18,600
If the children is empty then
it's fine to just do...

394
00:23:20,146 --> 00:23:23,746
We're going to give it an empty load of children.

395
00:23:23,740 --> 00:23:28,040
And I'm prejudging the idea that we're going to

396
00:23:28,053 --> 00:23:30,570
create these by providing an array of children,

397
00:23:30,613 --> 00:23:33,880
rather than creating an empty one
and then mutating it to add them

398
00:23:33,946 --> 00:23:37,720
but we will investigate whether
that's a good idea or not I suppose.

399
00:23:42,770 --> 00:23:46,050
I'll just make it clearer that
that is going to be an empty array.

400
00:23:46,220 --> 00:23:49,586
It may be that is an optional
argument and if we don't provide it

401
00:23:49,586 --> 00:23:51,413
then it creates an empty node.

402
00:23:52,573 --> 00:23:54,573
But this is what would make sense to me

403
00:23:54,573 --> 00:23:58,306
and I'm thinking in terms
of myself being a client now.

404
00:23:58,320 --> 00:24:01,973
If there are no children we make an empty one,

405
00:24:01,970 --> 00:24:04,626
if there are children then...

406
00:24:04,626 --> 00:24:07,200
each of the children in my representation here

407
00:24:07,680 --> 00:24:11,426
is of the same form as
the list of children i.e. an array.

408
00:24:12,250 --> 00:24:16,573
I need to call build_tree on
each child to turn it into a node,

409
00:24:16,600 --> 00:24:20,640
then I can pass that collection
of nodes to the constructor of node.

410
00:24:20,640 --> 00:24:23,390
So I just need to call
this recursively on the children.

411
00:24:23,400 --> 00:24:26,026
I know, because I've written Ruby before,

412
00:24:26,020 --> 00:24:31,000
that I can do that by doing
children.map(&method(:build_tree))

413
00:24:31,960 --> 00:24:36,973
That's going to call
build_tree on each individual child.

414
00:24:36,970 --> 00:24:44,560
That's the same as no new
children, map, child, build tree, child.

415
00:24:44,573 --> 00:24:47,426
Just slightly more concise.

416
00:24:48,220 --> 00:24:51,613
In fact I prefer that one.

417
00:24:53,560 --> 00:24:55,570
DN:  Yes, it shows the argument better.

418
00:24:55,570 --> 00:24:57,600
TS: Yes, you can see what's going on there.

419
00:24:57,600 --> 00:25:00,370
Then I just have to
remember to close the brackets.

420
00:25:00,370 --> 00:25:05,640
Now I can see that this line here is a special case.

421
00:25:05,650 --> 00:25:09,960
In this one, we're mapping over an
empty array which gives you an empty array.

422
00:25:10,493 --> 00:25:12,026
So I can get rid of that.

423
00:25:15,140 --> 00:25:16,906
So now where are we....

424
00:25:20,220 --> 00:25:24,080
Now it's complaining
that I don't have a Node class.

425
00:25:29,050 --> 00:25:30,213
Let's make one.

426
00:25:30,680 --> 00:25:32,450
I'll put it in a folder called lib.

427
00:25:38,080 --> 00:25:40,140
I'm hesitating because this is the point at which

428
00:25:40,140 --> 00:25:43,613
I would like to start dropping
down to write some unit tests.

429
00:25:43,613 --> 00:25:45,770
Get this to a point where we're comfortable.

430
00:25:45,786 --> 00:25:48,293
Still say uninitialized constant.

431
00:25:50,280 --> 00:25:53,110
I would like to start
dropping down to unit tests now.

432
00:25:55,800 --> 00:25:58,893
We haven't filled this stuff out yet,

433
00:25:59,400 --> 00:26:03,026
but I think I'm happy to just bounce back and forth.

434
00:26:03,710 --> 00:26:06,170
It would be nice to get this first step passing

435
00:26:06,480 --> 00:26:10,000
because it's saying I don't
know what this Node thing is.

436
00:26:10,020 --> 00:26:15,720
so I would be more comfortable to
drive that out with a unit test now.

437
00:26:18,770 --> 00:26:24,560
TS: The main thing I'm
going to do now is install rspec.

438
00:26:25,860 --> 00:26:30,306
At the time of recording the
most recent version of rspec,

439
00:26:30,306 --> 00:26:34,733
is 3.0.0 release candidate 1. (RC1)

440
00:26:34,733 --> 00:26:35,933
DN:  Bleeding edge!

441
00:26:35,946 --> 00:26:39,340
TS. And hopefully the actual
version 3 will be out soon.

442
00:26:42,910 --> 00:26:49,346
DN: Just out of interest, you've
been running Cucumber scenarios.

443
00:26:49,346 --> 00:26:52,240
Are you suspending Vim or...?

444
00:26:52,280 --> 00:26:54,160
TS:  I will show you.

445
00:26:59,080 --> 00:27:01,140
DN: So you have something in your vimrc?

446
00:27:01,140 --> 00:27:02,770
TS: Yes, that does literally run.

447
00:27:02,770 --> 00:27:04,850
I'm sure there's a cleverer way than that

448
00:27:04,850 --> 00:27:07,413
but I'm just typing leader 'C' to run Cucumber,

449
00:27:07,450 --> 00:27:11,960
and because I've got
cucumber set up to use bin stubs...

450
00:27:13,480 --> 00:27:15,170
DN: You don't have do bundle exec.

451
00:27:15,173 --> 00:27:16,050
TS: Yes exactly.

452
00:27:18,080 --> 00:27:21,346
TS: It stores all of these
bin stubs in .bundle/bin,

453
00:27:21,346 --> 00:27:23,450
you can see there's a Cucumber binary there.

454
00:27:23,450 --> 00:27:26,413
and I've got my path set up
so bundle bin is on the path, which

455
00:27:26,413 --> 00:27:30,540
people have arguments
about this on the internet.

456
00:27:30,544 --> 00:27:32,820
It does create the opportunity
for someone to get you to

457
00:27:32,820 --> 00:27:37,573
clone a git repository that already has
a .bundle/bin folder with a binary called 'ls' in it

458
00:27:37,630 --> 00:27:40,653
that emails your password to the person.

459
00:27:42,400 --> 00:27:44,340
I prefer convenience over security,

460
00:27:44,340 --> 00:27:46,370
which is why I'm a terrible programmer.

461
00:27:47,420 --> 00:27:48,706
So that's all installed.

462
00:27:48,730 --> 00:27:55,320
Rspec comes with a nice
thingy that will initialize it for me.

463
00:27:55,340 --> 00:27:59,280
That's made a rspec file with some sensible defaults in,

464
00:27:59,280 --> 00:28:01,386
and it's made a spec helper.

465
00:28:01,420 --> 00:28:05,160
I will just check what's in here.

466
00:28:05,370 --> 00:28:09,293
Yes, there's a lot of guff in here which
for the purpose of this, I'll just get rid of.

467
00:28:11,250 --> 00:28:13,340
The only piece of configuration I want

468
00:28:13,340 --> 00:28:19,480
is that rspec 3 has this wonderful feature called disable_monkey_patching

469
00:28:19,680 --> 00:28:23,240
which will turn off all of the stuff
that patches the main object

470
00:28:23,266 --> 00:28:27,893
and extends Object with the 'should' method.

471
00:28:27,890 --> 00:28:31,053
So the only way I'm going to get
any kind of behavior out of rspec now,

472
00:28:31,053 --> 00:28:35,280
is to specifically say I want to
call this method as part of rspec.

473
00:28:37,250 --> 00:28:38,370
That's good.

474
00:28:39,050 --> 00:28:41,560
I will run all of my specs.

475
00:28:42,620 --> 00:28:44,640
Zero example, zero failures.

476
00:28:46,970 --> 00:28:48,820
I better write some examples then.

477
00:28:54,540 --> 00:28:57,400
I've already committed to
the class being called Node

478
00:28:57,400 --> 00:28:59,720
so I will call this node_spec.

479
00:29:01,880 --> 00:29:03,770
So because I turned monkey patching off,

480
00:29:03,770 --> 00:29:06,933
ordinarily the first thing I would
do here is say "describe something"

481
00:29:06,940 --> 00:29:09,426
but in rspec 3 when you turn monkey patching off

482
00:29:09,420 --> 00:29:13,013
you have to refer to the
top level constant RSpec.describe.

483
00:29:15,970 --> 00:29:17,333
Nodes of a tree.

484
00:29:21,820 --> 00:29:24,493
Now I'm ready to start writing examples here.

485
00:29:24,970 --> 00:29:26,773
If I run all of my tests.

486
00:29:31,540 --> 00:29:34,186
DN: How do you run your rspec tests?

487
00:29:34,570 --> 00:29:42,213
TS: I am using the vim-rspec plugin.

488
00:29:42,270 --> 00:29:44,000
So if I grep...

489
00:29:49,080 --> 00:29:50,340
That's not very helpful.

490
00:29:54,620 --> 00:29:57,493
Maybe what I want to find here is just spec.

491
00:29:58,250 --> 00:30:00,973
There are a few different bindings here.

492
00:30:01,106 --> 00:30:02,800
Leader 'T' runs the current file.

493
00:30:02,800 --> 00:30:09,226
Leader 'S' runs the part of the
spec that is nearest to the person.

494
00:30:09,226 --> 00:30:10,360
So that's really handy,

495
00:30:10,386 --> 00:30:13,480
I can run focused tests by just pressing leader 'S'.

496
00:30:13,773 --> 00:30:20,440
And leader 'L' is excellent because every
time I run the test it remembers how it called rspec.

497
00:30:20,440 --> 00:30:22,680
Every time I press leader 'L' it re-runs it.

498
00:30:22,693 --> 00:30:25,866
This is from thoughtbot I think. It's very nice.

499
00:30:28,120 --> 00:30:29,293
Where was I?

500
00:30:30,280 --> 00:30:31,680
node_spec.

501
00:30:35,110 --> 00:30:39,586
The first thing I want to do
here is verify that I can create one.

502
00:30:40,310 --> 00:30:42,373
So let's say something like:

503
00:30:42,370 --> 00:30:45,853
When the tree is empty.

504
00:30:45,970 --> 00:30:47,186
That will do.

505
00:30:52,000 --> 00:30:54,906
I want to start with something really simple here.

506
00:31:02,140 --> 00:31:05,680
I'm trying to think what I want to do
here to drive out the creation of the class.

507
00:31:13,200 --> 00:31:16,093
I don't really know what
behavior I want yet but let's say:

508
00:31:16,090 --> 00:31:17,453
It has no children.

509
00:31:17,453 --> 00:31:19,450
I'm already jumping slightly ahead but...

510
00:31:21,420 --> 00:31:26,266
This is going to help me to
think about what I want the API to be.

511
00:31:26,280 --> 00:31:28,893
DN: Do you want to use the word children?

512
00:31:28,890 --> 00:31:32,066
But I guess children means something different.

513
00:31:32,066 --> 00:31:33,140
TS: That's a good point.

514
00:31:33,280 --> 00:31:37,466
I've already introduced the word
children but yes, I mean direct descendants.

515
00:31:37,570 --> 00:31:40,400
That's just my prejudice
about what trees look like

516
00:31:40,400 --> 00:31:43,466
and what the things in them are called.

517
00:31:49,650 --> 00:31:53,040
TS: I'm already having to
think about the API of the thing here.

518
00:31:55,680 --> 00:32:03,040
I'm uncomfortable with that. Let's
say "it can be created without error".

519
00:32:03,110 --> 00:32:05,540
That's really the bare minimum I would expect,

520
00:32:05,540 --> 00:32:07,910
is the ability to create one of these things.

521
00:32:07,910 --> 00:32:10,346
So I'm going to say expect this block.

522
00:32:10,370 --> 00:32:12,666
Make me a new tree with no children.

523
00:32:13,940 --> 00:32:15,746
Not to raise an error.

524
00:32:15,740 --> 00:32:16,546
DN: Ok

525
00:32:17,650 --> 00:32:19,186
TS: So if I run all my tests.

526
00:32:19,620 --> 00:32:23,653
There's the failure I'm
looking for, uninitialized constant Node.

527
00:32:28,050 --> 00:32:29,453
I created the file.

528
00:32:30,250 --> 00:32:34,826
Or maybe I didn't because I
didn't put anything in it and save it.

529
00:32:40,200 --> 00:32:42,066
There's a class.

530
00:32:43,540 --> 00:32:45,301
If I run all my specs.

531
00:32:46,280 --> 00:32:48,710
It's still saying uninitialized constant though

532
00:32:48,710 --> 00:32:51,680
because I haven't made any attempt to load it.

533
00:32:51,720 --> 00:32:54,800
DN: I wondered if that might
be happening by magic somehow.

534
00:32:54,813 --> 00:32:57,250
TS: No it isn't happening by magic and I like that.

535
00:32:57,250 --> 00:33:01,853
With rspec and Cucumber,
you have to explicitly add them in.

536
00:33:01,853 --> 00:33:03,640
I'm a big fan of this.

537
00:33:03,640 --> 00:33:06,666
One of the things that people
criticize both rspec and Cucumber for

538
00:33:06,660 --> 00:33:11,120
was this lack of explicitness and
doing to much stuff automatically.

539
00:33:11,120 --> 00:33:15,066
Both projects at the time have tended towards removing

540
00:33:15,060 --> 00:33:17,426
that stuff and expecting
you to be more explicit.

541
00:33:17,440 --> 00:33:19,413
In fact a lot of the automatic stuff

542
00:33:19,426 --> 00:33:22,306
that people think of rspec
and cucumber as doing now

543
00:33:22,370 --> 00:33:25,510
are actually being done by
rspec rails and cucumber rails,

544
00:33:25,510 --> 00:33:29,440
because they wire cucumber
and rspec into a rails application

545
00:33:29,440 --> 00:33:31,800
and then put stuff in the spec helper

546
00:33:31,800 --> 00:33:34,440
and env files that boot up your application

547
00:33:34,450 --> 00:33:39,853
and then you've got rails
constant auto loading as if  by magic.

548
00:33:39,860 --> 00:33:43,093
but in this kind of setting we have to be explicit and it's nice

549
00:33:43,093 --> 00:33:44,666
because it means that I can...

550
00:33:44,680 --> 00:33:47,773
I mean whether or not we end up
with more than one class here I don't know.

551
00:33:47,773 --> 00:33:50,650
This might be the only spec file we write today.

552
00:33:51,510 --> 00:33:56,186
In this spec file I can say "I want to load node".

553
00:33:58,600 --> 00:34:03,440
By convention that lib folder that's
in the root rspec will put it on the load path.

554
00:34:03,480 --> 00:34:05,973
so I don't have to fiddle around with the load path,

555
00:34:06,000 --> 00:34:09,520
but I do have to explicitly
say I want to load this class.

556
00:34:14,160 --> 00:34:15,693
'wrong number of arguments', OK

557
00:34:15,690 --> 00:34:19,146
so it has found it and we've got the
wrong number of arguments in the constructor,

558
00:34:19,146 --> 00:34:21,400
so now I can go back and say:

559
00:34:28,710 --> 00:34:31,013
Now I hope to see a green test.

560
00:34:31,013 --> 00:34:32,440
DN: Yeah, great.

561
00:34:34,970 --> 00:34:39,560
TS: I've just realised that I've
powered on through this a long way

562
00:34:39,560 --> 00:34:44,173
and completely forgotten to make any
commits and that's now starting to make me nervous

563
00:34:44,173 --> 00:34:48,080
because I've just written a line
of actual code and I'm nervous about it.

564
00:34:50,310 --> 00:34:54,400
I'm going to deal with
that by opening a GNU screen.

565
00:34:55,970 --> 00:34:59,066
I'll still have Vim open but
I'm also going to have another terminal

566
00:34:59,066 --> 00:35:01,253
where I'm going to make some commits.

567
00:35:01,250 --> 00:35:07,026
Of course, this isn't even
a git repository!

568
00:35:07,813 --> 00:35:10,546
I'm not going to waste any time on this.

569
00:35:11,140 --> 00:35:17,533
I'm going to do some slightly more
coarse-grained commits than I'm happy with.

570
00:35:17,533 --> 00:35:19,240
So I'm now clean.

571
00:35:19,280 --> 00:35:23,613
I should have been in that situation
before but I got over excited by the problem!

572
00:35:23,680 --> 00:35:28,813
Let's go back and look at the test we were writing.

573
00:35:30,480 --> 00:35:32,600
I believe that's all fine.

574
00:35:32,620 --> 00:35:34,050
Everything is happy there.

575
00:35:37,480 --> 00:35:40,820
What I'd like to do now is
start building this functionality out.

576
00:35:43,570 --> 00:35:48,613
I can say, context when the tree is not empty.

577
00:35:51,140 --> 00:35:56,960
This is actually when the node has no children.

578
00:35:58,680 --> 00:36:00,370
I think that's more appropriate.

579
00:36:00,370 --> 00:36:01,413
DN: Yes.

580
00:36:02,080 --> 00:36:04,333
TS: And this is when the node has children.

581
00:36:09,420 --> 00:36:11,973
Oh... what a disaster.

582
00:36:21,540 --> 00:36:23,946
What I'd like to do here...

583
00:36:23,946 --> 00:36:26,120
and I don't know if I will stick with this,

584
00:36:26,120 --> 00:36:33,946
is to have a collection of test doubles.

585
00:36:34,786 --> 00:36:37,546
In fact that's not here, this is here.

586
00:36:37,540 --> 00:36:41,720
It is so I can give it an array
of something without having to

587
00:36:41,720 --> 00:36:43,650
then think about what those are.

588
00:36:43,650 --> 00:36:45,200
Anyway, see how far we can get.

589
00:36:52,880 --> 00:36:55,850
We've still got a very
basic level of functionality here.

590
00:36:57,340 --> 00:36:59,440
DN: Your missing a closing brace.

591
00:36:59,440 --> 00:37:01,440
TS: Yes, there.

592
00:37:02,200 --> 00:37:05,650
I'm expecting the evaluation
of that block not to raise an error.

593
00:37:06,280 --> 00:37:07,226
Great, OK.

594
00:37:10,020 --> 00:37:13,653
I've got my Node class, and I
can instantiate which is great.

595
00:37:14,250 --> 00:37:16,340
I can see here this is some duplication.

596
00:37:16,340 --> 00:37:21,466
So instead of having two
different things there I will pull up this.

597
00:37:24,940 --> 00:37:30,573
I'm defining children in both
cases but in one context it's empty

598
00:37:30,586 --> 00:37:32,573
and in another context it's not empty.

599
00:37:32,586 --> 00:37:37,853
That gives me a nice clean separation.

600
00:37:37,866 --> 00:37:40,200
Those two things are exactly the same.

601
00:37:42,680 --> 00:37:48,106
Ordinarily I would refactor this and
pull those out into a shared example group.

602
00:37:48,120 --> 00:37:52,613
If we duplicate a lot of examples here, I'll do that anyway.

603
00:37:53,850 --> 00:37:58,853
Now I want to think about what
my acceptance tests are demanding.

604
00:37:58,866 --> 00:38:01,140
I've run these unit tests a couple of times

605
00:38:01,770 --> 00:38:05,760
The acceptance tests were complaining
about was, you don't have a Node class.

606
00:38:05,810 --> 00:38:10,133
Now I have got the Node class,
it's time for me to step back up

607
00:38:10,140 --> 00:38:13,986
and run the cucumber
features again to see if I have finished,

608
00:38:13,986 --> 00:38:16,400
but I don't think I have.

609
00:38:17,110 --> 00:38:18,310
These are failing now.

610
00:38:18,310 --> 00:38:20,466
They are still complaining
that they can't find Node.

611
00:38:20,466 --> 00:38:26,440
and that's because I
need to make sure it's required.

612
00:38:26,770 --> 00:38:27,940
DN: In the environment.

613
00:38:27,940 --> 00:38:28,733
TS: Yes.

614
00:38:28,740 --> 00:38:35,386
So I'll say require and again I think cucumber
is going to put lib on the load path again.

615
00:38:40,170 --> 00:38:42,226
I've gone slightly wrong there.

616
00:38:42,466 --> 00:38:44,613
That's not supposed to be green.

617
00:38:46,220 --> 00:38:50,773
These step definitions, tree steps...

618
00:38:50,773 --> 00:38:53,213
DN: They don't actually do anything do they?

619
00:38:56,826 --> 00:39:00,773
TS: In order to show what I wanted the
structure to be here, this needs to be pending.

620
00:39:00,773 --> 00:39:02,426
because I'm not yet done with it.

621
00:39:07,800 --> 00:39:08,933
That's what I want.

622
00:39:08,930 --> 00:39:14,280
I should not have left these
step definitions that say nothing.

623
00:39:14,850 --> 00:39:18,213
So now it's saying you
haven't implemented these steps.

624
00:39:18,226 --> 00:39:22,013
sort by total number of descendants
or by the total number of terminals.

625
00:39:22,013 --> 00:39:26,666
Now I can think in terms
of being a client of this API

626
00:39:26,773 --> 00:39:28,586
What do I want this to look like.

627
00:39:28,586 --> 00:39:32,346
So I've got my collection of trees,
which I've just assumed is an array,

628
00:39:32,346 --> 00:39:34,050
but I think that's reasonable.

629
00:39:36,220 --> 00:39:40,866
If someone gave me this API and
said you've got a collection of trees,

630
00:39:41,020 --> 00:39:44,466
and I have implemented an API, for the trees.

631
00:39:44,460 --> 00:39:47,720
and now I want you to sort
them by the number of descendants,

632
00:39:47,733 --> 00:39:49,146
or the number of terminals.

633
00:39:49,450 --> 00:39:52,560
I would expect there to be a method on each tree

634
00:39:52,573 --> 00:39:54,693
that I can call that would give me a number back,

635
00:39:54,690 --> 00:40:04,640
that would say how many... trees equals
trees sort... by something...

636
00:40:05,266 --> 00:40:07,440
it will either be number of...

637
00:40:07,710 --> 00:40:11,240
It's tempting to call it 'number of descendants'.

638
00:40:13,680 --> 00:40:16,906
But I'm wondering if it should be descendants_count.

639
00:40:16,900 --> 00:40:18,560
DN: Sure, yes.

640
00:40:19,620 --> 00:40:23,880
Maybe that would be nicer, it's a bit more idiomatic.

641
00:40:25,200 --> 00:40:29,293
But then again, it's at odds with the
language being used here, so I'm not sure about that.

642
00:40:29,306 --> 00:40:32,760
I might revisit that later.

643
00:40:37,000 --> 00:40:40,346
I would like it so that...

644
00:40:40,800 --> 00:40:47,800
I can call descendants_count or
terminals_count on each node in that collection,

645
00:40:47,813 --> 00:40:51,146
it would give me a number back
and then it's going to sort the collection

646
00:40:51,146 --> 00:40:54,533
If I run one of my Cucumber features now.

647
00:40:54,740 --> 00:40:57,426
I would expect to see actual failures.

648
00:40:57,420 --> 00:41:02,893
This is complaining about
undefined method descendants_count

649
00:41:02,890 --> 00:41:04,920
and undefined method terminals-count.

650
00:41:07,506 --> 00:41:09,220
Again I've charged ahead here.

651
00:41:11,340 --> 00:41:14,066
Let's be a bit more meticulous.

652
00:41:14,066 --> 00:41:23,293
So this is: "Add instantiation
example for Node with children"

653
00:41:26,373 --> 00:41:37,666
And this is: "Load Node class
for duration of cucumber features"

654
00:41:37,660 --> 00:41:42,880
DN: Your commits sometimes have more text in
the commit message than what is to be committed.

655
00:41:42,906 --> 00:41:47,510
TS: Right, I find that to be
the most useful way of doing it.

656
00:41:48,540 --> 00:41:50,520
So let's see, what did I do here?

657
00:41:50,840 --> 00:41:52,480
I want to split that.

658
00:41:52,770 --> 00:41:54,626
I'm going to commit this change.

659
00:41:56,960 --> 00:42:00,746
"Mark then step as pending."

660
00:42:01,386 --> 00:42:04,370
Which should have been pending in the first place.

661
00:42:06,520 --> 00:42:15,146
Now this: "Is implement
when step for sorting collections"

662
00:42:16,760 --> 00:42:18,773
All clean again, I can relax.

663
00:42:19,000 --> 00:42:21,110
All of the stuff in my gutter goes away.

664
00:42:21,110 --> 00:42:23,480
DN: Yes, I wanted to draw attention to that.

665
00:42:23,493 --> 00:42:24,866
I think that's fabulous.

666
00:42:24,866 --> 00:42:27,360
TS: I think it's just called 'git gutter'.

667
00:42:29,910 --> 00:42:31,820
DN: Do you always have that enabled?

668
00:42:31,820 --> 00:42:32,420
TS: Yes.

669
00:42:32,910 --> 00:42:37,893
DN: I noticed it and I wondered
if it had crept in at some point.

670
00:42:38,170 --> 00:42:40,820
TS: It only creeps in if there is something to show.

671
00:42:40,820 --> 00:42:44,053
so if I make a change the gutter will appear.

672
00:42:44,066 --> 00:42:46,980
If I then make a change back so that git says

673
00:42:46,986 --> 00:42:48,413
there's no change it disappears again.

674
00:42:48,410 --> 00:42:52,826
DN:  I think the reason we didn't see it for
so long is because you didn't commit anything.

675
00:42:52,820 --> 00:42:54,706
Everything was added, and new.

676
00:42:55,540 --> 00:43:02,453
TS: The reason why I didn't make those commits
is because I forgot to 'git init' in the beginning.

677
00:43:02,466 --> 00:43:05,893
Now I find I don't remember to make commits.

678
00:43:05,890 --> 00:43:10,773
It's the stuff in the gutter that reminds me it's starting to get a bit dirty.

679
00:43:16,360 --> 00:43:18,600
DN: How much noise in the gutter can you tolerate?

680
00:43:18,600 --> 00:43:22,026
TS: Not very much.

681
00:43:22,026 --> 00:43:25,400
Ordinarily I like to make
commits as frequently as possible.

682
00:43:25,940 --> 00:43:28,000
Very small commits I can get away with.

683
00:43:28,000 --> 00:43:33,213
And as you say quite often the message
is longer than the content of the commit.

684
00:43:33,370 --> 00:43:43,400
The problem here is that we don't have
a terminals_count, or a descendants_count method.

685
00:43:50,170 --> 00:43:53,880
This makes me realise that I'm
trying to do two scenarios at the same time.

686
00:43:53,890 --> 00:43:57,533
I would like to focus on just one.

687
00:43:57,866 --> 00:44:01,340
TS: I don't want to be simultaneously implementing

688
00:44:01,340 --> 00:44:03,740
number of descendants and number of terminals.

689
00:44:03,740 --> 00:44:06,053
I'd rather just look at this one.

690
00:44:06,140 --> 00:44:07,450
I'm going to temporarily...

691
00:44:11,746 --> 00:44:18,260
comment out terminal sorting scenario.

692
00:44:18,510 --> 00:44:20,420
There are better ways of doing that.

693
00:44:20,420 --> 00:44:23,986
With Cucumber you can tag scenarios
so you don't have to run them but...

694
00:44:24,540 --> 00:44:27,626
this is the simplest thing to do.

695
00:44:27,626 --> 00:44:30,240
I mustn't forget about that

696
00:44:30,250 --> 00:44:33,066
but, as long as I don't forget about
it, it's going to give me the opportunity

697
00:44:33,066 --> 00:44:37,613
to run through getting
the descendants count to work.

698
00:44:38,740 --> 00:44:44,146
I'm going to switch back to my
node spec and have a look at doing that.

699
00:44:51,786 --> 00:44:58,200
So now I need to start making some
decisions around how to even set up the test.

700
00:44:58,620 --> 00:45:00,940
because what I want
here is something like:

701
00:45:01,906 --> 00:45:10,586
context 'when the Node
has five descendants'

702
00:45:11,340 --> 00:45:15,986
And then I want something here
that's like the Node is something here

703
00:45:15,986 --> 00:45:19,306
and then it has five descendants.

704
00:45:19,853 --> 00:45:26,146
And then this would say
expect Node descendant_count.

705
00:45:26,146 --> 00:45:28,510
Which is what we said in the step definition.

706
00:45:28,853 --> 00:45:32,026
Node descendant count to be equal to 5.

707
00:45:32,540 --> 00:45:34,320
So I know what the example is.

708
00:45:36,450 --> 00:45:39,600
I'm not quite sure exactly what I want to do here....

709
00:45:43,220 --> 00:45:45,693
because I've got doubles here.

710
00:45:47,280 --> 00:45:52,333
If I just make real instances of node, I could
already build you a tree that has five descendants

711
00:45:52,333 --> 00:45:56,933
because we had a similar one in the step definition.

712
00:45:56,946 --> 00:46:01,413
So I know how to make <i>real</i> trees with 5 descendants.

713
00:46:02,853 --> 00:46:07,026
If I want the children of this
node to be the test doubles,

714
00:46:07,080 --> 00:46:16,746
then I need to work out what it is
that makes this fake tree have five descendants.

715
00:46:27,110 --> 00:46:31,813
This feels like it should be a recursive method.

716
00:46:31,910 --> 00:46:35,973
The number of descendants of
a tree is the number of descendants

717
00:46:35,973 --> 00:46:39,973
of all of its subtrees plus the node at the top.

718
00:46:40,180 --> 00:46:45,733
If I've got three children and each
one of them has three descendants in it,

719
00:46:45,800 --> 00:46:50,213
then I've got 3 + 3 + 3 = 9
descendants, plus myself is 10.

720
00:46:51,850 --> 00:46:54,940
That's a very obvious
structure for solving the problem.

721
00:47:02,570 --> 00:47:04,213
I'm getting slightly ahead of myself here.

722
00:47:04,210 --> 00:47:08,720
It would be nice to say "it has
no descendants" for the empty one.

723
00:47:08,740 --> 00:47:10,540
because I can avoid that problem.
I can just say:

724
00:47:10,540 --> 00:47:29,480
expect Node.new(children).descendant_count
to be equal to zero

725
00:47:30,400 --> 00:47:34,480
You can see when I press leader 'S' there,
it's set up RSpec to only run that line.

726
00:47:34,480 --> 00:47:37,470
So now it's saying 'undefined
method descendant_count for node'

727
00:47:37,470 --> 00:47:42,360
and then I can easily
go in here and say...

728
00:47:44,773 --> 00:47:46,453
Just return zero.

729
00:47:47,340 --> 00:47:52,680
So if I now do leader 'L' to run my last focus test It runs just that example.

730
00:47:58,820 --> 00:48:01,546
I can make that work quite easily here.

731
00:48:02,340 --> 00:48:06,066
I can't make it work so easily down
here, because what does it mean

732
00:48:08,253 --> 00:48:11,173
for the tree to have five descendants.

733
00:48:14,800 --> 00:48:17,560
This does go slightly counter to the way I want to write tests

734
00:48:17,586 --> 00:48:20,706
but I think in terms of expediency it's going
to be quicker for me

735
00:48:20,730 --> 00:48:23,093
to just make a real tree here because

736
00:48:23,093 --> 00:48:26,546
I've already written the tree
helper that knows how to do that.

737
00:48:26,850 --> 00:48:31,066
And I've already got some
examples from the Cucumber step.

738
00:48:32,050 --> 00:48:36,760
I think that slightly subverts
the notion of it being a unit test,

739
00:48:36,893 --> 00:48:40,020
because although I'm only testing one method here,

740
00:48:41,370 --> 00:48:43,910
I'll end up testing it against multiple objects.

741
00:48:44,510 --> 00:48:48,000
If I didn't have a time limit, I
would like to spend some time

742
00:48:48,013 --> 00:48:50,640
investigating what would
be the consequences of me

743
00:48:51,250 --> 00:48:53,480
trying to do all of this with test doubles.

744
00:48:54,170 --> 00:48:58,666
But my instinct tells me that
I might get a bit tied in knots.

745
00:49:00,250 --> 00:49:04,093
So for this specific example, I
shall err on the side of 'quickness'

746
00:49:04,400 --> 00:49:08,640
and have a look at the tree steps here.

747
00:49:09,740 --> 00:49:12,250
I already have a tree here with 5 descendants

748
00:49:12,740 --> 00:49:14,266
this wide tree.

749
00:49:16,620 --> 00:49:21,986
So I can go here and say...

750
00:49:24,050 --> 00:49:25,170
What do I want to do?

751
00:49:27,600 --> 00:49:29,540
It's going to be something like this:

752
00:49:32,850 --> 00:49:34,146
Let's get rid of this.

753
00:49:34,400 --> 00:49:38,066
That's going to give me a node
that really does have five descendants.

754
00:49:38,066 --> 00:49:38,413
DN: Yes.

755
00:49:38,413 --> 00:49:40,910
And then this is going to say check that it does.

756
00:49:41,340 --> 00:49:44,786
If I already knew how
descendant_count was going to work...

757
00:49:52,613 --> 00:49:54,213
I'm really conflicted about this!

758
00:49:54,210 --> 00:49:56,573
Let's just see what happens
if I say let node be...

759
00:50:02,530 --> 00:50:07,413
I would like to get my head around
if this is the right decision or not.

760
00:50:07,620 --> 00:50:11,880
So, if I run this, firstly the
answer is going to be wrong.

761
00:50:12,280 --> 00:50:15,013
It's going to say, "expected five and I got none".

762
00:50:16,453 --> 00:50:18,620
DN: Where is children coming from there?

763
00:50:18,620 --> 00:50:21,226
TS: Children is coming from here.

764
00:50:24,253 --> 00:50:27,386
It walks up until it finds a place
where that has been defined.

765
00:50:27,400 --> 00:50:30,826
So I'm still using this as several test doubles.

766
00:50:34,340 --> 00:50:38,400
I may decide to put 'let children' inside here and then it would provide...

767
00:50:39,200 --> 00:50:41,133
DN: A locally scoped version?

768
00:50:41,130 --> 00:50:42,026
TS: Yes, exactly.

769
00:50:43,940 --> 00:50:46,373
That's the wrong answer, expected five, got zero.

770
00:50:47,020 --> 00:50:51,266
Now I can start thinking
about how I want this to work.

771
00:50:51,310 --> 00:50:56,546
well the most obvious thing that I
need is to remember what the children are.

772
00:50:57,800 --> 00:51:00,160
And I guess this could be
something like...

773
00:51:01,853 --> 00:51:07,586
If children is empty, then zero.

774
00:51:08,420 --> 00:51:11,213
Is that right? Oh well...

775
00:51:11,373 --> 00:51:15,040
Yes... No... (laughter).

776
00:51:20,506 --> 00:51:24,386
It's a little difficult
because this method needs to...

777
00:51:26,800 --> 00:51:29,320
We need to subtract one from it,

778
00:51:29,320 --> 00:51:30,080
DN: Right.

779
00:51:30,080 --> 00:51:31,960
Only once, right at the end.

780
00:51:31,970 --> 00:51:36,333
So if we call it on the root node of a
tree, it needs to walk down through the tree

781
00:51:36,346 --> 00:51:38,133
adding up how many nodes there are.

782
00:51:38,140 --> 00:51:40,680
And then we subtract one from it right at the end.

783
00:51:40,693 --> 00:51:41,106
DN: Yes.

784
00:51:48,450 --> 00:51:50,573
It now occurs to me that I'm not sure.

785
00:51:50,573 --> 00:51:53,653
Oh, descendant count of zero
for the empty node is correct

786
00:51:53,666 --> 00:51:55,706
because there's just the root node.

787
00:51:55,706 --> 00:51:57,226
DN: Yes.

788
00:52:00,400 --> 00:52:02,920
Let's leave that as it was, I don't think that's right.

789
00:52:03,480 --> 00:52:05,200
So if it has got several children

790
00:52:05,400 --> 00:52:08,253
in my head, the general pattern that we want here

791
00:52:08,253 --> 00:52:13,040
is to take all the children
and call descendant_count on them.

792
00:52:14,400 --> 00:52:18,800
And when I know how many descendants all
of the children have I want to add one to that.

793
00:52:20,110 --> 00:52:20,800
DN: Right.

794
00:52:22,310 --> 00:52:24,600
The one whose
children you're asking about?

795
00:52:24,600 --> 00:52:26,240
TS: Yes. The current node.

796
00:52:27,170 --> 00:52:30,140
If I collect all the
descendant counts and add them up,

797
00:52:30,770 --> 00:52:33,973
by using inject plus, and then I have one

798
00:52:34,110 --> 00:52:36,310
and that's kind of the answer that I want.

799
00:52:36,310 --> 00:52:39,280
Or at least that's the
answer I want in the recursive case.

800
00:52:41,420 --> 00:52:44,710
I haven't been called
recursively as part of this procedure,

801
00:52:44,733 --> 00:52:47,080
the root node, I need to subtract one from it.

802
00:52:47,080 --> 00:52:49,340
I need to think more carefully about this.

803
00:52:53,420 --> 00:52:58,866
Hopefully that will be born out by
the fact that here we would want all of these

804
00:53:00,306 --> 00:53:02,333
to return that it has five descendants.

805
00:53:02,330 --> 00:53:05,866
Right now it won't because
we've got the wrong code.

806
00:53:07,600 --> 00:53:08,973
Let's run that last test.

807
00:53:20,450 --> 00:53:24,720
There's our first problem, that
because all the children are just test doubles.

808
00:53:25,880 --> 00:53:30,253
They've all just returned... in
fact I haven't made any effort to...

809
00:53:30,250 --> 00:53:34,080
At the moment I've just
got these three dumb children.

810
00:53:34,570 --> 00:53:41,306
So why don't I set up a situation
that looks like the tree we had here.

811
00:53:41,450 --> 00:53:44,053
Which was... there would be five of these

812
00:53:47,940 --> 00:53:49,853
It would be quicker to just say...

813
00:53:52,450 --> 00:53:57,786
if I want five children the
easiest way to do that is 5 x map.

814
00:53:59,650 --> 00:54:03,853
Whatever is in this block will get
evaluated five times, and put into an array.

815
00:54:06,520 --> 00:54:09,373
I can use RSpec 3's verifying doubles for this.

816
00:54:09,400 --> 00:54:11,400
I can say 'instance double'.

817
00:54:11,850 --> 00:54:14,960
I want to have a double for
an instance of the node class.

818
00:54:14,973 --> 00:54:17,970
And what this will do is, if the node class is loaded

819
00:54:17,970 --> 00:54:23,213
it will check whatever stub
methods I put on this double actually exist

820
00:54:23,220 --> 00:54:27,720
so it's checking that I'm not
stubbing out methods that don't exist.

821
00:54:28,306 --> 00:54:32,510
So in this case, I want
to stub out descendant_count.

822
00:54:32,800 --> 00:54:35,840
and I want that to be... new style

823
00:54:35,866 --> 00:54:40,026
I can say the descendant count
of each of these, needs to be one.

824
00:54:41,573 --> 00:54:45,226
I can already see that is not
going to give me the right answer.

825
00:54:45,226 --> 00:54:49,386
Because it adds one, I get six.

826
00:54:53,960 --> 00:54:59,573
DN: Just so I'm on the same page as
you here, you've created five instance doubles,

827
00:54:59,573 --> 00:55:01,650
each one is a node.

828
00:55:01,650 --> 00:55:04,110
And it's reporting that it has one descendant

829
00:55:04,110 --> 00:55:07,133
but actually that descendant is itself.

830
00:55:07,850 --> 00:55:10,546
Ah yes, of course, it's reporting to its parent.

831
00:55:10,800 --> 00:55:13,973
TS: Yes, so this is the problem,
is that...

832
00:55:14,770 --> 00:55:18,746
we've already said that an
empty node should have no descendants.

833
00:55:18,893 --> 00:55:20,170
That's returning zero.

834
00:55:20,170 --> 00:55:23,186
But to even get this started I'm
having to say that these nodes,

835
00:55:23,186 --> 00:55:26,850
which I'm thinking of being empty
ones, will have a descendant count of one.

836
00:55:27,706 --> 00:55:29,480
There's an impedance mismatch.

837
00:55:31,110 --> 00:55:33,910
Effectively you've got
two different methods here

838
00:55:33,920 --> 00:55:37,026
and we're trying to cram them into the same place.

839
00:55:37,026 --> 00:55:39,306
So I need to get rid of this.

840
00:55:39,910 --> 00:55:41,493
I need to fix this.

841
00:55:56,940 --> 00:55:59,786
I already feel confused by the test doubles.

842
00:55:59,780 --> 00:56:03,440
given that they weren't helping
me I'll get rid of them for now.

843
00:56:03,480 --> 00:56:05,520
If I can use them later, I will.

844
00:56:06,880 --> 00:56:10,533
This is going to help me think
through how we want this to behave

845
00:56:10,530 --> 00:56:14,040
because up here we've got a real
instance of a node with no children

846
00:56:14,140 --> 00:56:17,360
and it's giving the right answer.

847
00:56:17,510 --> 00:56:21,626
Now we've got a real instance of node
and we want to see what the answer is.

848
00:56:22,320 --> 00:56:23,620
Let's just see.

849
00:56:25,250 --> 00:56:29,693
So now this is saying we
don't have that build_tree helper.

850
00:56:29,720 --> 00:56:33,026
So I need to require that.

851
00:56:33,540 --> 00:56:36,746
I think it's up in features support.

852
00:56:37,546 --> 00:56:38,960
Trees helper.

853
00:56:40,820 --> 00:56:46,840
And then I need to include a module in my RSpec file.

854
00:56:47,110 --> 00:56:50,080
I don't have a great way of having test helpers

855
00:56:50,093 --> 00:56:52,970
that are available in both
RSpec and Cucumber features.

856
00:56:52,970 --> 00:56:59,106
Usually because, when I'm writing a unit
test I wouldn't want these helpers that build

857
00:56:59,250 --> 00:57:00,640
huge trees of real objects.

858
00:57:00,640 --> 00:57:02,546
But... that's what we've got.

859
00:57:06,520 --> 00:57:08,053
Why has that worked?

860
00:57:08,770 --> 00:57:13,133
Expect descendant count to be
five. Ok, I've done the wrong thing.

861
00:57:13,133 --> 00:57:16,266
expected five and got one, and
I think the reason why we've got one

862
00:57:16,740 --> 00:57:19,250
is because the subtrees have all returned zero

863
00:57:19,250 --> 00:57:20,850
DN: And then we've added one to it.

864
00:57:20,850 --> 00:57:21,310
TS: Yes.

865
00:57:21,320 --> 00:57:27,320
So I think that we need to have
one method that we call from the outside,

866
00:57:27,333 --> 00:57:29,986
which is going to be descendant_count.

867
00:57:29,986 --> 00:57:32,760
And a different method that is used...

868
00:57:35,440 --> 00:57:37,910
This code here is going to be something else.

869
00:57:39,266 --> 00:57:40,293
DN: I see.

870
00:57:41,420 --> 00:57:46,200
And this thing here can be 'something else' minus one.

871
00:57:46,770 --> 00:57:47,666
DN: OK.

872
00:57:47,710 --> 00:57:54,840
Because when you call this you want
it to count all the... what did we call them?

873
00:57:56,000 --> 00:57:58,400
This is almost like... 'node count'.

874
00:57:58,880 --> 00:58:04,933
You want it to count all of the nodes,
including itself and then disregard itself.

875
00:58:06,020 --> 00:58:06,933
I think!

876
00:58:07,800 --> 00:58:10,533
This may be stupid but let's see what happens.

877
00:58:13,250 --> 00:58:15,140
This I think, does the correct thing.

878
00:58:20,170 --> 00:58:21,893
So this needs to be one.

879
00:58:21,900 --> 00:58:25,560
So what we are trying to ask is
how many nodes in total are in the tree.

880
00:58:25,580 --> 00:58:29,200
So if I don't have any children
there's just the one, that's me.

881
00:58:29,200 --> 00:58:34,093
and if I have some children then
I have all my childrens' nodes and myself.

882
00:58:34,093 --> 00:58:37,920
So I'm always adding one,
and at the end you subtract one.

883
00:58:39,360 --> 00:58:44,146
So if I run my unit tests... expected five, got zero.

884
00:58:47,053 --> 00:58:50,653
That's not what I was expecting.
Ah... it's because I forgot to change this.

885
00:58:52,140 --> 00:58:55,240
So we have to call that
node_count method recursively

886
00:58:55,250 --> 00:58:59,426
Now, it will correctly count all of the nodes.

887
00:58:59,420 --> 00:59:05,200
Now is this silly... I don't think so.

888
00:59:08,020 --> 00:59:11,280
There are other ways that we
can arrange this, but I think this is fine.

889
00:59:11,293 --> 00:59:13,170
I think this is just as good.

890
00:59:14,250 --> 00:59:19,186
It's slightly awkward that we
have these two ways of doing it.

891
00:59:23,226 --> 00:59:28,613
But this is an inevitable consequence
of saying that the root node is not...

892
00:59:28,613 --> 00:59:29,786
Actually...

893
00:59:33,740 --> 00:59:36,173
Maybe there is a better way of doing this.

894
00:59:36,840 --> 00:59:38,520
We can do a bit of refactoring here.

895
00:59:38,546 --> 00:59:42,520
Let me make a commit because
I've definitely done some work.

896
00:59:46,140 --> 00:59:47,910
I've got something that works now.

897
00:59:48,133 --> 00:59:59,173
So I will just say implement node descendant_count.

898
00:59:59,540 --> 01:00:05,613
There is a smarter way which is to always
think about the descendant count being...

899
01:00:06,740 --> 01:00:09,226
How many nodes are there apart from me.

900
01:00:09,317 --> 01:00:13,989
For whatever reason, my intuitive idea of
what descendant count was doing

901
01:00:15,180 --> 01:00:19,653
would be including the... It would
be like self AND descendant count

902
01:00:19,660 --> 01:00:24,160
But that's not what you want you
want to know how many children there are

903
01:00:24,180 --> 01:00:29,080
and how many children of
children there are, not counting myself.

904
01:00:31,850 --> 01:00:33,933
If I do this descendant count...

905
01:00:33,940 --> 01:00:38,333
could I say,'if I don't have any
children then there are zero descendants".

906
01:00:38,340 --> 01:00:44,426
If I do have some children I then add
up the descendants each of them have

907
01:00:44,420 --> 01:00:47,080
then I add how many children I have.

908
01:00:48,220 --> 01:00:57,600
So this would be children.size and
then I think that does the same thing.

909
01:00:57,613 --> 01:00:59,440
That's slightly nicer.

910
01:01:00,080 --> 01:01:07,200
I hadn't thought of that as being a
way of adding them up but I think it works.

911
01:01:09,560 --> 01:01:14,240
It's a problem that you have to
call size on the collection of children.

912
01:01:14,250 --> 01:01:17,613
Whereas, previously we didn't
have to do that, you got that for free,

913
01:01:17,626 --> 01:01:22,786
because every child was returning
'one'. If they included themselves anyway.

914
01:01:22,780 --> 01:01:25,693
Now we have to have an
awareness of how many children we have.

915
01:01:25,706 --> 01:01:29,173
I think that's why I avoided that.

916
01:01:31,400 --> 01:01:33,680
DN: Yes, well there's only question to ask.

917
01:01:33,693 --> 01:01:38,370
TS: This is the best way of representing what you wanted.

918
01:01:38,370 --> 01:01:39,220
DN: Right.

919
01:01:41,050 --> 01:01:46,666
TS: The examples are passing the test.

920
01:01:51,770 --> 01:01:55,933
I might stick one more in
here. Given that we've got them.

921
01:01:57,093 --> 01:02:02,890
I said I thought this one had twelve.
So let's find out if it does in fact, have twelve.

922
01:02:03,666 --> 01:02:05,620
DN: It definitely has many. TS: Yes.

923
01:02:32,200 --> 01:02:36,160
So this one is going to be it has twelve.

924
01:02:48,450 --> 01:02:51,053
I was right, it does have twelve!

925
01:02:54,570 --> 01:03:00,666
Although I am uncomfortable with the use of
the real instances here, I think I'm going to carry on

926
01:03:00,770 --> 01:03:04,360
because for the purposes of what we are doing here,

927
01:03:04,386 --> 01:03:08,933
I don't think it would be
interesting for me to fix that problem.

928
01:03:08,970 --> 01:03:13,880
Now I've decided how this works I could go
back and instead of having real instances here

929
01:03:13,880 --> 01:03:17,413
I could just have doubles, so
that here, I just need three children

930
01:03:17,426 --> 01:03:20,920
that each say they have four descendants.

931
01:03:20,960 --> 01:03:23,400
So I don't need the real instances here.

932
01:03:23,970 --> 01:03:28,333
but I've already 'flip flopped' on that a
bit so I'm just going to move on with my life.

933
01:03:29,800 --> 01:03:32,240
I've only tested descendant count three times there

934
01:03:32,240 --> 01:03:35,346
but that's giving me
confidence, that it's not totally wrong.

935
01:03:36,893 --> 01:03:40,426
All of these trees are pretty much symmetric.

936
01:03:42,910 --> 01:03:45,340
All of the children look the same in each tree.

937
01:03:45,340 --> 01:03:48,840
This one has got three
children which are all four deep.

938
01:03:49,400 --> 01:03:54,306
I think I'm confident enough that
that's not a problem, so I'm going to carry on.

939
01:03:54,650 --> 01:03:57,586
Let's run the Cucumber features and see where we are.

940
01:03:58,680 --> 01:04:01,140
Undefined method descendants count for node.

941
01:04:01,730 --> 01:04:05,840
Why has that happened? Is
it because it's descendant count.

942
01:04:11,450 --> 01:04:16,026
I think descendant count is the
name I want that method to have.

943
01:04:17,340 --> 01:04:21,320
When I was writing the acceptance
test I did write descendants count.

944
01:04:24,170 --> 01:04:26,250
DN: That's an easy refactoring to change.

945
01:04:31,080 --> 01:04:35,546
TS: The reason I wrote descendants
there was because I'd written descendants here.

946
01:04:35,650 --> 01:04:38,220
We've got the word descendants all over the place.

947
01:04:41,200 --> 01:04:48,080
But this feels more idiomatically
Ruby to me, that's just my instinct.

948
01:04:49,370 --> 01:04:50,360
Let's run them.

949
01:04:54,110 --> 01:04:57,533
DN: The pending one is the one we
don't care about at the moment isn't it?

950
01:04:57,546 --> 01:04:59,440
TS: Yes, sure.

951
01:05:00,050 --> 01:05:08,586
I'm going to add this change and say:
Consolidate descendent_count and node count

952
01:05:10,653 --> 01:05:18,146
And say: "Add extra example
of descendant_count"

953
01:05:20,253 --> 01:05:27,266
And here: "Change expected method names"

954
01:05:31,650 --> 01:05:34,080
I think we can power through the rest of it now.

955
01:05:34,080 --> 01:05:38,840
So now we say the collection should be
ordered by the total number of descendants.

956
01:05:38,840 --> 01:05:38,853
That means we are going to start
putting some code in here which says:
So now we say the collection should be
ordered by the total number of descendants.

957
01:05:38,853 --> 01:05:42,506
That means we are going to start
putting some code in here which says:

958
01:05:42,506 --> 01:05:49,626
expect(@trees).to be equal to something.

959
01:05:49,620 --> 01:05:57,693
So if we've sorted them by
descendant_count we expect to see

960
01:05:58,710 --> 01:06:00,320
@just_one_node which has no descendants.

961
01:06:01,050 --> 01:06:03,453
A @deep_tree which has four.

962
01:06:04,173 --> 01:06:06,520
A @wide_tree which has five.

963
01:06:08,250 --> 01:06:10,413
and @deep_wide_tree which has twelve.

964
01:06:10,910 --> 01:06:12,040
So let's run that.

965
01:06:14,540 --> 01:06:17,570
I got that green before but I didn't deserve it.

966
01:06:17,570 --> 01:06:20,853
In fact because I didn't
deserve it I'll put pending in here.

967
01:06:37,450 --> 01:06:39,293
So, I think we finished that.

968
01:06:40,710 --> 01:06:47,013
I'll just go back here and...
uncomment that

969
01:06:48,450 --> 01:06:49,573
and now we've got...

970
01:06:50,340 --> 01:06:53,240
sort the collection by terminals is failing.

971
01:06:54,080 --> 01:06:57,106
Ok, so I'm hoping we can pick up the pace a bit now.

972
01:06:58,320 --> 01:07:00,050
What situation are we in?

973
01:07:00,770 --> 01:07:06,026
Undefined method terminal count,
I can start writing specs around that.

974
01:07:06,026 --> 01:07:08,133
For the moment I don't have any.

975
01:07:11,770 --> 01:07:17,013
So if we've only got a single node. It has no terminals

976
01:07:38,940 --> 01:07:41,140
It's complaining about undefined method.

977
01:07:42,746 --> 01:07:44,160
I've done with that.

978
01:07:49,850 --> 01:07:53,840
If we just have that return zero,
at least that example will pass

979
01:07:53,866 --> 01:07:55,920
and that's not broken anything.

980
01:08:05,110 --> 01:08:07,370
Now we have to do something more difficult.

981
01:08:07,370 --> 01:08:10,440
Which is... how does this work...

982
01:08:10,440 --> 01:08:13,493
It has no terminals.

983
01:08:15,760 --> 01:08:21,266
This is the tree with five. The flat tree.

984
01:08:21,620 --> 01:08:23,110
That's going to work as well.

985
01:08:24,420 --> 01:08:25,510
DN: With no extra work.

986
01:08:25,510 --> 01:08:27,850
TS: Yes that's great, and we can just stop there!

987
01:08:30,020 --> 01:08:35,986
This is going to be more challenging.
It has three terminals, is that right?

988
01:08:36,013 --> 01:08:37,066
DN: Yes.

989
01:08:37,773 --> 01:08:42,220
We're expecting the node
terminal count to be equal to three.

990
01:08:49,890 --> 01:08:51,253
Let's run this one.

991
01:08:53,570 --> 01:08:56,186
Expected three, got zero.

992
01:09:03,620 --> 01:09:06,133
What do I want to do here?

993
01:09:07,970 --> 01:09:10,880
I'm counting how many leaves there are.

994
01:09:17,820 --> 01:09:21,640
But I only want the leaves
that are at the maximum depth.

995
01:09:21,820 --> 01:09:23,120
DN: That's right, yes.

996
01:09:28,510 --> 01:09:34,306
TS: That gives me the idea of having another method,

997
01:09:34,346 --> 01:09:40,690
that can be called leaf_count,
that takes a depth argument.

998
01:09:47,710 --> 01:09:50,170
We're going to have some kind of maximum depth.

999
01:10:03,080 --> 01:10:09,186
I think it would be easier for me if I
thought of depth in the way that I talked about it.

1000
01:10:09,200 --> 01:10:14,520
Actually, no let's go with your method
definition. We just have to make it work.

1001
01:10:16,370 --> 01:10:18,540
If we want to refactor it then we can do so.

1002
01:10:20,110 --> 01:10:21,680
DN: I'm being an awkward client.

1003
01:10:21,680 --> 01:10:23,250
TS: Yes this is very realistic.

1004
01:10:23,250 --> 01:10:24,920
DN: Use my language! (laughter)

1005
01:10:24,946 --> 01:10:31,920
TS: So in that case, terminal count will just be
count all of the leaves that are at depth MAX_DEPTH.

1006
01:10:38,910 --> 01:10:44,613
This just gives me an 'in' because
terminal count is one of those things

1007
01:10:44,653 --> 01:10:47,610
that we're not going to be able to call recursively.

1008
01:10:47,610 --> 01:10:55,760
we're not going to be able to say on the child nodes
"Tell me how many terminal nodes are inside you".

1009
01:10:56,200 --> 01:10:59,786
Because the child doesn't
know where it is in the tree.

1010
01:11:00,250 --> 01:11:05,053
It doesn't have a link to its
parent. It just contains children.

1011
01:11:06,820 --> 01:11:11,706
The reason I'm doing this is because
I can define leaf count recursively.

1012
01:11:28,250 --> 01:11:38,346
If we don't have any children
then... If the depth argument is 1

1013
01:11:44,946 --> 01:11:48,540
The root node is at depth
one in your numbering system.

1014
01:11:48,540 --> 01:11:52,840
so the root is at depth one and a child is at depth two

1015
01:11:52,880 --> 01:11:55,480
and another child is at depth three, four and five.

1016
01:11:55,480 --> 01:11:56,386
DN: Yes.

1017
01:11:56,400 --> 01:12:06,626
TS: If you are at depth one, and you're
a leaf then you are what we are looking for.

1018
01:12:06,640 --> 01:12:07,080
DN: Yes.

1019
01:12:07,080 --> 01:12:10,813
So you say count how many leaves
there are and if you are already a leaf,

1020
01:12:12,050 --> 01:12:15,560
and we're looking for things
that are at depth one, then return one.

1021
01:12:15,746 --> 01:12:18,066
Because that's what you are yourself.

1022
01:12:18,140 --> 01:12:22,173
Otherwise, for leaves at
some other depth return zero.

1023
01:12:23,880 --> 01:12:28,826
And in the recursive case, I
think we want to do something similar.

1024
01:12:29,020 --> 01:12:33,280
We want to say children map.
This is going to be more complicated.

1025
01:12:33,290 --> 01:12:36,413
Child leaf count.

1026
01:12:42,170 --> 01:12:49,680
As we recursively walk down, we say
now I am looking for things at one level lower.

1027
01:12:49,693 --> 01:12:52,600
So the root node is looking for leaves at depth five.

1028
01:12:52,600 --> 01:12:57,573
But when it asks all of its children it says
"do you guys have any leaf descendants at depth four

1029
01:12:57,586 --> 01:13:02,013
because if you do that's depth five with respect to me".

1030
01:13:06,400 --> 01:13:10,266
So we get all of the child leaf counts and add them up.

1031
01:13:14,340 --> 01:13:17,480
Let's try running that last test. That passes.

1032
01:13:17,710 --> 01:13:19,826
If I run all the tests.

1033
01:13:19,820 --> 01:13:22,946
Got a failure, "Double received unexpected message: leaf_count"

1034
01:13:22,946 --> 01:13:26,800
This is the sort of thing I was talking about.

1035
01:13:26,800 --> 01:13:31,746
The fact that there's a failure there
is fine, because it's what guides me

1036
01:13:31,760 --> 01:13:35,600
to stubbing methods out of my
test doubles and then gives me feedback

1037
01:13:35,600 --> 01:13:38,093
on what the API of those objects should be.

1038
01:13:38,093 --> 01:13:42,480
However in this case those objects
are all  instances of the same class as me.

1039
01:13:44,480 --> 01:13:52,320
For the purpose of expediency I think it would
be quicker to make these instances of node.

1040
01:13:56,650 --> 01:13:58,800
What was actually the source of that?

1041
01:13:59,060 --> 01:14:02,200
This says... this is line 38.

1042
01:14:05,240 --> 01:14:06,600
Expect no new children.

1043
01:14:07,710 --> 01:14:11,906
I'm asking for the terminal count and
now I realise what I should  have been doing.

1044
01:14:11,900 --> 01:14:15,480
Everything I said was nonsense.
This should have just been node.

1045
01:14:15,570 --> 01:14:21,440
I already tried not to use these test doubles
in places where I was calling real methods.

1046
01:14:21,540 --> 01:14:25,770
Those were just for the purposes
of creating the...

1047
01:14:28,910 --> 01:14:31,973
So all of those tests are passing.

1048
01:14:34,770 --> 01:14:37,866
I feel moderately confident that that is correct.

1049
01:14:38,770 --> 01:14:45,386
In which case, let's go
back to the Cucumber feature,

1050
01:14:45,450 --> 01:14:49,986
to see if we've done enough work in the
unit test to make the acceptance test pass.

1051
01:14:49,986 --> 01:14:52,000
We just haven't implemented this yet.

1052
01:14:55,480 --> 01:14:57,620
Perhaps we should have done that first.

1053
01:14:59,386 --> 01:15:03,000
This is expecting the trees to be...
what order do we want these to be in?

1054
01:15:05,680 --> 01:15:08,310
DN: Is it sorting from small to large at the moment?

1055
01:15:08,310 --> 01:15:08,910
TS: Yes.

1056
01:15:09,370 --> 01:15:13,893
DN: So it's not much different then
it will be just one node, wide tree.

1057
01:15:17,050 --> 01:15:18,746
Is that right?

1058
01:15:18,746 --> 01:15:20,013
TS: I think so yes.

1059
01:15:20,170 --> 01:15:21,880
DN: Deep tree then deep wide tree.

1060
01:15:22,340 --> 01:15:22,940
TS: Yes.

1061
01:15:32,310 --> 01:15:33,250
TS: Oh dear...

1062
01:15:37,620 --> 01:15:39,220
This is very difficult to read.

1063
01:15:39,400 --> 01:15:46,560
My immediate suspicion here is that it is to
do with the sort not being stable, as I mentioned

1064
01:15:46,650 --> 01:15:50,026
I can't read this output and
see what the difference is.

1065
01:15:50,400 --> 01:15:59,160
My intuition is that when you sort by terminal_count,
given we've got two nodes that have no terminals,

1066
01:15:59,170 --> 01:16:03,573
We know we want them to appear at the
beginning we just don't know which way around.

1067
01:16:03,586 --> 01:16:06,280
It's also fine for them to be the other way round.

1068
01:16:06,850 --> 01:16:14,133
If we wanted them to stay in the same order
in the array, we can't use Ruby's sort_by.

1069
01:16:15,480 --> 01:16:17,220
Well we can, but not out of the box.

1070
01:16:17,220 --> 01:16:20,400
We have to find a way to
preserve the original order of the list.

1071
01:16:20,400 --> 01:16:23,933
So that we can associate all of the elements
in the list with their original position

1072
01:16:23,933 --> 01:16:26,733
and then sort by a compound key.

1073
01:16:27,450 --> 01:16:30,666
Firstly sort by how many terminals they've got

1074
01:16:30,710 --> 01:16:35,893
and then by what their original
position in the list was so that is preserved.

1075
01:16:38,880 --> 01:16:42,666
DN: It's more likely that I
would be ordering them by quantity,

1076
01:16:42,666 --> 01:16:52,720
those with the greatest number, and things
that have no terminals is of no interest to me.

1077
01:16:52,730 --> 01:16:54,840
They are the ones I want to ignore.

1078
01:16:54,850 --> 01:17:00,013
You could even throw away the ones with zero terminals.

1079
01:17:01,860 --> 01:17:08,160
The kind of use I would have for this tree
structure, those with no terminals are of no interest.

1080
01:17:08,970 --> 01:17:12,170
TS: I will see if I can get
the existing test passing happily.

1081
01:17:12,170 --> 01:17:14,800
Then we can refine the requirements if we want to.

1082
01:17:15,000 --> 01:17:19,613
It's been too long since I committed.

1083
01:17:19,740 --> 01:17:22,813
So let's say...

1084
01:17:22,826 --> 01:17:27,740
I should have made this change first
incidentally, I just lost track of what we were doing.

1085
01:17:27,746 --> 01:17:33,450
Before I started dropping down to RSpec,
I should have allowed myself to see this fail,

1086
01:17:33,700 --> 01:17:38,106
and it would have indicated that
I needed to go down and write some unit tests.

1087
01:17:38,400 --> 01:17:46,000
I will say add scenario and step definition for checking.

1088
01:17:48,200 --> 01:17:52,800
Terminal checking sorting by terminals.

1089
01:17:54,220 --> 01:17:55,800
And then what have I done here?

1090
01:17:55,800 --> 01:18:02,226
This is just basically test
and implement terminal count.

1091
01:18:07,890 --> 01:18:11,533
That's slightly frustrating...

1092
01:18:12,310 --> 01:18:15,990
The best I can do here is to express our intent.
I should say:

1093
01:18:16,000 --> 01:18:33,720
expect the first two trees to contain
exactly @just_one_node and @wide_tree

1094
01:18:35,570 --> 01:18:43,053
That will verify that this collection here is
exactly two long, and has those two things in it.

1095
01:18:43,053 --> 01:18:45,480
But we don't care about the order.

1096
01:18:45,480 --> 01:18:48,080
Because we do care about the order of the rest of it.

1097
01:18:48,170 --> 01:18:55,813
I can say expect trees drop to
be exactly equal to that array.

1098
01:18:55,850 --> 01:19:01,453
This is a little bit clumsy, but it is at least expressing what we want.

1099
01:19:01,460 --> 01:19:04,506
You are saying you don't
care what order they come in,

1100
01:19:04,500 --> 01:19:07,666
so we will use a 'matcher' to
check they are in the order we want.

1101
01:19:07,666 --> 01:19:10,613
Whereas we do want the rest
of it to look exactly like that.

1102
01:19:10,613 --> 01:19:13,080
So, there we go.

1103
01:19:13,080 --> 01:19:14,213
DN: Very nice.

1104
01:19:15,250 --> 01:19:17,040
TS: We've got everything passing.

1105
01:19:17,050 --> 01:19:19,746
I want to go back and look at this.

1106
01:19:23,540 --> 01:19:25,310
We have definitely done this bit...

1107
01:19:25,310 --> 01:19:29,053
given a collection of trees
let me sort by these properties.

1108
01:19:29,586 --> 01:19:31,050
We haven't modeled...

1109
01:19:31,050 --> 01:19:35,106
This max-depth of 5 is implicit
in the definition of a terminal,

1110
01:19:35,100 --> 01:19:38,400
but we haven't enforced it.

1111
01:19:39,440 --> 01:19:48,133
You haven't said, when instantiating
these trees, enforce that it isn't deeper than five.

1112
01:19:48,133 --> 01:19:50,173
But there is an implication.

1113
01:19:50,173 --> 01:19:51,221
DN: Yes.

1114
01:19:51,220 --> 01:19:55,626
TS: And you've also said the total should
be correct after adding or removing nodes.

1115
01:19:56,066 --> 01:19:58,933
So there are two things there.

1116
01:20:01,220 --> 01:20:04,170
What is most interesting
to me is the latter statement.

1117
01:20:08,970 --> 01:20:12,800
Although the enforcement of
the maximum depth is interesting.

1118
01:20:15,140 --> 01:20:19,253
Let's think about the other
one and go back to that later.

1119
01:20:19,266 --> 01:20:21,340
DN: That is more driving the API isn't it?

1120
01:20:21,340 --> 01:20:22,840
TS: I think so yes.

1121
01:20:25,740 --> 01:20:31,866
If only because, at the moment we haven't
looked at what it means to modify these trees.

1122
01:20:32,050 --> 01:20:38,760
At the moment it if you look at our
node class you can't even get the children,

1123
01:20:39,466 --> 01:20:40,940
much less set them. DN: Yes.

1124
01:20:40,960 --> 01:20:46,520
We haven't in any way addressed what
it means to be able to mutate these things.

1125
01:20:47,840 --> 01:20:52,613
That's an interesting thing to think about.

1126
01:20:52,613 --> 01:20:58,080
I'm not entirely sure how to address that.

1127
01:21:00,280 --> 01:21:02,450
Let me make a commit before I do anything.

1128
01:21:04,080 --> 01:21:10,826
So this is: "fix terminal ordering.

1129
01:21:10,930 --> 01:21:15,955
Then step to accommodate unstable sort"

1130
01:21:15,950 --> 01:21:22,900
(TS dithers)

1131
01:21:22,920 --> 01:21:31,771
This is more difficult to
accommodate in a cucumber feature,

1132
01:21:31,777 --> 01:21:36,010
but I think there's probably a way of doing it.

1133
01:21:39,600 --> 01:21:41,640
It seems like...

1134
01:21:41,693 --> 01:21:44,080
this is implicitly a requirement.

1135
01:21:44,910 --> 01:21:45,706
DN: Yes.

1136
01:21:45,706 --> 01:21:49,733
TS: What this implies is that firstly
you should be able to add or remove a node.

1137
01:21:49,740 --> 01:21:55,906
and secondly, when you do so it
shouldn't change what's going on here.

1138
01:21:55,906 --> 01:21:56,946
DN: Yes.

1139
01:21:58,280 --> 01:22:00,866
TS: You should be able to change one of these trees,

1140
01:22:00,866 --> 01:22:04,666
and then if I order the
collection again, it should change.

1141
01:22:04,666 --> 01:22:05,613
DN: Exactly.

1142
01:22:08,400 --> 01:22:11,746
TS: So that necessitates firstly
some kind of acceptance test

1143
01:22:11,746 --> 01:22:15,266
that tells us what it is we want.

1144
01:22:15,920 --> 01:22:20,413
And then some kind of implementation
that allows us to mutate these trees.

1145
01:22:23,466 --> 01:22:27,853
Or add and remove nodes from them.

1146
01:22:27,910 --> 01:22:31,306
I'm trying to think of the easiest way to test that.

1147
01:22:36,050 --> 01:22:44,493
Maybe we need a new feature which
is adding and removing and updating it.

1148
01:22:47,020 --> 01:22:51,000
It's still sort of, part of the sorting feature.

1149
01:22:51,970 --> 01:23:02,066
Given that I have a collection of
trees, when I add a nodes to one of them,

1150
01:23:02,520 --> 01:23:08,333
and I sort the collection again then it should
still be ordered by total number of descendants.

1151
01:23:10,820 --> 01:23:14,613
DN: I had imagined that perhaps you
would be doing some kind of caching.

1152
01:23:14,880 --> 01:23:17,920
At the moment you're not doing anything with caching.

1153
01:23:17,930 --> 01:23:24,360
All the counting happens on live objects,
so if you were to create another feature

1154
01:23:24,370 --> 01:23:27,586
maybe we could call it
'manipulating trees' or something.

1155
01:23:27,586 --> 01:23:31,706
It could justifiably not be
part of the sorted trees story.

1156
01:23:31,800 --> 01:23:32,653
TS: Ok.

1157
01:23:36,400 --> 01:23:38,306
What's the best way to do that....

1158
01:23:46,280 --> 01:23:52,706
I think what we are talking about here is coming
up with an API for being able to modify these trees.

1159
01:23:57,650 --> 01:24:00,680
Let's say there is a modifying feature.

1160
01:24:06,650 --> 01:24:14,790
Let's say... features/modifying

1161
01:24:15,000 --> 01:24:27,230
this will be Feature: modifying trees

1162
01:24:27,240 --> 01:24:30,490
and then...

1163
01:24:32,330 --> 01:24:42,400
Scenario: adding node to a tree.
Given I have a tree,

1164
01:24:42,500 --> 01:24:51,540
When I add a node to it
Then the tree should contain that node

1165
01:24:51,570 --> 01:24:54,990
I'm not sure what I want to say
here. But something like that.

1166
01:24:54,990 --> 01:24:59,660
You start out with one of these things,
and then you change it and get a new one.

1167
01:25:07,880 --> 01:25:09,250
We don't need that anymore.

1168
01:25:11,140 --> 01:25:14,510
I think I can keep putting this stuff in tree steps.

1169
01:25:14,540 --> 01:25:18,700
If I run these cucumber features it's
going to say you don't have any of this.

1170
01:25:30,020 --> 01:25:31,980
Let's say my tree is...

1171
01:25:40,850 --> 01:25:43,010
It doesn't matter really.

1172
01:25:43,050 --> 01:25:48,460
I guess we just need to think
about what it is that goes in.

1173
01:25:49,650 --> 01:25:50,910
Now I've built 'some' tree.

1174
01:25:52,600 --> 01:25:57,950
I've got one pending scenario.

1175
01:25:58,420 --> 01:26:02,300
I need to put something in here
that involves adding a node to the tree.

1176
01:26:02,950 --> 01:26:05,200
And then I want to do something
that checks that it's...

1177
01:26:08,610 --> 01:26:11,790
I guess, this is the point
where we need to make a decision.

1178
01:26:11,800 --> 01:26:16,380
To someone using this from the outside,
what does adding a node to a tree mean?

1179
01:26:18,970 --> 01:26:25,020
I think the simplest thing is
to add another child at the root.

1180
01:26:28,700 --> 01:26:32,280
I guess it could be
"I've got a node that is already a tree".

1181
01:26:32,280 --> 01:26:41,000
I could say... additional node is something here.

1182
01:26:41,050 --> 01:26:46,800
It could be a node with no
children or something like this:

1183
01:26:46,800 --> 01:26:48,240
DN: Ah yes.

1184
01:26:48,240 --> 01:26:54,710
TS: And then I want to somehow
add that as a child of the tree, right?

1185
01:26:55,650 --> 01:26:59,480
DN: I don't think it would be
necessary to compose trees like that.

1186
01:26:59,540 --> 01:27:02,020
You would only ever be adding one node at a time.

1187
01:27:02,030 --> 01:27:08,620
For example, when you leave a comment on a blog,

1188
01:27:09,520 --> 01:27:11,630
they sometimes have a 'nest it' type thing.

1189
01:27:11,630 --> 01:27:16,600
Imagine each node is
something that one user has added.

1190
01:27:16,770 --> 01:27:17,450
TS: Ok.

1191
01:27:17,450 --> 01:27:18,870
Well in that case...

1192
01:27:20,450 --> 01:27:24,720
That's just making an empty node.

1193
01:27:24,770 --> 01:27:30,340
So I can add that, and then I have
to do something to my tree to add it.

1194
01:27:30,350 --> 01:27:34,150
So it could be that there's some kind of add_child.

1195
01:27:34,220 --> 01:27:37,220
You haven't said anything
about the ordering of nodes.

1196
01:27:37,220 --> 01:27:40,770
Your diagram suggests that
you might not care about the ordering.

1197
01:27:40,780 --> 01:27:45,120
You haven't drawn this as a
top to bottom, left to right tree.

1198
01:27:45,130 --> 01:27:49,160
You just say there are nodes
emanating out from the center.

1199
01:27:51,570 --> 01:27:56,920
You can clarify whether or not you
care.  But for the purpose of this...

1200
01:27:57,310 --> 01:28:00,560
we're just going to add a child
on to the end of this node.

1201
01:28:04,470 --> 01:28:08,480
And then when we get to this step
there is something that is going to check

1202
01:28:08,480 --> 01:28:11,310
that this node has been added to the tree.

1203
01:28:18,760 --> 01:28:21,820
We can go ahead and
start writing unit tests here

1204
01:28:22,710 --> 01:28:31,600
but my personal preference would
be for making these trees immutable.

1205
01:28:32,020 --> 01:28:34,370
Having this return a new tree.

1206
01:28:39,400 --> 01:28:43,120
I don't think this example
is going to illustrate this.

1207
01:28:43,480 --> 01:28:48,550
But making these structures
immutable makes it a lot easier to keep track

1208
01:28:48,560 --> 01:28:50,710
of what can possibly happen.

1209
01:28:50,720 --> 01:28:54,960
Because if I did want to start caching
stuff, which we wont have time to do today.

1210
01:28:54,960 --> 01:29:02,210
But if I did, having these be immutable means
that I don't have to deal with the caching problem.

1211
01:29:02,210 --> 01:29:06,030
If I want to memoize the
result of those recursive calls,

1212
01:29:06,030 --> 01:29:10,890
then I could just memoize them and then next
time I call them you just get the memoized result.

1213
01:29:10,890 --> 01:29:14,960
And if you change the tree,
that just means you have a new one.

1214
01:29:14,970 --> 01:29:19,740
And if you had some kind of structural
sharing, so that when you add an extra child,

1215
01:29:19,750 --> 01:29:24,580
you get a new tree back but all of the
previous children are literally the same objects.

1216
01:29:24,600 --> 01:29:29,090
But the parent node is new and has a new child.

1217
01:29:29,090 --> 01:29:32,910
And all of the cached stuff would be
shared from the old parts of the tree

1218
01:29:32,910 --> 01:29:35,880
that haven't changed. And then
you would have to re-build the cache

1219
01:29:35,890 --> 01:29:37,770
for the new parts of the tree. DN: I see.

1220
01:29:37,770 --> 01:29:41,210
TS: Driving all of that stuff out with
tests is going to be time consuming.

1221
01:29:41,220 --> 01:29:46,960
In my view, it's going to make
for an easier system to deal with

1222
01:29:47,040 --> 01:29:49,640
without these things being mutable.

1223
01:29:51,600 --> 01:29:58,810
What I don't want, in my capacity as a consumer
of this API, is to be able to only do tree.children.

1224
01:30:00,920 --> 01:30:02,380
Like do that:

1225
01:30:06,110 --> 01:30:09,610
If there was just an accessor on tree
that returned an array of children

1226
01:30:09,620 --> 01:30:11,920
and I concatenated that on to the end.

1227
01:30:12,010 --> 01:30:15,260
The root node of that tree
doesn't even know it's happened.

1228
01:30:16,800 --> 01:30:21,110
And so for me to do anything that
responds to changes in the structure of the tree

1229
01:30:21,110 --> 01:30:25,040
gets very difficult, if not impossible
if I expose that array of children.

1230
01:30:25,050 --> 01:30:28,810
Because now you have that array in your
hand and you can do whatever you like to it.

1231
01:30:28,810 --> 01:30:31,830
I don't really like the idea of exposing it directly.

1232
01:30:32,020 --> 01:30:38,070
For the same reason I don't like the
idea of this being something that mutates

1233
01:30:38,070 --> 01:30:41,260
the underlying tree. I would
rather just return a new one.

1234
01:30:41,370 --> 01:30:44,880
Assuming there's a way to append the child there,

1235
01:30:46,450 --> 01:30:49,790
Which there isn't. So we're going
to see a failure in our features.

1236
01:30:52,080 --> 01:30:53,970
When I scroll off the top you can see:

1237
01:30:54,110 --> 01:30:56,910
when I add a node to it
undefined method append_child.

1238
01:30:56,910 --> 01:30:58,370
So let's make a commit there.

1239
01:31:08,400 --> 01:31:11,850
I'd like to make that work.

1240
01:31:11,910 --> 01:31:19,570
I think this is an opportunity to do
some tidying up at the implementation level.

1241
01:31:20,910 --> 01:31:24,290
We've expressed what we want
to happen in the feature here

1242
01:31:24,290 --> 01:31:26,410
but let's go down to the unit test.

1243
01:31:32,510 --> 01:31:35,570
So let's pick one of these.

1244
01:31:35,890 --> 01:31:39,590
This is quite a nice one, where
the node has five descendants.

1245
01:31:45,220 --> 01:31:48,820
In this unit test we have to
decide, and in the acceptance test,

1246
01:31:48,830 --> 01:31:51,800
how do we know if it's done the right thing.

1247
01:31:51,800 --> 01:31:53,800
DN: Yes.

1248
01:31:53,800 --> 01:31:56,140
TS: I don't really know how we are going to do that.

1249
01:31:56,140 --> 01:31:59,060
DN: You could check the number of descendants.

1250
01:31:59,070 --> 01:32:02,940
TS: At the moment that's the
only visibility we have on to the tree.

1251
01:32:02,950 --> 01:32:05,510
Let's think about doing that.

1252
01:32:05,680 --> 01:32:14,610
Let's say describe adding a child.

1253
01:32:17,740 --> 01:32:23,860
It increases the descendant count to six.

1254
01:32:23,880 --> 01:32:30,650
So whatever that's worth, we
would say expect node and child.

1255
01:32:34,240 --> 01:32:35,530
(Let's make a new one).

1256
01:32:39,000 --> 01:32:45,100
And this would be the
descendant count to be equal to six.

1257
01:32:45,820 --> 01:32:50,400
I think that would give us some
confidence that the right thing has happened.

1258
01:32:50,400 --> 01:32:55,140
That's the best we can do at the moment,
based on the API that's available to us.

1259
01:32:55,140 --> 01:32:58,940
Let's try running that example...
undefined method add_child.

1260
01:33:02,970 --> 01:33:08,740
Now we're going to need a
method here that adds a child.

1261
01:33:11,280 --> 01:33:13,310
There's a very easy thing
we can do here...

1262
01:33:13,710 --> 01:33:26,970
Which is to say make a new one of me with
my children but then add on that new child.

1263
01:33:27,020 --> 01:33:35,200
And that's enough to make the test
pass. That's moderately convincing I think.

1264
01:33:35,340 --> 01:33:38,880
I don't think that spec would
have passed if that didn't work.

1265
01:33:39,000 --> 01:33:46,670
So I'll make a commit there and
I'll say: "implement add child"

1266
01:33:50,080 --> 01:33:50,730
Whoops...

1267
01:33:51,910 --> 01:33:54,310
That's a nice simple implementation
I think.

1268
01:33:56,600 --> 01:33:58,610
How did you feel about that?

1269
01:33:58,650 --> 01:34:00,440
DN: I like it.

1270
01:34:03,140 --> 01:34:11,850
TS: Let's go back to the step definitions
and finish off because we're not done.

1271
01:34:13,740 --> 01:34:18,080
That's made that step work.
And now we have to say:

1272
01:34:19,020 --> 01:34:32,710
expect(@tree.descendant_count)
to be equal to...

1273
01:34:32,770 --> 01:34:36,410
I guess that one was two?
So we expect it to be equal to three.

1274
01:34:36,420 --> 01:34:39,520
DN: Just before you move on,
I notice you used append_child there

1275
01:34:39,520 --> 01:34:41,600
but it's add_child in the implementation.

1276
01:34:42,820 --> 01:34:43,970
TS: Thank you.

1277
01:34:44,020 --> 01:34:53,770
Well that's stupid, why didn't that fail?
Oh it did fail, I just didn't read it.

1278
01:34:53,770 --> 01:34:58,340
Yes you're right, append_child is a better name.

1279
01:34:58,350 --> 01:35:01,340
DN: For the immutable nature of it?

1280
01:35:01,340 --> 01:35:03,650
TS: Because it tells you where it's going to go.

1281
01:35:04,490 --> 01:35:06,440
DN: Right: 'Add child below me'.

1282
01:35:06,440 --> 01:35:11,790
TS: Yes, and the fact that it goes
on the end, after the existing children.

1283
01:35:11,790 --> 01:35:15,110
At the moment you can't tell.

1284
01:35:16,420 --> 01:35:19,420
So yes, let's call it add_child because at the moment

1285
01:35:19,440 --> 01:35:23,980
there's no way of knowing where it's gone.

1286
01:35:23,990 --> 01:35:28,100
If at some point we decide we're going
to be able to expose the collection of children

1287
01:35:28,100 --> 01:35:31,240
and now we care about where
it comes when you have it,

1288
01:35:31,280 --> 01:35:33,420
that would be the point at which to make it.

1289
01:35:33,420 --> 01:35:35,800
But right now you can't make that distinction.

1290
01:35:40,280 --> 01:35:43,030
Let's just commit that fix. That looks annoying.

1291
01:35:47,620 --> 01:35:48,500
And this is:

1292
01:35:50,930 --> 01:35:55,030
"Implement Then step for modified tree"

1293
01:36:02,650 --> 01:36:05,870
That's fine.

1294
01:36:05,910 --> 01:36:10,280
We are ignoring the fact that
presumably the whole point of these trees

1295
01:36:10,280 --> 01:36:13,380
is that you can at some point get to the nodes.

1296
01:36:13,420 --> 01:36:16,330
At the moment there's no API for getting to them.

1297
01:36:18,770 --> 01:36:31,900
I'd like to bring that out by saying:
expect(@tree.children).to include...

1298
01:36:34,250 --> 01:36:41,790
It seems like: to not do that
is to slightly dodge the issue.

1299
01:36:41,800 --> 01:36:43,380
DN: Sure

1300
01:36:44,330 --> 01:36:46,950
TS: We don't have a way of doing this yet.

1301
01:36:46,970 --> 01:36:50,390
DN: So at the moment children is a private attribute.

1302
01:36:50,420 --> 01:36:53,130
TS: Well it's an instance
variable. There is no children.

1303
01:36:53,140 --> 01:36:57,220
Not even a private method called
children, so that's going to say

1304
01:36:57,240 --> 01:37:02,310
"I don't know what you're talking about".

1305
01:37:02,510 --> 01:37:09,210
In the spec, you didn't say explicitly,
but implicit in all of this stuff is...

1306
01:37:09,270 --> 01:37:13,580
Where you say model a tree.

1307
01:37:13,580 --> 01:37:18,770
It is implied that you want
access to the contents of the tree?

1308
01:37:18,780 --> 01:37:20,710
DN: Sure, it would be nice.

1309
01:37:21,570 --> 01:37:28,880
TS: So this gives us a way in and
verify that the children of the tree are inclusive.

1310
01:37:28,890 --> 01:37:32,980
I want to check this...
If it was an empty array,

1311
01:37:35,370 --> 01:37:37,400
then that step should fail.

1312
01:37:37,420 --> 01:37:39,450
We expected that to include that node.

1313
01:37:39,910 --> 01:37:45,750
If I just had an array that had additional
node in there then I think that my... Yeah!

1314
01:37:45,800 --> 01:37:51,280
That's to verify that my rspec expectation is right.

1315
01:37:51,310 --> 01:37:56,440
Because I always spell include or
includes... or does it have a '?'

1316
01:37:56,450 --> 01:37:59,450
Every time I type include in Ruby, I get it wrong.

1317
01:37:59,450 --> 01:38:03,190
So that has given me confidence
that my test is testing the right thing.

1318
01:38:03,200 --> 01:38:08,570
Now, that introduces a new requirement
which is how do we get at the children of the tree?

1319
01:38:18,200 --> 01:38:22,470
I guess that means we
need a test here that says...

1320
01:38:24,050 --> 01:38:26,380
This would be a good place for it.

1321
01:38:28,230 --> 01:38:34,970
It "contains its children",
or something like that.

1322
01:38:35,880 --> 01:38:42,110
Maybe "exposes" that it's
possible to "get at" the children:

1323
01:38:42,450 --> 01:38:59,230
I would expect Node.new(children)
.children to be equal to... that!

1324
01:38:59,240 --> 01:39:03,430
I can round trip that collection
of children through the node.

1325
01:39:07,680 --> 01:39:10,430
There's some duplication here but I'll leave  it.

1326
01:39:10,450 --> 01:39:13,710
All over here we've got places
where we're making node.new children.

1327
01:39:13,720 --> 01:39:17,430
There's a temptation to have
one of these let things that says:

1328
01:39:18,620 --> 01:39:20,430
Here we could do it.

1329
01:39:22,310 --> 01:39:27,980
That says let(:node)
be Node.new(children)

1330
01:39:27,990 --> 01:39:32,410
That means that all of these places
where I've got Node.new(children),

1331
01:39:32,450 --> 01:39:34,540
I can replace that with just node.

1332
01:39:36,970 --> 01:39:43,380
And I think that those tests
will... Wow! completely explode.

1333
01:39:43,440 --> 01:39:44,970
That's not what I wanted.

1334
01:39:45,600 --> 01:39:51,946
Oh, it's because this is nonsense!
That should be Node.new(children).

1335
01:39:52,320 --> 01:39:55,075
Sorry, don't know what I was thinking.

1336
01:39:58,755 --> 01:40:00,613
"You must pass an argument"

1337
01:40:01,360 --> 01:40:07,706
Oh yes, what am I doing?
I was reading the one above.

1338
01:40:07,820 --> 01:40:12,168
This is not supposed to be a block.
This is just an argument to expect.

1339
01:40:12,551 --> 01:40:16,133
That's the one failure I wanted.

1340
01:40:23,680 --> 01:40:25,671
That is not what I wanted.

1341
01:40:28,310 --> 01:40:30,160
What did I do here?

1342
01:40:30,168 --> 01:40:43,591
Oh this was: "Actually check
children in Cucumber feature"

1343
01:40:49,182 --> 01:40:51,777
Again I've raced ahead
and done two things.

1344
01:40:52,195 --> 01:40:55,591
But I just want to add that.

1345
01:40:57,740 --> 01:41:07,795
Which is:
'Extract "node" accessor in spec'

1346
01:41:10,020 --> 01:41:12,346
That has cleaned up my spec a bit.

1347
01:41:12,346 --> 01:41:16,702
And now I've just got this new example which is failing.

1348
01:41:16,702 --> 01:41:18,700
DN: Yes.

1349
01:41:26,220 --> 01:41:28,960
TS: I'm not going to spend
time writing examples around this,

1350
01:41:28,960 --> 01:41:33,342
but I don't want to expose just that children array.

1351
01:41:33,400 --> 01:41:39,004
I think that would be bad. Because
then you would be able to modify it.

1352
01:41:40,170 --> 01:41:45,751
The simplest thing I can do to make
the test pass is to [create a method].

1353
01:41:45,751 --> 01:41:53,004
In fact I don't even need to do that!
I can just say attr_reader :children

1354
01:41:53,820 --> 01:41:58,257
I think that will make all my tests pass
and then hopefully

1355
01:41:58,257 --> 01:42:01,395
when I run all my cucumber features,
it will make them all pass.

1356
01:42:01,420 --> 01:42:06,568
So I will commit that and say:
"Implement..."

1357
01:42:10,420 --> 01:42:13,448
But, I'm not really happy about it.

1358
01:42:13,480 --> 01:42:16,906
DN: Even though it's a reader,
you can take that object and modify it.

1359
01:42:16,940 --> 01:42:21,128
TS: Exactly.  It doesn't let
you re-assign the children collection,

1360
01:42:21,137 --> 01:42:26,444
but once you have an array you can
remove everything from it and re-populate it.

1361
01:42:26,450 --> 01:42:31,057
The actual identity of the array
isn't a very useful thing to protect.

1362
01:42:31,057 --> 01:42:33,653
It's the contents of it
that we care about.

1363
01:42:35,000 --> 01:42:38,791
We could freeze the array.

1364
01:42:38,820 --> 01:42:42,568
We could make an accessor here that says:

1365
01:42:42,568 --> 01:42:46,071
children... I guess actually...

1366
01:42:47,510 --> 01:42:49,262
Could we freeze it here?

1367
01:42:51,650 --> 01:42:53,466
I think if we do that

1368
01:42:55,857 --> 01:42:58,924
then it all still works.

1369
01:42:58,924 --> 01:42:59,720
DN: Yes, right.

1370
01:42:59,733 --> 01:43:03,093
TS: Our cucumber features all still work.

1371
01:43:03,100 --> 01:43:04,915
So that's one way of dealing with it.

1372
01:43:04,920 --> 01:43:11,324
I think a more interesting way is...
to expose an enumerator.

1373
01:43:38,622 --> 01:43:40,817
I think that would feel more natural to me.

1374
01:43:40,810 --> 01:43:45,120
To say "if you want to iterate
over my children, then you may do so".

1375
01:43:47,320 --> 01:43:54,817
If I just pop open irb...
"if I have an array".

1376
01:44:00,097 --> 01:44:02,890
There are a variety of ways
to make an enumerator out of that

1377
01:44:02,900 --> 01:44:08,471
you can call to_enum, or you can
just call each and that also returns enumerator.

1378
01:44:08,510 --> 01:44:12,648
I think here I would like to define an iterator.

1379
01:44:12,650 --> 01:44:16,711
So if we can iterate over each
child, and I can provide a block.

1380
01:44:17,050 --> 01:44:22,471
Then I will call each on the children for you.

1381
01:44:23,510 --> 01:44:25,653
And that's nice because...

1382
01:44:29,048 --> 01:44:31,671
if I have some class,

1383
01:44:35,510 --> 01:44:37,493
If I call...

1384
01:44:42,222 --> 01:44:44,702
If I pass on the block argument like that.

1385
01:44:44,711 --> 01:44:46,551
And make a new one of these.

1386
01:44:48,746 --> 01:44:52,222
each_child

1387
01:44:52,310 --> 01:44:54,186
Then it will work.

1388
01:44:54,364 --> 01:44:59,060
If I don't pass in a block, each will
behave as if I haven't passed in a block,

1389
01:44:59,060 --> 01:45:00,702
which gives you an iterator back.

1390
01:45:00,702 --> 01:45:04,320
This works the same as when
I've been doing: 10.times.each:

1391
01:45:10,080 --> 01:45:14,826
Or I've just been using 10.times
and then not passing it a block,

1392
01:45:15,820 --> 01:45:18,675
and then calling something
like map on the end of it.

1393
01:45:18,675 --> 01:45:24,490
That works because these methods in the
standard library return an enumerator.

1394
01:45:24,500 --> 01:45:29,315
The opportunity to return an
enumerator here is a nicer interface.

1395
01:45:29,448 --> 01:45:32,170
It's more constrained and
gives you what you want.

1396
01:45:35,140 --> 01:45:37,250
And, you don't even know that it's an array.

1397
01:45:37,250 --> 01:45:42,124
The enumerator itself doesn't
let you reach inside it and say:

1398
01:45:42,133 --> 01:45:46,000
"what kind of thing are you iterating over"?

1399
01:45:47,420 --> 01:45:49,653
So that feels quite nice.

1400
01:45:49,820 --> 01:45:53,020
The problem is that that's
going to break all of our examples,

1401
01:45:53,020 --> 01:45:55,297
or just this one that asks for the children.

1402
01:45:55,310 --> 01:45:57,570
DN: So we still don't have a children method.

1403
01:45:57,570 --> 01:46:03,760
TS: No. We just have a way of
iterating over all of the children.

1404
01:46:03,770 --> 01:46:06,560
So we need to change our spec slightly.

1405
01:46:08,620 --> 01:46:12,410
So I can't call children any more,
I can only call each_child.

1406
01:46:12,420 --> 01:46:15,560
Which gives me an enumerator back.

1407
01:46:15,570 --> 01:46:21,820
If I want to check all the things
that are yielded by that enumerator.

1408
01:46:21,820 --> 01:46:26,100
I could write some code that says...

1409
01:46:26,110 --> 01:46:29,350
I could pass this a block and then say:

1410
01:46:29,360 --> 01:46:34,930
actual_children << child
if I had already initialized one.

1411
01:46:34,940 --> 01:46:39,075
But fortunately enumerators
include the Enumerable module

1412
01:46:39,080 --> 01:46:42,124
which already has a method
called entries.

1413
01:46:42,120 --> 01:46:46,711
So I can say "if I get an
enumeration of all the children,

1414
01:46:46,737 --> 01:46:50,035
and turn that into an array
by accumulating all of them.

1415
01:46:50,035 --> 01:46:53,422
That should be the same as the array of children".

1416
01:46:59,940 --> 01:47:03,066
What's that complaining about?

1417
01:47:03,140 --> 01:47:09,235
Node line 9. Oh it's because I
forgot to refer to it as an instance variable.

1418
01:47:14,480 --> 01:47:17,075
So that's all fine.

1419
01:47:17,110 --> 01:47:24,364
If I now run my cucumber features. I've got
a failure because that's calling children as well.

1420
01:47:27,075 --> 01:47:30,986
This is all about designing the API.

1421
01:47:31,000 --> 01:47:34,720
I've got an opportunity to shape the API,

1422
01:47:37,840 --> 01:47:43,831
and those changes to the API need
to propagate out of the cucumber feature

1423
01:47:43,830 --> 01:47:48,826
because in the world where the
customer is the person using the API,

1424
01:47:48,826 --> 01:47:52,800
we need to make sure that all the things
they want to do have been designed out.

1425
01:47:52,817 --> 01:47:58,088
And I think that exposing an iterator, although
it's not as nice as being able to call children.

1426
01:47:58,090 --> 01:48:04,951
In fact, we could add a children method
that does each_child.entries if we wanted to.

1427
01:48:04,951 --> 01:48:09,822
But this is nice. It's low level but it
exposes the...

1428
01:48:09,850 --> 01:48:17,040
The essence of the interface, is
that you can iterate over all of the children.

1429
01:48:19,217 --> 01:48:22,888
I will just commit that.

1430
01:48:35,540 --> 01:48:39,662
DN: If you did call each_child.entries
and the array that you get back

1431
01:48:39,680 --> 01:48:42,113
if you then changed that, it wouldn't affect it ?

1432
01:48:42,110 --> 01:48:43,940
TS: Right. Because that's your array

1433
01:48:43,940 --> 01:48:45,688
DN: It's a copy.

1434
01:48:45,697 --> 01:48:49,591
TS: Yes, the tree doesn't even know
that you have called entries on that enumerator.

1435
01:48:49,591 --> 01:48:53,146
You've just got one.

1436
01:48:53,146 --> 01:48:55,982
In fact, that reminds me.

1437
01:48:56,820 --> 01:49:00,453
In terms of designing the API of
this thing or doing some re-factoring.

1438
01:49:00,450 --> 01:49:06,364
You can see there are a few places
where we want to know if this is empty.

1439
01:49:06,373 --> 01:49:07,820
Here's the clearest point.

1440
01:49:07,820 --> 01:49:10,382
What we are asking here is whether we are a leaf.

1441
01:49:10,710 --> 01:49:11,831
"Am I a leaf?"

1442
01:49:12,017 --> 01:49:15,768
Because that's what it really means.

1443
01:49:15,866 --> 01:49:19,368
If we're a leaf do this otherwise do this other thing.

1444
01:49:20,820 --> 01:49:24,506
We can have a method here. Which is "are you a leaf"?

1445
01:49:26,650 --> 01:49:31,955
Because I've got access to it I can just say children.empty

1446
01:49:31,970 --> 01:49:37,537
But I'm nervous about all of these places
where we're referring to the instance variable.

1447
01:49:38,220 --> 01:49:42,930
I would much rather have the
instance variable in as few places as possible.

1448
01:49:42,940 --> 01:49:48,613
If I think that each_child is a
reasonable API for accessing the children

1449
01:49:48,620 --> 01:49:50,435
I should be able to consume that internally

1450
01:49:50,453 --> 01:49:54,420
Instead of having all these places
where I'm accessing the children

1451
01:49:54,570 --> 01:49:59,066
For example, in this leaf method,
instead of saying children.empty?

1452
01:50:00,220 --> 01:50:01,790
I could say: each child.entries.empty?

1453
01:50:01,800 --> 01:50:05,431
So build me an array, and
then tell me whether it's empty.

1454
01:50:05,440 --> 01:50:11,537
But there's an even better way of doing
that. Enumerable has a method called 'none?'.

1455
01:50:11,540 --> 01:50:15,075
So if I call each_child to get the
enumerator I can say...

1456
01:50:15,080 --> 01:50:18,462
That is saying "are there no children?".

1457
01:50:18,471 --> 01:50:22,106
In fact it will tell me if there
are any children that are nil or false,

1458
01:50:22,100 --> 01:50:25,422
but in this case, none takes a block

1459
01:50:25,480 --> 01:50:28,871
and you can say "are there no children that satisfy this condition?"

1460
01:50:28,871 --> 01:50:33,520
If you don't provide the block, it says
"are there no children that are truthy?",

1461
01:50:33,620 --> 01:50:36,200
which in our case is the same as there being none.

1462
01:50:36,200 --> 01:50:39,200
If I run all of the unit tests, that still works.

1463
01:50:39,250 --> 01:50:43,990
And all the cucumber features still work.
That gives me an opportunity to say:

1464
01:50:44,000 --> 01:50:55,466
"Extract leaf and use enumerator
instead of instance variable"

1465
01:50:55,580 --> 01:50:58,391
And there are several
other places where I could do this.

1466
01:50:58,400 --> 01:51:06,355
I'm only using children here  to map over
something, which each_child will do quite nicely.

1467
01:51:06,355 --> 01:51:08,008
And same here.

1468
01:51:12,480 --> 01:51:17,893
All I am doing with this instance variable is
remember the value that was passed into the constructor,

1469
01:51:17,900 --> 01:51:21,271
and then I am exposing a way of iterating over it.

1470
01:51:21,280 --> 01:51:27,653
So the only state that is stored in
here, allows you to expose it in iteration,

1471
01:51:27,662 --> 01:51:31,413
and some of the work is done by doing that iteration.

1472
01:51:31,440 --> 01:51:34,213
So if I run all of my tests. They're fine.

1473
01:51:34,250 --> 01:51:37,137
And the cucumber features are fine.

1474
01:51:37,537 --> 01:51:45,990
I can change this to: 'Use #each_child
instead of @children when iterating'

1475
01:51:46,370 --> 01:51:54,666
The only frustrating thing is
because we did this children.size...

1476
01:51:54,800 --> 01:51:59,146
When you create an enumerator,
it is possible to tell it how to find the size

1477
01:51:59,150 --> 01:52:02,666
of the underlying collection. Some enumerators can.

1478
01:52:02,740 --> 01:52:05,644
It has always got a size
method, but sometimes it returns nil

1479
01:52:05,653 --> 01:52:09,431
if the enumerator has
been created without providing

1480
01:52:09,448 --> 01:52:12,817
what the size of the underlying enumeration is.

1481
01:52:14,910 --> 01:52:18,453
If I say each and then ask that for its size.

1482
01:52:18,570 --> 01:52:22,480
In the case where the
underlying collection that you've provided,

1483
01:52:22,480 --> 01:52:26,391
does report the size, you can get the size back out.

1484
01:52:28,420 --> 01:52:31,591
I feel slightly nervous about that.

1485
01:52:31,620 --> 01:52:35,546
Oh! But, I've just remembered!

1486
01:52:35,540 --> 01:52:41,564
I think enumerable has a method called count.

1487
01:52:41,650 --> 01:52:45,226
Which does something like 'all' or 'none'.

1488
01:52:45,220 --> 01:52:49,333
You can give it a block and it will tell
you for how many items in the enumeration,

1489
01:52:49,370 --> 01:52:51,688
that block is true.

1490
01:52:53,170 --> 01:52:55,200
But I'm not sure if this is going to work.

1491
01:52:56,310 --> 01:52:57,893
It does, good.

1492
01:53:01,650 --> 01:53:05,928
In all these cases I have avoided
building an array of all the children.

1493
01:53:11,480 --> 01:53:14,888
Now that we are only
accessing that children collection....

1494
01:53:14,888 --> 01:53:16,888
(we have got to do this).

1495
01:53:16,880 --> 01:53:20,480
Apart from that we are only accessing
that children collection through the iterator,

1496
01:53:20,480 --> 01:53:24,222
which means that children
can be anything that's enumerable.

1497
01:53:24,220 --> 01:53:27,617
Anything that responds to each.
It doesn't have to be an array.

1498
01:53:27,630 --> 01:53:33,244
It could be some sort of 'lazy
collection', which you haven't specified.

1499
01:53:33,240 --> 01:53:37,848
But designing it this way means we
are gradually reducing the surface area

1500
01:53:37,857 --> 01:53:39,555
of what we expect from children.

1501
01:53:39,550 --> 01:53:43,697
All we require from children is that we
can call each on it, to get an enumerator back,

1502
01:53:43,706 --> 01:53:47,208
and the rest of the functionality
sits on top of that single assumption

1503
01:53:47,200 --> 01:53:49,742
about what we can do with the children.

1504
01:53:52,340 --> 01:53:57,004
I'm not changing the tests at all here.
I'm just getting a chance to refactor.

1505
01:53:57,022 --> 01:54:07,013
"Use Enumerable#count to count
the children through the enumerator"

1506
01:54:07,031 --> 01:54:10,170
And then, (this one is a bit tricky).

1507
01:54:10,540 --> 01:54:12,622
There are two ways of doing this.

1508
01:54:13,420 --> 01:54:17,946
I'll show you the stupid way... well, you
don't need me to show you stupid way

1509
01:54:18,140 --> 01:54:27,146
It's just: each_child.entries
and add that child to the end.

1510
01:54:27,480 --> 01:54:29,333
Run all the tests.

1511
01:54:29,370 --> 01:54:31,066
Run all the cukes.

1512
01:54:31,110 --> 01:54:31,710
That's fine.

1513
01:54:32,110 --> 01:54:33,724
DN: Yes.

1514
01:54:34,570 --> 01:54:40,693
TS: I think a better way is to build
an enumeration of the new children

1515
01:54:40,702 --> 01:54:44,017
by adapting the old enumeration.

1516
01:54:44,020 --> 01:54:51,182
I can say here children equals a new enumerator.

1517
01:54:51,250 --> 01:54:58,195
An enumerator works by providing
an object called a yielder to this block.

1518
01:54:58,195 --> 01:55:03,102
that you pass in the constructor.
And every time you call yielder.yield

1519
01:55:03,110 --> 01:55:04,720
It will yield that value.

1520
01:55:08,400 --> 01:55:11,164
Let's look at it on irb:

1521
01:55:11,170 --> 01:55:29,191
If I say: enum=Enumerator.new do |yielder|
yielder.yield one, two, three, end.

1522
01:55:29,200 --> 01:55:31,795
First you can step through them one at a time.

1523
01:55:31,800 --> 01:55:34,990
You can say give me the next value,
and the next... It's using fibers

1524
01:55:35,000 --> 01:55:40,620
to suspend execution of that block after
every yield until I say I'm ready.

1525
01:55:40,630 --> 01:55:43,635
If I enumerate off the end
it says: reached an end.

1526
01:55:43,650 --> 01:55:47,493
I think I can rewind. Yes.

1527
01:55:48,910 --> 01:55:55,671
It's enumerable so I can also say:
enum.entries. I can do: enum.each.

1528
01:55:59,680 --> 01:56:04,330
It works like a normal enumerable
'thing' but you've built it programmatically.

1529
01:56:04,340 --> 01:56:15,848
I can take advantage of that by saying:
each_child do |child| yielder.yield child

1530
01:56:15,850 --> 01:56:22,506
So yield all existing children to the
yielder, and then yield a new one.

1531
01:56:25,946 --> 01:56:32,720
I need to do some variable
re-names. It's fine but I think it's confusing.

1532
01:56:32,942 --> 01:56:34,750
So add a new child.

1533
01:56:34,764 --> 01:56:37,795
And then I'll say make a new enumerator.

1534
01:56:38,570 --> 01:56:40,533
It will not create an array.

1535
01:56:40,540 --> 01:56:44,720
This piece of code will just spin
over the old children and yield them.

1536
01:56:44,740 --> 01:56:46,540
And then will yield the new child.

1537
01:56:46,540 --> 01:56:49,191
Rather than building a new array here.

1538
01:56:49,220 --> 01:56:55,502
I can pass in my new enumeration of the children.

1539
01:56:56,880 --> 01:56:59,262
And that works.  DN: Very nice.

1540
01:56:59,431 --> 01:57:03,617
I think that's an efficient
way of mutating these trees.

1541
01:57:03,617 --> 01:57:07,550
To think of the children as
being enumerations of children.

1542
01:57:07,560 --> 01:57:10,000
And you can imagine
doing something similar...

1543
01:57:10,008 --> 01:57:13,146
If we had some kind of 'insert before'

1544
01:57:13,170 --> 01:57:21,395
You could do a thing here that says "if child
equals the one I'm supposed to be inserting before,

1545
01:57:21,390 --> 01:57:25,644
then yield the new one. And
after that yield the existing one."

1546
01:57:25,650 --> 01:57:30,408
If it's 'insert after' you can yield the old
child and then immediately yield the new one.

1547
01:57:30,480 --> 01:57:33,760
Adding it on to the end is the
easiest because we know where it goes.

1548
01:57:33,768 --> 01:57:36,488
But enumerating over the old collection

1549
01:57:36,510 --> 01:57:41,493
and inserting the new one
at the right time... allows us to...

1550
01:57:41,911 --> 01:57:47,250
If we wanted to insert a copy
of this after every existing child.

1551
01:57:47,250 --> 01:57:52,897
We can say "yield the old child and then
yield the new one", each time around the loop.

1552
01:57:52,970 --> 01:57:56,506
We can do any modification
to the tree that we want here.

1553
01:57:56,613 --> 01:57:58,740
But we're not actually modifying anything.

1554
01:57:59,280 --> 01:58:01,706
This has the nice structural sharing property

1555
01:58:01,710 --> 01:58:05,546
where this new new node that we are getting

1556
01:58:05,570 --> 01:58:09,688
is re-using the collection of
children that the old node had.

1557
01:58:09,710 --> 01:58:16,177
It isn't copying that array and adding
to it. It's holding on to it through each_child.

1558
01:58:16,170 --> 01:58:21,733
The new node has a child enumerator
that calls each_child on the old node,

1559
01:58:21,800 --> 01:58:25,724
and when it's finished enumerating
all of its children, it yields the new one.

1560
01:58:25,724 --> 01:58:29,217
That feels close to optimal to me.

1561
01:58:32,020 --> 01:58:36,311
It's not super efficient because when
you are doing things non-destructively,

1562
01:58:36,311 --> 01:58:42,370
you're expecting the garbage collector to do
the work of cleaning up all the old stuff for you.

1563
01:58:42,435 --> 01:58:50,810
But after the garbage collector has run,
we're not going to be using lots more memory.

1564
01:58:50,850 --> 01:58:55,493
If you want to compose a lot of trees
together, which this API allows you to do.

1565
01:58:55,570 --> 01:59:01,315
Every time you compose a tree into a
new one, you are not taking a copy of it.

1566
01:59:01,310 --> 01:59:08,337
You are holding on to a reference to it.
Which you would do anyway if it was mutable

1567
01:59:08,337 --> 01:59:12,533
And every time you make a change
it's creating just enough new stuff

1568
01:59:12,550 --> 01:59:17,715
and holding on to as much of the
old stuff as is necessary to make use of it.

1569
01:59:17,715 --> 01:59:21,680
I feel good that we have been
able to do that there.

1570
01:59:21,760 --> 01:59:32,728
So: "Use an enumerator to
create a add_children" I suppose.

1571
01:59:32,770 --> 01:59:33,608
How are we doing?

1572
01:59:33,620 --> 01:59:36,266
DN: I think that's a good place to wrap up.

1573
01:59:36,275 --> 01:59:41,004
Thanks Tom, it's been very
interesting watching you work.

1574
01:59:41,004 --> 01:59:43,800
TS: Thanks for having me, it has been really good fun.

1575
01:59:43,800 --> 01:59:50,004
Captions produced by Bonnie Roworth
