1
00:00:01,570 --> 00:00:07,360
Welcome to Peer to Peer, where you
can watch how experts solve tech problems.

2
00:00:07,370 --> 00:00:09,200
Our guest today is Camille Baldock

3
00:00:09,600 --> 00:00:12,970
who by day writes Ruby and
JavaScript for the British Government.

4
00:00:13,060 --> 00:00:18,260
And by night mentors junior developers and
teaches programming in schools.

5
00:00:18,260 --> 00:00:20,340
Our host is Tom Stuart.

6
00:00:20,391 --> 00:00:22,995
And the challenge that we set
for Camille is called

7
00:00:22,995 --> 00:00:25,090
Ranking Poker Hands

8
00:00:25,910 --> 00:00:29,220
TS: So Camille, would you like to
read out the problem statement?

9
00:00:29,490 --> 00:00:34,266
CB: Sure. A"hand" in poker consists of five
playing cards drawn from a standard deck.

10
00:00:34,746 --> 00:00:37,831
Apparently today I'm going to implement a
system which can decide which of two

11
00:00:37,830 --> 00:00:44,737
hands has the highest ranking, according
to standard poker ranking rules.

12
00:00:44,740 --> 00:00:46,720
Do you know the standard
poker ranking rules?

13
00:00:46,728 --> 00:00:48,450
CB: I do!  Which is fortunate.

14
00:00:48,453 --> 00:00:53,560
CB: OK, right, so this is nice and vague!

15
00:00:54,740 --> 00:01:00,480
CB: If I'm doing something like
that I need some way of knowing

16
00:01:00,480 --> 00:01:05,537
this is hand A and this is
hand B and the program will sort it out.

17
00:01:05,610 --> 00:01:10,684
And I need to think of how to tell people
to tell me what their hand looks like.

18
00:01:10,693 --> 00:01:14,035
TS: OK

19
00:01:14,340 --> 00:01:19,822
The first 'off the top of my head', easy
thing, is to have and array of 5 things

20
00:01:19,822 --> 00:01:26,090
that says I have a 5 of Hearts
and the 6 of Diamonds.

21
00:01:26,106 --> 00:01:33,710
I could represent that as ['4H', '5D'].
(4 Hearts 5 Diamonds).

22
00:01:33,760 --> 00:01:38,115
Put that in an array and then
two arrays. And create the problem

23
00:01:38,110 --> 00:01:38,782
TS: OK.

24
00:01:38,782 --> 00:01:44,222
CB: So we'll get started with that.

25
00:01:44,420 --> 00:01:47,831
So, I'm just going to switch to
where I put code.

26
00:01:50,462 --> 00:01:52,497
We'll have our own folder today.

27
00:01:54,110 --> 00:01:58,088
What I'm going to do is make
sure I've got a couple of things in place

28
00:01:58,080 --> 00:02:02,690
Like a spec_helper.rb.
And then, we can get started.

29
00:02:06,110 --> 00:02:13,520
The first thing I want to do is enter some
kind of array 'thing' and it creates...

30
00:02:13,528 --> 00:02:16,977
I don't know what it creates.

31
00:02:16,990 --> 00:02:20,204
So, if I'm going to be comparing hands...

32
00:02:20,204 --> 00:02:24,666
A hand has several cards in it, and I
need some way to represent what a card is

33
00:02:24,710 --> 00:02:27,066
and a hand that has several cards in it.

34
00:02:27,060 --> 00:02:30,820
And then I want to be taking
the hand, and taking the other Hand object

35
00:02:30,880 --> 00:02:32,986
and then somehow comparing them.

36
00:02:33,000 --> 00:02:38,862
So the first thing I probably want to have
in place is some kind of Hand object

37
00:02:38,880 --> 00:02:43,155
and some kind of Card
object in which I can put 'things'.

38
00:02:43,155 --> 00:02:46,480
Yes, so we can go ahead and start that.

39
00:02:47,582 --> 00:02:51,650
So the first thing I want to do is...

40
00:02:51,820 --> 00:02:54,520
I have an array that says
5H and 6 Diamond.

41
00:02:54,570 --> 00:03:01,066
And on the other end, and this is my Hand
object with those card 'things' inside it.

42
00:03:01,075 --> 00:03:03,050
So we'll start with that I think.

43
00:03:04,000 --> 00:03:06,920
TS: Are you talking about
an array of strings?

44
00:03:06,920 --> 00:03:09,150
CB: As an input or...
TS: Yes

45
00:03:11,973 --> 00:03:16,044
CB: I'm not too concerned about that at
the moment. I don't think it matters much,

46
00:03:16,044 --> 00:03:20,337
Since I don't want to keep them as an array
of strings, but do interesting things

47
00:03:20,330 --> 00:03:22,008
afterwards. So I don't think it should
matter that much.

48
00:03:22,026 --> 00:03:25,050
TS: So this is just going
to be a serialisation format.

49
00:03:25,057 --> 00:03:30,250
CB: Yes, a hand parser type thing.
Let's call it that.

50
00:03:31,420 --> 00:03:35,100
So, if I have a hand parser 'thing'.

51
00:03:36,340 --> 00:03:41,440
Ok, so this is the 'I can't type moment'.
[laughter]

52
00:03:42,250 --> 00:03:46,770
So if we have some kind
of object called HandParser

53
00:03:51,770 --> 00:03:59,440
It probably should 'parses the
array of strings representing the cards'

54
00:03:59,440 --> 00:04:03,848
(this is quite verbose),
but let's get to that.

55
00:04:03,840 --> 00:04:08,542
Actually this is going to
fail so how about we run this.

56
00:04:08,570 --> 00:04:13,377
And this is not very happy and
'uninitialized constant HandParser'

57
00:04:13,420 --> 00:04:16,890
Yes, this is my first failure -
here we go!

58
00:04:18,450 --> 00:04:22,020
So I'm going to have to
have a HandParser sitting somewhere.

59
00:04:22,530 --> 00:04:25,090
I need to create that file in there.

60
00:04:25,850 --> 00:04:28,770
And let's create a  parser
that does absolutely nothing.

61
00:04:29,280 --> 00:04:35,970
But that should make my test happy enough,
unless I don't require it, obviously.

62
00:04:36,080 --> 00:04:39,928
Because otherwise it wouldn't know
where to look.

63
00:04:40,020 --> 00:04:44,791
So let's give that a try... OK, zero
examples, zero failures. So far so good.

64
00:04:45,710 --> 00:04:48,808
What I probably want to do is...

65
00:04:48,840 --> 00:04:56,778
If I create a HandParser and I give it the
array of strings that will represent cards

66
00:04:56,778 --> 00:05:02,181
then on the other hand I want
to check what the output of that is.

67
00:05:02,180 --> 00:05:10,334
Let's have... so the subject is
HandParser, so if we have described_class.

68
00:05:10,340 --> 00:05:15,920
If I create HandParser and hopefully
have some kind of thing that says parse

69
00:05:16,590 --> 00:05:22,785
and it will take the array
of cards, which I need to define.

70
00:05:24,523 --> 00:05:27,400
Let's have a look at how
I'm going to put those cards in.

71
00:05:27,403 --> 00:05:32,058
So we can have those as
5 Hearts 6 of Diamonds.

72
00:05:32,545 --> 00:05:35,258
That's not an array [Laughter].

73
00:05:38,370 --> 00:05:40,436
You choose the cards.

74
00:05:40,480 --> 00:05:42,167
TS: King, Queen, Ace.

75
00:05:45,310 --> 00:05:53,338
CB: Yes, King of Spades, what's
the other suit? Clubs, that's the one.

76
00:05:53,370 --> 00:05:59,323
So Queen of Clubs, and then we can have...
let's have an annoying card in there.

77
00:05:59,330 --> 00:06:01,800
Just so we have a bit of fun.

78
00:06:02,269 --> 00:06:04,340
Which is Ace.

79
00:06:08,280 --> 00:06:13,607
Let's keep Ace as one and see where that
takes us. I reckon that matters somehow.

80
00:06:13,740 --> 00:06:17,709
But I have no idea, so we shall see.

81
00:06:17,700 --> 00:06:20,792
And this should give me
some kind of 'thing'.

82
00:06:22,087 --> 00:06:26,443
This is already going to fail so I'm not
even going to put an expectation in there

83
00:06:26,440 --> 00:06:30,705
I'm going to go ahead and run my tests and
this should fail nicely, because

84
00:06:30,700 --> 00:06:32,414
I don't have a method parse.

85
00:06:32,421 --> 00:06:33,229
TS: OK.

86
00:06:33,220 --> 00:06:34,331
[Camille types]

87
00:06:39,080 --> 00:06:44,661
If I have a method parse that
takes an array of things (cards).

88
00:06:44,660 --> 00:06:46,540
It's not these things.

89
00:06:46,540 --> 00:06:47,897
[Camille ponders]

90
00:06:53,410 --> 00:06:57,658
Well - this test tests nothing.
But at least it's not erroring any more.

91
00:06:57,650 --> 00:07:01,450
On the other hand -
I want it to be a hand and...

92
00:07:05,629 --> 00:07:09,338
I want this to be some
kind of Hand object type of thing.

93
00:07:09,330 --> 00:07:10,811
So... [Camille ponders]

94
00:07:13,000 --> 00:07:15,450
So, I want to create
a Hand object type of thing.

95
00:07:15,450 --> 00:07:16,320
TS: OK.

96
00:07:20,250 --> 00:07:22,080
Oh, how do we even do this in RSpec.

97
00:07:23,480 --> 00:07:26,603
I don't want to do
something like this, right.

98
00:07:26,620 --> 00:07:29,690
How do you get a thing and
check the class of it?

99
00:07:29,690 --> 00:07:34,400
Actually, do I even care about the class
of it? No, I care about how it quacks.

100
00:07:34,407 --> 00:07:42,807
So I expect:
(hand.cards.count).to equal 5

101
00:07:42,800 --> 00:07:45,432
And actually...

102
00:07:45,454 --> 00:07:51,687
this doesn't test that anymore
so let's rewire this thing a little bit.

103
00:07:51,690 --> 00:07:59,309
We'll just give this 5 cards
and it returns back a hand of cards.

104
00:07:59,300 --> 00:08:04,254
So here we want it to have exactly
the same number of things that we have.

105
00:08:04,250 --> 00:08:08,749
I'm going to gloss over the issue where I
give it an array that only has 4 cards

106
00:08:08,749 --> 00:08:11,770
and it falls over.
Let's just not go there for now!

107
00:08:11,780 --> 00:08:15,876
We'll just assume that our users
are going to put correct things in there.

108
00:08:15,870 --> 00:08:17,054
TS: OK.

109
00:08:17,956 --> 00:08:22,530
CB: So yes let's just start with
that, this will already fail quite nicely.

110
00:08:27,930 --> 00:08:28,940
Right, excellent.

111
00:08:31,620 --> 00:08:36,945
This needs to return a thing
that quacks .cards

112
00:08:37,050 --> 00:08:38,770
TS: OK.

113
00:08:38,770 --> 00:08:42,843
[Silence]

114
00:08:51,600 --> 00:08:55,396
Look at me failing... that's
sublime, beautiful. [laughter]

115
00:08:57,710 --> 00:09:04,560
OK, so if it has that then... This should
complain for different reasons now.

116
00:09:05,780 --> 00:09:08,720
No, wrong shortcut, OK

117
00:09:08,740 --> 00:09:13,083
uninitialized constant
HandParser::Hand... so far so good.

118
00:09:16,050 --> 00:09:21,338
This doesn't know what Hand
is so let's quickly require it.

119
00:09:21,738 --> 00:09:23,570
And now back to our tests.

120
00:09:27,512 --> 00:09:30,785
OK, undefined method count,
it has nothing in it.

121
00:09:30,780 --> 00:09:36,298
Right, so...

122
00:09:36,510 --> 00:09:39,900
This should fail for a slightly
nicer reason now.

123
00:09:39,900 --> 00:09:43,112
[Silence]

124
00:09:43,130 --> 00:09:46,487
So now we have an array that has nothing
in it. And we should have 5 things.

125
00:09:46,480 --> 00:09:51,490
and now I'll actually implement
the things because it's about time!

126
00:09:51,498 --> 00:09:54,552
So if we have an array of cards
and it has 5 things,

127
00:09:54,552 --> 00:09:59,054
then what I want to do is
create a hand with some cards in it.

128
00:09:59,060 --> 00:10:05,949
So if we have some 'thing'
that takes the array of cards

129
00:10:10,270 --> 00:10:14,807
which is essentially an array of string
cards, or however you want to call that.

130
00:10:15,040 --> 00:10:20,274
And I want it to basically...
[Camille ponders]

131
00:10:23,060 --> 00:10:28,365
from that string of card be able to
say, make me a Card object type 'thing'.

132
00:10:28,400 --> 00:10:29,702
TS: Right.

133
00:10:29,850 --> 00:10:32,460
and then eventually I'll want
to feed it into Hand.

134
00:10:32,580 --> 00:10:34,640
but one thing at a time.

135
00:10:34,770 --> 00:10:38,194
OK, so that can live here.

136
00:10:38,200 --> 00:10:45,600
So if I have make_card thing, this is
going to move to Card object later.

137
00:10:45,600 --> 00:10:47,062
Let's get to that in a second.

138
00:10:47,062 --> 00:10:48,674
TS: OK.

139
00:10:49,770 --> 00:10:53,737
I don't like the interface of
this, it is quite unnatural.

140
00:10:53,730 --> 00:10:57,485
I quite like the fact that my parsing
logic is going to sit somewhere else.

141
00:10:57,480 --> 00:11:00,194
I don't want to have to do
crazy regexes and things like that

142
00:11:00,205 --> 00:11:03,440
as part of a thing that is
supposed to be comparing cards.

143
00:11:03,450 --> 00:11:07,851
But, at the same time, like
here, I'm creating a new card.

144
00:11:07,851 --> 00:11:11,462
TS: So why are you approaching it in
this particular way?

145
00:11:11,460 --> 00:11:15,382
if you're saying you don't want this
method here, why are you putting it here?

146
00:11:15,390 --> 00:11:23,977
CB: I'm not quite sure what my Card.new
method should be accepting.

147
00:11:23,980 --> 00:11:28,468
In a perfect world, I would like it
to say 'if it's a 5 of Diamond' it takes

148
00:11:28,480 --> 00:11:32,800
Card.new 5 and a
Diamond symbol type thing.

149
00:11:33,200 --> 00:11:38,845
So I want a bit of pre-processing to check
that there are 2 things in this string.

150
00:11:38,902 --> 00:11:42,000
And H maps to Hearts,
and something like that.

151
00:11:42,011 --> 00:11:42,540
TS: Fine

152
00:11:42,540 --> 00:11:42,651
CB: So this is where I want this to live. I'm not quite sure yet.
TS: Fine

153
00:11:42,651 --> 00:11:46,011
CB: So this is where I want this to live.
I'm not quite sure yet.

154
00:11:46,057 --> 00:11:50,308
TS: So you're expecting that later you'll
have a better idea of what's going on.

155
00:11:50,308 --> 00:11:50,960
CB: Yes.

156
00:11:50,971 --> 00:11:54,800
TS: OK let's see what happens.

157
00:11:54,811 --> 00:12:01,497
CB: OK, so this is a thing,
and it takes a card string.

158
00:12:01,510 --> 00:12:06,491
And, if I remember rightly, my card
string has 5 H or something like that.

159
00:12:06,490 --> 00:12:09,794
So what I'm going to do is...

160
00:12:09,800 --> 00:12:18,674
Card.new and I'm taking card_string[0]
card_string[1] but actually not.

161
00:12:20,971 --> 00:12:26,251
How do I want my cards to look,
how do I want them to quack.

162
00:12:27,080 --> 00:12:32,765
It's going to be easier for me as a
human, to have my suits (as in Hearts/Diamonds etc)

163
00:12:32,777 --> 00:12:34,880
written out in plain letters
not as H and D etc.

164
00:12:34,880 --> 00:12:35,942
TS: OK

165
00:12:36,140 --> 00:12:42,651
I just want to do a very quick
pre-parsing of...

166
00:12:42,710 --> 00:12:52,377
if this is 'h' then just give me
:heart. and this is 'd' give me :diamond.

167
00:12:52,380 --> 00:12:57,828
Actually, this could very well live in
a hash, why am I doing a terrible switch?

168
00:12:57,828 --> 00:13:02,034
Let's have a hash sitting here.

169
00:13:02,050 --> 00:13:13,142
We have all the suits, so we
have H, Diamonds, Clubs, Spades.

170
00:13:13,268 --> 00:13:14,370
That seems correct.

171
00:13:14,742 --> 00:13:16,548
TS: That's all of them yes.

172
00:13:16,540 --> 00:13:17,691
[Camille types]

173
00:13:20,910 --> 00:13:23,908
CB: This is the slightly tedious
typing part.

174
00:13:23,940 --> 00:13:30,605
Oh right! Spades, cool.

175
00:13:30,660 --> 00:13:33,668
So, this goes bye bye.

176
00:13:33,690 --> 00:13:39,280
TS: So now you can just look up with a
hash rather than using a switch statement.

177
00:13:39,310 --> 00:13:44,994
CB: I want it to fall over quite loudly,
if I have something crazy as my suit.

178
00:13:45,110 --> 00:13:47,220
TS: How are you going to
make it fall over?

179
00:13:47,220 --> 00:13:54,548
CB: With fetch. If I put, say, '5a' in
there, fetch is going to complain

180
00:13:54,570 --> 00:14:00,297
because there is no suit with key 'a'
and therefore it will throw an exception.

181
00:14:00,298 --> 00:14:02,057
This is a bit...

182
00:14:02,057 --> 00:14:05,970
I should probably be handling this in a
more graceful way than doing that.

183
00:14:05,970 --> 00:14:10,308
I definitely don't want to have a default
value because there's no such thing.

184
00:14:10,340 --> 00:14:12,420
I should be thinking about things like,

185
00:14:12,770 --> 00:14:15,890
do I want capital H in
there and little things like that.

186
00:14:15,890 --> 00:14:20,891
But for now I'm doing it with
the minimum viable array string parser.

187
00:14:20,902 --> 00:14:22,400
And see where that takes me.

188
00:14:22,410 --> 00:14:28,548
TS: So your motivation here sounds
like you don't want it to silently fail?

189
00:14:28,548 --> 00:14:30,600
If there's bad input,
you want it to complain.

190
00:14:30,600 --> 00:14:31,910
CB: Yes, that's it.

191
00:14:31,910 --> 00:14:36,937
In the same way here for
example, it takes the first symbol.

192
00:14:36,960 --> 00:14:41,634
So if someone puts H5 for example, that
would also fail quite loudly.

193
00:14:41,702 --> 00:14:45,470
If someone puts HH however,
it's not going to fail loudly.

194
00:14:46,540 --> 00:14:52,308
But, I'm not in a statically typed language
and I don't want to spend time on it now.

195
00:14:52,540 --> 00:14:55,260
I'll clean it up a bit later.

196
00:14:56,280 --> 00:15:00,308
What I would usually do If I'm
writing things I want to ship is...

197
00:15:02,140 --> 00:15:14,445
I would put a TODO and 'fail loudly and
with better errors with unexpected inputs'.

198
00:15:14,440 --> 00:15:24,068
much in the same way I would probably
be happy having #TODO: fail nicely when not 5.

199
00:15:25,177 --> 00:15:26,491
TS: Right.

200
00:15:28,420 --> 00:15:33,188
CB: There's other things, like: if there's
two 5 of Hearts, you have a cheat!

201
00:15:33,310 --> 00:15:35,850
And things like that,
but let's not even go there!

202
00:15:35,850 --> 00:15:39,691
Let's assume that that our players
are trying to be honest, at least.

203
00:15:39,710 --> 00:15:45,428
TS: we'll, I don't know enough about the
variance of Poker to say whether that's illegal.

204
00:15:45,480 --> 00:15:48,514
CB: I think if you have one deck
and you have two 5 of Hearts

205
00:15:48,570 --> 00:15:52,228
you can reasonably assume that
somebody's messing with the game.

206
00:15:52,230 --> 00:15:54,000
TS: Fair enough.

207
00:15:54,170 --> 00:15:59,062
CB: So that's going to fail quite nicely because
I'm obviously missing quite a lot of objects.

208
00:15:59,325 --> 00:16:03,074
But let's see where it's failing.

209
00:16:03,390 --> 00:16:08,662
So, undefined method...
Oh of course, I did something...

210
00:16:09,680 --> 00:16:15,131
Here I'm assuming that make_card
is available on my string, which it isn't.

211
00:16:15,450 --> 00:16:18,731
TS: You don't want to make it available.

212
00:16:18,770 --> 00:16:21,862
I thought you were going to
do some monkey patching and...

213
00:16:24,050 --> 00:16:27,611
Well, if you want to do it
for fun, to do crazy things, [laughter]

214
00:16:27,680 --> 00:16:37,245
and then see how I fail later, then sure,
but I love myself too much to do that to myself.

215
00:16:42,940 --> 00:16:46,640
So, "uninitialized constant..."
Here we go.

216
00:16:46,640 --> 00:16:49,880
Now it's complaining that
we don't have whatever that is.

217
00:16:49,950 --> 00:16:52,500
so we should re-create a
'whatever that is'.

218
00:16:54,240 --> 00:16:57,817
card.rb and for now, to be honest

219
00:16:57,828 --> 00:17:02,580
I don't see it doing anything
really smart so it's just going to have...

220
00:17:03,794 --> 00:17:09,805
It's called 'Pips' in English, that's the
number on the face of the card, is it not?

221
00:17:09,820 --> 00:17:14,811
TS: I think I've heard the word
'rank' but 'Pips' also seems sensible.

222
00:17:14,840 --> 00:17:17,120
I'm going to stick with 'Pips'.

223
00:17:17,120 --> 00:17:21,280
I reckon, since I'm also doing hand
ranker, rank is going to confuse things.

224
00:17:21,280 --> 00:17:25,177
TS: Oh... that's a good point.
Separate words for separate ideas.

225
00:17:26,850 --> 00:17:29,771
CB: I hear that's helpful. [laughter]

226
00:17:33,570 --> 00:17:38,060
OK, so I have some kind of
silly strap that doesn't do much here.

227
00:17:39,250 --> 00:17:42,820
I just want to acquire it -
rather than leave it sitting around here.

228
00:17:43,400 --> 00:17:46,137
And let's go back to our spec.

229
00:17:50,020 --> 00:17:56,034
Excellent, we still have nothing and that is
simply because I still haven't implemented it.

230
00:17:57,634 --> 00:18:05,890
Now Hand takes cards and we're
just going to initialize it with cards.

231
00:18:07,870 --> 00:18:09,130
I can get rid of that.

232
00:18:11,020 --> 00:18:14,617
And make that cards available.

233
00:18:18,540 --> 00:18:22,160
This should hopefully stop complaining.

234
00:18:23,554 --> 00:18:28,620
No, because it did a zero
failure, so that is the one I want.

235
00:18:28,620 --> 00:18:29,965
[Camille ponders]

236
00:18:33,080 --> 00:18:34,570
Let's have a look.

237
00:18:35,640 --> 00:18:43,165
I'm creating my hand...
[sounds of realization]

238
00:18:43,730 --> 00:18:46,820
My favorite one is also to spell
initialize with 's'.

239
00:18:46,820 --> 00:18:49,954
And then I spend 2 minutes thinking...
Oh! American spelling.

240
00:18:49,954 --> 00:18:50,940
TS: Yes.

241
00:18:50,940 --> 00:18:53,954
[Silence]

242
00:18:54,000 --> 00:18:56,468
CB: Yes, good, slightly more
convincing isn't it?

243
00:18:56,468 --> 00:18:58,605
TS: Yes, very good.

244
00:18:59,290 --> 00:19:02,685
CB: I now have some 'thing' and
it has the right number of things.

245
00:19:02,685 --> 00:19:06,700
I don't actually know that
it does parse the cards correctly.

246
00:19:07,250 --> 00:19:11,680
And if the array looks
like I want it to look.

247
00:19:11,680 --> 00:19:14,920
so what I can do is...

248
00:19:15,540 --> 00:19:20,514
Because, currently my parser
doesn't care how many cards I'm parsing in

249
00:19:21,120 --> 00:19:28,411
I can do a very quick check so
it returns the right cards as a test.

250
00:19:28,410 --> 00:19:31,017
I can just do a very quick...

251
00:19:31,051 --> 00:19:37,851
And if my array_of_cards is
just the one, let's say 6 of Diamonds.

252
00:19:38,050 --> 00:19:43,268
Then I go for exact the same test.

253
00:19:43,570 --> 00:19:45,450
And what I want is...

254
00:19:46,080 --> 00:19:48,200
I take my hand, I take the cards in there.

255
00:19:48,680 --> 00:19:54,840
I take the first one and I
want to check the suit is Diamonds

256
00:19:56,200 --> 00:19:59,540
I also want to check that
my Pips are equal to six.

257
00:19:59,690 --> 00:20:00,210
TS: OK.

258
00:20:00,620 --> 00:20:03,908
CB: And I reckon we're
going to have a surprising 'thing'

259
00:20:03,908 --> 00:20:07,565
because I haven't cast it to an
integer or anything like that.

260
00:20:10,220 --> 00:20:18,045
Since I want to compare them, it's easier
to do if they're integers than strings

261
00:20:18,045 --> 00:20:20,520
Yes, expected an integer and got a string!

262
00:20:21,280 --> 00:20:26,210
What I'm going to do is not really
good practice,

263
00:20:26,340 --> 00:20:30,320
but that should please it for now.

264
00:20:30,400 --> 00:20:35,470
So now I can have a 'thing' and
when I put several things in there,

265
00:20:35,620 --> 00:20:39,302
it puts them in a hand with cards,
and then I can check

266
00:20:39,314 --> 00:20:41,931
that if I do put a card
it seems relatively OK.

267
00:20:42,262 --> 00:20:48,670
If I wanted to be really exhaustive I would go
through and check Spades, check Hearts, check Clubs.

268
00:20:48,680 --> 00:20:51,794
Just to see that that matching is OK.

269
00:20:51,794 --> 00:20:55,737
And that would give me a bit more
certainty about what on Earth I am doing!

270
00:20:55,740 --> 00:20:57,302
TS: Ok.

271
00:20:57,340 --> 00:21:01,211
But that kind of does the thing,
that is good enough.

272
00:21:01,250 --> 00:21:04,370
Now I'm going to start focusing on...

273
00:21:05,510 --> 00:21:08,982
If I have those two hand objects
and I can look at cards on them.

274
00:21:08,982 --> 00:21:13,051
And I have a nice interface with
my cards, it gives me Pips and Suits

275
00:21:13,074 --> 00:21:14,930
How do I compare them?

276
00:21:15,554 --> 00:21:19,405
This is time to step away from
the computer for a second.

277
00:21:19,410 --> 00:21:24,811
TS: Yes, it felt like this was an
administrative thing you needed to do.

278
00:21:24,820 --> 00:21:29,965
Your warmed up now. You can make two hands
of cards. Now it's time to compare them?

279
00:21:29,988 --> 00:21:31,908
CB: Yes, that's about it.

280
00:21:34,400 --> 00:21:40,148
The first thing we can do is
have some way of having a hand,

281
00:21:40,148 --> 00:21:45,748
and it tells me 'you have a Flush' or 'you
have a Pair' and that is actually your best thing.

282
00:21:45,740 --> 00:21:50,171
Not just 'you still happen to have a
Pair' because the last thing I want to do is...

283
00:21:50,170 --> 00:21:54,582
I have a card that has, for example,
3 of a kind which is better than 2 of a kind

284
00:21:54,594 --> 00:22:00,308
which I'm assuming you know,
which isn't very nice [laughter]

285
00:22:00,340 --> 00:22:04,720
TS: I am roughly familiar with
the rules of Poker.

286
00:22:04,800 --> 00:22:09,097
CB: I'll keep being unnecessarily verbose,
if you get bored you can stop me.

287
00:22:09,120 --> 00:22:11,680
TS: No, no, talk me through it.

288
00:22:11,970 --> 00:22:15,245
CB: If I have 3 of a kind, the last thing
I want is for my hand to tell me

289
00:22:15,257 --> 00:22:20,114
"We have 2 of a kind, excellent!"
when the best I could do is 3 of a kind.

290
00:22:20,120 --> 00:22:24,330
TS: So for any individual hand there
might be several possible classifications

291
00:22:24,330 --> 00:22:29,611
of the cards in it, but we want to use the one that's
most likely to cause this hand to beat another one.

292
00:22:29,620 --> 00:22:36,022
CB: Yes, you want the highest possible
rank of things you can get in Poker.

293
00:22:36,050 --> 00:22:43,394
so if I have 4 fours then I want 4 of a kind,
not 3 of a kind, and definitely not a Pair.

294
00:22:43,417 --> 00:22:47,748
Definitely not a high card.

295
00:22:50,540 --> 00:22:57,714
TS: It sounds like your first line
of interest, is classifying these hands

296
00:22:57,710 --> 00:23:02,434
according to what kind they are.
How were you expecting to approach that?

297
00:23:02,520 --> 00:23:06,220
CB: Essentially I want to look at a
hand and it gives me what the rank is.

298
00:23:06,220 --> 00:23:08,340
so it tells me if it's
a straight or thing.

299
00:23:08,970 --> 00:23:13,668
So it feels to me like we're going to
have some kind of rank method on the Hand

300
00:23:13,668 --> 00:23:17,725
that is going to return a "and this
is the thing that you can do with it".

301
00:23:17,720 --> 00:23:20,502
That is the best possible one.

302
00:23:22,970 --> 00:23:25,440
which we can half implement for now.

303
00:23:25,474 --> 00:23:28,354
The first thing I'm going to
do is create a spec for my Hand,

304
00:23:28,377 --> 00:23:31,245
because we're going to start
adding stuff to that.

305
00:23:33,530 --> 00:23:38,480
Quick housekeeping. TS: Yes.

306
00:23:38,680 --> 00:23:41,828
CB: And I'm going to be
describing my Hand.

307
00:23:42,850 --> 00:23:49,862
And, I want some kind of method
I'll call it 'Rank'.

308
00:23:51,680 --> 00:23:56,868
I have no particular reason to know
whether that's a good idea or not now.

309
00:23:56,910 --> 00:24:02,011
So I'll keep it as it is.
And what it does is

310
00:24:02,034 --> 00:24:15,330
it returns the best type of hand
from it's own cards.

311
00:24:19,702 --> 00:24:24,110
There is no way I'm going to implement in
just one test, all the rules of Poker.

312
00:24:24,110 --> 00:24:25,245
TS: OK. [laughter]

313
00:24:25,245 --> 00:24:32,410
CB: I'm going to assume that I'm playing in
a simplified world where the only thing is a pair.

314
00:24:32,600 --> 00:24:34,430
Which seems easy.

315
00:24:35,370 --> 00:24:41,405
And I might regret this because maybe it's
not the easiest choice I could have made.

316
00:24:41,400 --> 00:24:45,920
[Silence]

317
00:24:45,931 --> 00:24:49,977
I'm not going to put in a context
for now I'm not sure where I'm going.

318
00:24:49,980 --> 00:24:54,491
So, I have a Hand and...

319
00:24:54,500 --> 00:24:57,840
[Camille ponders]

320
00:24:58,090 --> 00:25:03,885
So this is where things get
a bit annoying. What I want is...

321
00:25:05,382 --> 00:25:13,280
I have some kind of hand around.
And what I want on that hand is...

322
00:25:14,850 --> 00:25:17,240
For now I'm going to use the HandParser.

323
00:25:17,428 --> 00:25:20,560
Which makes me feel this is
not the right interface for the problem,

324
00:25:20,580 --> 00:25:29,851
if I have to use it in such a way, but if
I have say, 5 of Hearts, 5 of Diamonds.

325
00:25:30,140 --> 00:25:35,200
We're actually going to take a
Pair. And see where it takes us.

326
00:25:35,540 --> 00:25:38,594
7 of Diamonds, 8 of Diamonds.

327
00:25:38,590 --> 00:25:39,931
[Camille ponders]

328
00:25:46,811 --> 00:25:52,980
This should just say "we have a Pair
and by the way that Pair is a Pair of 5s".

329
00:25:53,620 --> 00:25:57,405
For now let's start with
'you have a Pair' in there.

330
00:25:57,417 --> 00:26:00,605
TS: As you said,
that might be enough information.

331
00:26:00,620 --> 00:26:04,354
If there's another hand that doesn't have
a Pair in it, you've already determined that.

332
00:26:04,354 --> 00:26:05,554
CB: Yes, that's exactly it.

333
00:26:05,570 --> 00:26:08,970
The first thing you want to
know is do I have a better hand?

334
00:26:09,200 --> 00:26:14,914
and then if your two hands are not the
same rank, then you try calculating it.

335
00:26:15,260 --> 00:26:20,594
My initial reckoning is that it will be
easier to calculate what the highest card is

336
00:26:20,605 --> 00:26:22,754
at the time I'm also establishing
the rank.

337
00:26:23,060 --> 00:26:29,165
So for now I want my interface
to just return the type of hand.

338
00:26:29,170 --> 00:26:35,382
But later I'll want it to say, this is the
type of hand and this is the highest card.

339
00:26:35,530 --> 00:26:38,982
Just in case there's a tie. TS: Alright.

340
00:26:40,910 --> 00:26:45,737
CB: Let's assume that's my hand
and I want hand.rank.

341
00:26:47,130 --> 00:26:53,131
So 'expect' hand.rank  to equal,
and then...

342
00:26:57,910 --> 00:27:08,920
It turns information about
the winning potential of the hand.

343
00:27:09,200 --> 00:27:11,140
This is a terrible description!

344
00:27:11,140 --> 00:27:14,022
[Silence]

345
00:27:14,820 --> 00:27:17,782
I'm just going to let it go,
because in a minute

346
00:27:17,800 --> 00:27:21,540
I will probably change my
mind about what this should look like.

347
00:27:21,540 --> 00:27:25,948
[Camille ponders]

348
00:27:26,050 --> 00:27:30,011
So if I expect the hand equals that...

349
00:27:31,260 --> 00:27:32,540
Not that.

350
00:27:34,590 --> 00:27:42,034
This is failing quite nicely because
I haven't done all my requiring correctly.

351
00:27:42,030 --> 00:27:46,382
[Camille ponders]

352
00:27:47,040 --> 00:27:50,590
I'm doing silly thing with
silly shortcuts here [laughter].

353
00:27:51,800 --> 00:27:54,600
I also don't have my HandParser.

354
00:27:55,910 --> 00:28:00,662
What I don't like about that is
that now I can call this extra class

355
00:28:00,662 --> 00:28:04,285
and I have this extra thing
that has all this logic here.

356
00:28:04,310 --> 00:28:09,005
So rethinking it now I would
probably move that logic around.

357
00:28:09,000 --> 00:28:16,788
And have my hand.new
that handles things like that.

358
00:28:16,810 --> 00:28:28,217
And my hand.new can take a HandParser as
one of it's attributes of the method.

359
00:28:28,770 --> 00:28:32,930
and I can make sure that
the logic of if it's H it's Hearts,

360
00:28:32,970 --> 00:28:36,011
and if it's D it's Diamonds,
just goes somewhere else.

361
00:28:36,020 --> 00:28:38,330
I'm not happy about that interface.

362
00:28:43,200 --> 00:28:47,417
Because I don't like stopping in
the middle of a 'thing' #TODO...

363
00:28:48,400 --> 00:28:52,810
This is not a nice interface,
not what I wanted to do.

364
00:28:52,845 --> 00:28:55,450
TS: So your queuing up a bit of
re-factoring to do?

365
00:28:56,710 --> 00:29:00,450
CB: Yes, my tests have passed so
I can't afford to just go off on a tangent

366
00:29:00,650 --> 00:29:02,480
and go to fix all the things.

367
00:29:04,410 --> 00:29:07,017
So let's just have a quick...

368
00:29:07,010 --> 00:29:16,937
[Silence]

369
00:29:16,940 --> 00:29:22,217
OK, so that's parsing,
and that's failing. Cool.

370
00:29:22,217 --> 00:29:27,810
rank returns nil which is pretty much
what you'd expect because it returns nil.

371
00:29:27,900 --> 00:29:32,948
OK, so I've got all my cards,
and how do I want to detect a Pair?

372
00:29:33,370 --> 00:29:39,120
Array of cards - if I want to detect a
Pair, all I care about is the Pips on the cards.

373
00:29:40,720 --> 00:29:46,102
I have all the cards, I can look
at how many Pips there are for each of those cards

374
00:29:46,102 --> 00:29:53,314
and I can count for each possible
Pip value, how many of that Pip I have.

375
00:29:53,314 --> 00:29:53,782
TS: OK.

376
00:29:53,782 --> 00:30:00,680
So if I have say, 55678 here.

377
00:30:01,970 --> 00:30:05,074
There was 2 x 5s, 1 x 6, 1 x7 and 1 x 8

378
00:30:05,074 --> 00:30:09,908
TS: I see so you're counting
them by how many Pips they have.

379
00:30:09,910 --> 00:30:14,365
You want to somehow say
I've got 2 x 5s, I've got 1 x 6 etc.

380
00:30:14,370 --> 00:30:17,165
CB: Yes, I want some kind of Pip counter

381
00:30:17,180 --> 00:30:20,788
that sort of mashes them up in
some structure it can read nicely.

382
00:30:24,650 --> 00:30:30,422
Ideally, if I had a thing like that then I
would have something along the lines of...

383
00:30:31,180 --> 00:30:38,937
I'm going to do that as a hash but I would
expect my result to look a bit like this.

384
00:30:38,970 --> 00:30:41,600
I would like a magical
thing that does that for me.

385
00:30:43,940 --> 00:30:53,462
And once I have that then I can check if I
have any things that so happen to have 2 of the 'thing'.

386
00:30:53,480 --> 00:30:59,542
And if I do then it's a Pair.
Otherwise, it's a highest card.

387
00:30:59,730 --> 00:31:00,910
So that's about it.

388
00:31:02,020 --> 00:31:04,040
I want to implement a thing
that does that.

389
00:31:04,850 --> 00:31:06,780
So what does this do?

390
00:31:09,740 --> 00:31:14,262
I would say it's a 'Pip counter',
but it's not a great word for it.

391
00:31:14,260 --> 00:31:22,068
It's a... who knows [laughter].

392
00:31:22,170 --> 00:31:25,300
I'm going to call it Pip counter and...

393
00:31:25,300 --> 00:31:29,611
[Silence]

394
00:31:29,740 --> 00:31:36,240
This is a silly thing I do, and I may as
well do it on camera, (the world will laugh),

395
00:31:36,340 --> 00:31:40,982
so when I have a terrible name
for a thing, I just put a ##bob.

396
00:31:41,050 --> 00:31:45,100
I was given the clean code
thing when I started programming.

397
00:31:45,100 --> 00:31:48,994
And it has this amazing thing about
how you should not name your methods.

398
00:31:49,005 --> 00:31:53,154
Things like holy hand grenade
for destroy, and silly things like that,

399
00:31:53,154 --> 00:31:59,680
so I always put a bob when I have
bad naming thing, and I usually have fun

400
00:31:59,720 --> 00:32:02,971
figuring out the interface
when I'm finishing off an object.

401
00:32:03,000 --> 00:32:06,468
So let's say it's pip_count, for now.

402
00:32:06,480 --> 00:32:08,057
TS: OK.

403
00:32:08,510 --> 00:32:10,297
So what does my pip_count do,

404
00:32:10,605 --> 00:32:12,422
Hey, we can write a test!

405
00:32:14,170 --> 00:32:17,428
That is going to do that for me.

406
00:32:17,428 --> 00:32:19,474
So if I have a pip_count...

407
00:32:22,850 --> 00:32:27,074
now whether that should be
in the public interface is debatable.

408
00:32:27,080 --> 00:32:28,388
TS: Right.

409
00:32:28,420 --> 00:32:33,131
CB: But I'm just going to keep it there
for now. As I don't yet know where we're going.

410
00:32:33,140 --> 00:32:43,074
If I have a pip_count and I am parsing exactly
that hand then this is exactly the thing I want.

411
00:32:46,020 --> 00:32:49,257
I'm going to stop returning that.

412
00:32:51,220 --> 00:32:52,171
There we go...

413
00:32:52,170 --> 00:32:56,891
That should fail quite loudly,
let's run this test.

414
00:32:57,440 --> 00:32:58,800
There we go...

415
00:32:59,000 --> 00:33:00,450
Yes, we've got nil, excellent.

416
00:33:00,740 --> 00:33:04,422
So how are we going
implement this.  I have my cards

417
00:33:04,510 --> 00:33:08,342
And for each of those cards I have Pips.

418
00:33:08,480 --> 00:33:11,920
I can just...

419
00:33:13,080 --> 00:33:15,954
Suddenly here I have an array of numbers,

420
00:33:15,950 --> 00:33:22,337
[Camille ponders]

421
00:33:23,710 --> 00:33:31,314
For a thing like this I need my documentation,
because I don't remember everything.

422
00:33:32,720 --> 00:33:36,902
There is a Ruby collect on Ruby array.

423
00:33:38,540 --> 00:33:44,434
This is dash... It's a documentation tool
that I like to use.

424
00:33:45,050 --> 00:33:48,370
TS: So you have all of the
Ruby API documentation.

425
00:33:49,710 --> 00:33:55,680
CB: This is just a quick reminder for me
because I reckon this has already been solved.

426
00:33:57,120 --> 00:34:00,750
But maybe not, who knows.

427
00:34:00,850 --> 00:34:07,085
Essentially I want to loop over my array
and count the number of incidences of each 'thing'.

428
00:34:07,310 --> 00:34:15,860
Which actually I could do
in any number of ways.

429
00:34:16,450 --> 00:34:19,668
I can't remember off the top of my
head how I would do that in pure Ruby.

430
00:34:19,660 --> 00:34:24,480
Any suggestions welcome,
before I re-invent the wheel!

431
00:34:24,510 --> 00:34:28,662
TS: I don't know that there is a
method in the array that does that.

432
00:34:28,680 --> 00:34:33,028
the only thing that comes to mind is a
group_by method, which won't do what you want

433
00:34:33,028 --> 00:34:39,840
but will do a related thing, which is group
together all of the 5s, all of the 6s and all of the 7s,

434
00:34:39,880 --> 00:34:41,850
but that doesn't give you what you want.

435
00:34:41,850 --> 00:34:44,170
CB: Does that give me an
array of arrays then?

436
00:34:44,170 --> 00:34:47,588
TS: It gives you a hash.

437
00:34:47,800 --> 00:34:52,651
The key in the hash would be 5
and the elements in the array would be

438
00:34:52,662 --> 00:34:54,845
all of the 5 Pip cards that it had found.

439
00:34:54,857 --> 00:34:57,474
and then the key would be 6
and the value would be...

440
00:34:57,480 --> 00:35:02,194
CB: I could map on that quite easily.

441
00:35:02,220 --> 00:35:05,960
Let's do a group_by
and see how that works.

442
00:35:10,845 --> 00:35:12,400
So group_by...

443
00:35:12,400 --> 00:35:13,725
[Camille ponders]

444
00:35:18,830 --> 00:35:20,160
TS: Does it not exist?

445
00:35:20,200 --> 00:35:21,790
CB: It's not in Array.

446
00:35:21,820 --> 00:35:24,297
TS: It will be in Enumerable I expect.

447
00:35:24,290 --> 00:35:25,657
[Camille ponders]

448
00:35:27,862 --> 00:35:29,942
CB: Let's just search...

449
00:35:29,970 --> 00:35:36,262
No it's not letting me search.
I'm in the wrong scope for it.

450
00:35:39,510 --> 00:35:42,697
Enumerable group_by... no, no no.

451
00:35:43,325 --> 00:35:46,628
It's just giving me Ansible stuff.

452
00:35:46,628 --> 00:35:48,365
TS: Maybe that was a bad idea.

453
00:35:48,491 --> 00:35:49,880
CB: All of the documentation.

454
00:35:51,910 --> 00:35:53,770
TS: If you can implement it yourself.

455
00:35:53,770 --> 00:35:58,982
CB: I shall implement it in like a minute.
That should be fine, I've got all my Pips.

456
00:35:58,990 --> 00:36:03,280
What I'm wondering is,
do I want just 52617181

457
00:36:03,310 --> 00:36:09,565
or do I want all of the keys of all the
possible things and then how many cards I have.

458
00:36:09,600 --> 00:36:12,020
But I don't think it makes
a lot of difference.

459
00:36:13,340 --> 00:36:15,542
TS: It depends what you want.

460
00:36:16,994 --> 00:36:20,102
CB: I want to use group_by,
I was very excited by this.

461
00:36:20,674 --> 00:36:24,251
So... here we go...

462
00:36:24,680 --> 00:36:27,060
OK, yes fair enough.

463
00:36:27,820 --> 00:36:32,040
TS: That's not quite what you said,
but it's close.

464
00:36:32,170 --> 00:36:36,388
In that you would get the right keys but
for the values, instead of being how many

465
00:36:36,420 --> 00:36:39,211
cards there were it would be
an array of those cards.

466
00:36:39,230 --> 00:36:45,657
CB: I'm just wondering...
I basically need group_by...

467
00:36:45,714 --> 00:36:51,017
This is not particularly pretty.
It probably has a better way of doing it.

468
00:36:51,020 --> 00:36:53,565
it might be the default for that.

469
00:36:54,514 --> 00:36:58,080
Let's run the tests and
see what that returns.

470
00:36:59,340 --> 00:37:02,190
Yes, that gives me arrays.

471
00:37:02,200 --> 00:37:05,150
Now we can just have a 'thing'.

472
00:37:06,130 --> 00:37:14,514
This is my grouped_cards,
and then I can say grouped_cards

473
00:37:15,000 --> 00:37:19,160
and then for each of my things,
I can say...

474
00:37:19,160 --> 00:37:24,177
[typing]

475
00:37:25,170 --> 00:37:26,822
TS: Ah! OK,

476
00:37:27,220 --> 00:37:31,782
So you are turning each of those
arrays into a number by counting it.

477
00:37:31,800 --> 00:37:34,708
CB: Yes so let's see how that works.

478
00:37:34,720 --> 00:37:42,422
It's not very elegant but it should make
the test pass... so that's close enough.

479
00:37:43,462 --> 00:37:46,594
We still have a failure
because we're not ranking stuff.

480
00:37:50,220 --> 00:37:55,177
We are in the magical world
where only 2 rankings exists.

481
00:37:55,188 --> 00:37:58,194
There is Pair and high card.

482
00:37:58,190 --> 00:37:59,645
TS: Right.

483
00:38:00,880 --> 00:38:06,891
If these are all my grouped
cards, and if I have 'anywhere',

484
00:38:09,250 --> 00:38:18,948
in the number of group cards I have a 2,
then it's a win, and otherwise it's not.

485
00:38:20,200 --> 00:38:25,405
This is my minimal viable code,
it's something along the lines of...

486
00:38:26,850 --> 00:38:29,520
so this should return...

487
00:38:29,720 --> 00:38:37,462
I have a rank of type Pair,
otherwise I have a rank of type highest.

488
00:38:37,474 --> 00:38:40,182
I'm not quite sure about line 10 now.

489
00:38:42,510 --> 00:38:45,257
So I have all the values,
I need to find...

490
00:38:45,250 --> 00:38:46,422
[Camille types]

491
00:38:53,110 --> 00:38:55,520
I think this is where tests help me.

492
00:38:55,554 --> 00:38:58,280
TS: Yes [laughter].

493
00:39:00,200 --> 00:39:05,954
CB: Undefined local variable
grouped_cards. I've done something silly.

494
00:39:06,130 --> 00:39:10,525
Of course... this is called Pip count.

495
00:39:11,485 --> 00:39:13,451
Right, let's try that again.

496
00:39:14,680 --> 00:39:17,640
So it does something,
and for the sake of completeness

497
00:39:17,680 --> 00:39:26,148
I also want to start using
better names now.

498
00:39:29,010 --> 00:39:31,782
Here I have a hand with just a Pair.

499
00:39:32,020 --> 00:39:36,160
and here I will have
a hand with nothing in it,

500
00:39:36,370 --> 00:39:39,790
which I will call 'highest', as a type.

501
00:39:42,850 --> 00:39:48,434
So if I have a highest hand, I essentially
want it to be pretty much this,

502
00:39:48,740 --> 00:39:55,257
but I'm just going to put something in
there, which as you see actually is a straight.

503
00:39:55,420 --> 00:39:57,794
This shouldn't be ranking as highest,
but...

504
00:39:57,810 --> 00:39:59,500
TS: Does that matter at this point?

505
00:40:00,030 --> 00:40:02,640
CB: No I'm quite happy about that.

506
00:40:03,910 --> 00:40:10,594
It's fine, it's just setting the scope
of the problem to solving a very small 'thing'.

507
00:40:10,620 --> 00:40:15,017
TS: Yes, you said before, you're
imagining a smaller version of Poker

508
00:40:15,017 --> 00:40:18,400
that only has 5 cards right?

509
00:40:18,450 --> 00:40:22,100
CB: Yes, a simpler and more boring world.

510
00:40:24,480 --> 00:40:25,910
And now we have no failures.

511
00:40:25,931 --> 00:40:31,782
I have a way of getting arrays
and then suddenly I have 'one pair',

512
00:40:31,782 --> 00:40:38,537
'one thing with a pair' and 'another with
nothing' and it does rankings.

513
00:40:38,740 --> 00:40:42,857
So now we have some kind of
way, in an oversimplified game of Poker

514
00:40:42,970 --> 00:40:46,480
to say I have a Pair and I have a highest.

515
00:40:49,770 --> 00:40:56,285
So what I would really like to do
is start implementing a few more things.

516
00:40:56,570 --> 00:41:01,074
So I think the super easy way to
go is we're not going to do just Pairs

517
00:41:01,170 --> 00:41:05,588
but we're going to find 3 of a kind, and 4 of
a kind and make sure the right thing comes out,

518
00:41:05,600 --> 00:41:12,628
and by that I mean,
if I create a 3 of a kind,

519
00:41:13,291 --> 00:41:15,805
let's call it a three_of_a_kind_hand.

520
00:41:19,220 --> 00:41:23,170
So if we have a three_of_a_kind_hand, it's
going to be...

521
00:41:25,770 --> 00:41:29,840
I need 5 of Hearts, Diamonds and Spades.

522
00:41:30,280 --> 00:41:34,891
and that at the moment it's
going to return a Pair, I presume.

523
00:41:34,970 --> 00:41:40,228
but actually we want it to
return 3 of a kind, so this should be...

524
00:41:42,594 --> 00:41:44,925
If I have a rank there should be
a type three.

525
00:41:45,000 --> 00:41:48,011
So if I start running this file now....

526
00:41:49,200 --> 00:41:51,050
Not like this,

527
00:41:51,220 --> 00:41:52,770
and not like this either.

528
00:41:52,800 --> 00:41:56,040
I think I'm doing something wrong...
There we go.

529
00:41:56,310 --> 00:42:03,314
I do have a failure because it is assuming
I have type :highest and not type :three.

530
00:42:03,510 --> 00:42:08,057
because I am matching for
exactly 2, and obviously it's 3.

531
00:42:08,110 --> 00:42:12,285
This might make my life a bit
easier because I don't need to make sure

532
00:42:12,310 --> 00:42:17,040
that I'm doing things in the right
order, for that specific comparison.

533
00:42:17,080 --> 00:42:22,045
I reckon it does matter for other things
but, let's get to that when we get to that.

534
00:42:24,890 --> 00:42:27,600
I'm starting to write some
pretty terrible code now.

535
00:42:29,210 --> 00:42:32,331
Shameless green is...

536
00:42:34,480 --> 00:42:39,290
so if I have 3 then
it becomes :three_of_a_kind

537
00:42:40,830 --> 00:42:51,817
and if I have 4 then
suddenly it becomes :four_of_a_kind.

538
00:42:54,480 --> 00:42:56,468
But that is pretty bad.

539
00:42:58,800 --> 00:43:03,710
I'm just going to check that
my tests do pass nicely.

540
00:43:03,940 --> 00:43:09,851
And as they don't... it is :three_of_a_kind
and this is 3, so this should now pass.

541
00:43:10,590 --> 00:43:13,130
This now knows what a 3 of a kind is.

542
00:43:14,030 --> 00:43:19,954
I could write a quick 4 of a kind
that we haven't covered for the future

543
00:43:19,950 --> 00:43:21,794
where we're going to be
adding more things.

544
00:43:21,817 --> 00:43:25,260
I want to make sure that
I'm not breaking things.

545
00:43:29,000 --> 00:43:33,970
let's just create some test
data with a four_of_a_kind_hand.

546
00:43:34,370 --> 00:43:42,765
This is terribly verbose, but we should
have here 5 of Clubs and that should pass.

547
00:43:45,340 --> 00:43:46,960
This is working out fine.

548
00:43:47,060 --> 00:43:55,074
This however, looks pretty terrible. So
there must be a smarter way of doing this.

549
00:43:56,680 --> 00:44:02,777
I could jump in right there and try to do some
kind of look at the Pip count and the values

550
00:44:02,920 --> 00:44:06,090
and then if it's 2 it's a Pair,
3 of a kind, 4 four of a kind.

551
00:44:06,280 --> 00:44:11,634
What I'm thinking now is that it
matters about things along the lines of,

552
00:44:14,240 --> 00:44:19,634
for example I'm going to take a
problematic example of the full house,

553
00:44:19,668 --> 00:44:22,891
where at the moment my code
would give me back a 3 of a kind.

554
00:44:23,080 --> 00:44:27,051
I definitely don't want it to
say that. I want it to be a full house.

555
00:44:27,110 --> 00:44:34,617
What I want to avoid now is making
an abstraction on this logic of Pip counts

556
00:44:34,880 --> 00:44:41,870
when actually, it's not clear to
me as to where that should live.

557
00:44:42,000 --> 00:44:45,782
What I would like to try doing
now is try implementing full house

558
00:44:45,805 --> 00:44:50,285
which has 3 of a kind,
2 of a kind in the same hand.

559
00:44:50,370 --> 00:44:57,051
Get that working and then at that point hopefully,
I will know how I want to look at those card counts.

560
00:44:57,080 --> 00:44:57,680
TS: Ok.

561
00:44:57,720 --> 00:44:58,970
CB: So I can extract that.

562
00:44:58,970 --> 00:45:05,531
I'm going to leave this horror in a tiny bit longer
until I know with more certainty where I'm heading.

563
00:45:05,640 --> 00:45:10,125
TS: So even though you're unhappy with your
code you're going to hold off from refactoring it

564
00:45:10,140 --> 00:45:15,051
because you're not confident
that your solution to it is complete yet.

565
00:45:15,074 --> 00:45:19,577
You don't want to introduce
an abstraction that won't fit.

566
00:45:19,580 --> 00:45:23,017
You're worried that if you extract
it at this point, then you will end up

567
00:45:23,028 --> 00:45:25,620
with something that won't
support full house.

568
00:45:25,680 --> 00:45:26,660
CB: Yes, absolutely.

569
00:45:27,140 --> 00:45:33,771
My initial premature abstraction is I just
map the number of pip count values to a type.

570
00:45:34,080 --> 00:45:38,230
and I can sense that that's
going to fail when I get to full house.

571
00:45:39,120 --> 00:45:44,342
I want to see how I will implement full house,
which is going to create more cruft in this code.

572
00:45:44,380 --> 00:45:47,805
but I think it would help
me finding the right abstraction.

573
00:45:47,850 --> 00:45:50,731
I think there is such a
thing as premature abstraction,

574
00:45:50,742 --> 00:45:54,020
I find myself guilty of it a lot of times.

575
00:45:59,930 --> 00:46:04,510
CB: I'm going to create a quick
test for my full house hand.

576
00:46:04,940 --> 00:46:14,600
and it has 5 of Hearts, 5 of Diamonds,
5 of Spades, 6 of Clubs and 6 of Hearts.

577
00:46:14,970 --> 00:46:18,790
So we have three 5s and two 6s,
and here we go.

578
00:46:19,080 --> 00:46:25,462
This is going to fail nicely, because we haven't
implemented that yet and it's detecting a Pair.

579
00:46:26,600 --> 00:46:29,480
Which is not what we want.

580
00:46:30,925 --> 00:46:35,702
So a couple of things to start with,
the first thing is...

581
00:46:37,170 --> 00:46:38,860
Right now in my code I'm saying:

582
00:46:38,880 --> 00:46:43,170
If there's 2: let's go there. If there's
3: go there. If there's 4: go there.

583
00:46:43,540 --> 00:46:46,110
This feels counter intuitive
because in Poker,

584
00:46:46,110 --> 00:46:51,622
what I want to check is do I have a royal
flush, or a straight flush etc.

585
00:46:51,620 --> 00:46:57,302
There is an order in which you would check because
you would start (in your head) with the highest hand

586
00:46:57,570 --> 00:47:03,520
and if you don't have the best possible thing,
you would lower the expectations of your hand

587
00:47:03,565 --> 00:47:06,502
and try to get as far down as you can.

588
00:47:07,340 --> 00:47:12,777
The way I have written this code is wrong in
terms of how a human would try to solve the problem.

589
00:47:12,820 --> 00:47:15,000
I can also see it as part of a full house.

590
00:47:15,150 --> 00:47:22,731
so if we do a bit of reshuffling,
and by that I mean check things.

591
00:47:23,110 --> 00:47:31,668
(This is terrible code by the way), but check things
in a way so I start with the nicest possible outcome.

592
00:47:31,880 --> 00:47:37,050
And as I go along I get less
desirable outcomes from my hand.

593
00:47:37,280 --> 00:47:41,560
then that would have given
me a 3 of a kind, as a full house.

594
00:47:41,931 --> 00:47:46,365
Which is less wrong but
still pretty wrong!

595
00:47:46,400 --> 00:47:53,794
TS: But what you've done there is you've built
into your code because you were explaining it...

596
00:47:53,870 --> 00:47:56,240
then you were saying there is
this implied thing.

597
00:47:56,510 --> 00:48:03,097
But if you're explaining what a 3 of a kind is
there's this implication, well it's not a 4 of a kind

598
00:48:03,220 --> 00:48:06,274
a Pair is not a 4 of a kind,
nor a 3 of a kind,

599
00:48:06,297 --> 00:48:10,354
and so it seems now your
code more accurately reflects that.

600
00:48:10,370 --> 00:48:15,190
Whereas before it was
just working what by accident?

601
00:48:15,420 --> 00:48:21,691
CB: It was working only in the case where
a specific hand only has for example,

602
00:48:21,720 --> 00:48:23,405
only 3 of a kind and nothing else.

603
00:48:23,417 --> 00:48:26,620
TS: I see, it's the full house
that's going to bring this out.

604
00:48:26,770 --> 00:48:31,988
CB: The full house is bringing this out and I think
that other hands are going to bring this out anyway

605
00:48:32,110 --> 00:48:35,770
because if you have a flush that
also happens to have a Pair in there

606
00:48:35,770 --> 00:48:39,200
you want to check flush first,
it doesn't matter if you have a Pair.

607
00:48:42,080 --> 00:48:46,850
In the case of a full house,
terrible code would go along the lines of

608
00:48:46,940 --> 00:48:51,760
if I happen to have 3 in my pip
count values then two things can happen.

609
00:48:51,820 --> 00:48:59,542
Either I have also in my pip count a value that
is 2, so I have a 3 and a 2 and therefore a full house.

610
00:48:59,650 --> 00:49:04,628
Otherwise, the best thing I do have
is 3 of a kind.

611
00:49:05,850 --> 00:49:11,640
So that would make my test
pass, but it's beginning to look terrible

612
00:49:11,740 --> 00:49:15,600
First let's check that I didn't
get this one wrong.

613
00:49:15,714 --> 00:49:19,590
So now that passes nicely and
this looks awful!

614
00:49:26,600 --> 00:49:30,440
I believe there's a problem in
how I'm testing those.

615
00:49:32,920 --> 00:49:34,660
TS: What's the problem?

616
00:49:34,800 --> 00:49:39,120
CB: I'm checking that an
array includes a certain number.

617
00:49:39,250 --> 00:49:45,771
and what I want to know is does my array,
in the case of 4 of a kind it includes 4, for sure.

618
00:49:45,931 --> 00:49:47,600
and I don't need to look at the rest.

619
00:49:47,600 --> 00:49:53,120
But in the others there are a
number of things that we want to look at.

620
00:49:57,080 --> 00:49:59,990
What I want to try doing is...

621
00:50:03,620 --> 00:50:07,394
TS: It sounds like you're
switching into refactoring. CB: Yes.

622
00:50:07,640 --> 00:50:09,931
TS: Why have you chosen this point?

623
00:50:09,950 --> 00:50:14,514
Because you said there are some other
hands that you haven't implemented yet.

624
00:50:14,600 --> 00:50:18,674
Do you feel that you have come to a point
now where you have sufficient confidence

625
00:50:18,685 --> 00:50:21,710
in your implementation
so far to start refactoring it?

626
00:50:21,710 --> 00:50:25,220
CB: I think I have sufficient
confidence to start thinking about it.

627
00:50:25,220 --> 00:50:29,382
But I might hit a mental
block in a few seconds [laughter].

628
00:50:29,382 --> 00:50:32,388
I want to see how the
other hands are going to work out.

629
00:50:32,388 --> 00:50:34,380
TS: I see, alright.

630
00:50:38,080 --> 00:50:42,171
CB: All my other hands are
along the lines of straight and flush,

631
00:50:42,171 --> 00:50:45,371
and we can assume that's already
out of the way.

632
00:50:45,370 --> 00:50:48,491
By the time the code will hit
those and now we're counting the cards

633
00:50:48,491 --> 00:50:52,171
we've already excluded
a couple of those things.

634
00:50:54,680 --> 00:50:56,430
I still don't like this.

635
00:50:56,480 --> 00:51:02,902
I don't like entering this type of code because
if 4 of a kind is better than a flush, for example.

636
00:51:02,925 --> 00:51:05,360
So I want to look at those things later.

637
00:51:06,220 --> 00:51:11,577
I am starting to imagine
that I am creating as I go along,

638
00:51:11,570 --> 00:51:13,737
this is a list of all the
things you can do in Poker.

639
00:51:13,782 --> 00:51:18,605
and this is how well they rank
in the world of poker.

640
00:51:18,710 --> 00:51:25,085
The highest and the lowest ranking
And a straight flush is as high as it gets.

641
00:51:31,310 --> 00:51:41,325
What I am creating in my head is some kind of
thing along the lines of a thing called Poker ranks

642
00:51:41,620 --> 00:51:44,640
which is something along the lines of...

643
00:51:45,680 --> 00:51:49,700
The most desirable 'thing'
is a straight flush.

644
00:51:50,680 --> 00:51:52,030
Let's give that a rating of...

645
00:51:52,040 --> 00:51:54,731
I don't know how many different
types of cards there are in Poker.

646
00:51:54,730 --> 00:51:57,554
Let's say 10, but I think that's wrong.

647
00:51:57,550 --> 00:52:05,165
and then we have a 4 of a kind and that
would be a rating 9, and then so on and so forth.

648
00:52:06,220 --> 00:52:11,645
And then each of those can have a
method that checks the card is what it is.

649
00:52:11,710 --> 00:52:16,891
But that would re-use quite a lot
of code and I'm not happy about that either.

650
00:52:16,891 --> 00:52:19,131
So, let's not do that.

651
00:52:19,130 --> 00:52:23,862
TS: OK, so you're talking about
having some sort of scoring system.

652
00:52:24,110 --> 00:52:26,940
What was your motivation for
wanting to score them?

653
00:52:30,170 --> 00:52:33,680
CB: I'm motivated to have
some defined order

654
00:52:33,680 --> 00:52:39,200
which looks for the best
and worst possible outcomes

655
00:52:39,340 --> 00:52:43,700
other than it checks for them
in a different order in the code.

656
00:52:44,050 --> 00:52:46,020
TS: So you want to make that more explicit

657
00:52:46,020 --> 00:52:50,091
rather than writing a method that
looks like you could do it in any order.

658
00:52:50,091 --> 00:52:51,177
CB: Yes.

659
00:53:03,450 --> 00:53:07,820
I'm going to start doing a tiny bit
of extract method, for my own sanity.

660
00:53:18,310 --> 00:53:20,502
Just so I can see where things are going.

661
00:53:20,514 --> 00:53:22,020
This is all going to be private.

662
00:53:22,940 --> 00:53:27,320
I'm going to quickly go through those...

663
00:53:27,320 --> 00:53:32,594
[Silence]

664
00:53:32,605 --> 00:53:33,942
That was a bit odd...

665
00:53:35,897 --> 00:53:36,537
There we go.

666
00:53:36,600 --> 00:53:44,068
Now we are assuming that we have those
magical methods: has_four, has_three, has_two.

667
00:53:44,170 --> 00:53:50,217
And checks whether there is a Pair
or a 3 or a combination of 4 in there.

668
00:53:50,400 --> 00:53:52,720
Which doesn't mean it's a three of a kind.

669
00:53:52,770 --> 00:53:57,290
it means there happens to be
3 cards of the same kind in there.

670
00:53:57,420 --> 00:54:03,337
So if we have has_four, then this
is still include(4) and in much the same way

671
00:54:03,337 --> 00:54:10,034
let's assume I have has_three and has_two
and that's going to be what you think.

672
00:54:10,340 --> 00:54:13,337
and that's a bit verbose but
I'm not so bothered about that

673
00:54:13,371 --> 00:54:16,710
because it's hidden away in private
methods and I can get round to it later

674
00:54:17,020 --> 00:54:20,430
if I feel it is necessary.

675
00:54:20,570 --> 00:54:22,980
This feels more readable to me.

676
00:54:23,300 --> 00:54:29,200
It feels like the 4 of a kind
type has the has_four check.

677
00:54:29,200 --> 00:54:32,740
And for the full house, this needs
to be true and this needs to be true.

678
00:54:32,880 --> 00:54:37,588
3 of a kind check this only needs
to be true. Pair has_pair needs to be true.

679
00:54:37,620 --> 00:54:43,965
So suddenly I have all my cards. All
of the types of things I can do in Poker.

680
00:54:44,050 --> 00:54:49,714
and I have a combination of methods that
can tell me exactly why that would be.

681
00:54:50,140 --> 00:54:52,080
So the easy way of doing it would be:

682
00:54:54,330 --> 00:54:58,377
If has_four then that.
This is still verbose.

683
00:54:59,390 --> 00:55:02,857
I start refactoring and then usually
I add a lot of stuff, make it very explicit

684
00:55:02,857 --> 00:55:05,337
then start compressing later.

685
00:55:06,000 --> 00:55:08,765
So elsif full_house.

686
00:55:10,110 --> 00:55:13,360
Then :type => :full_house.

687
00:55:13,420 --> 00:55:21,394
Elsif has_three then... 3 of
a kind, elsif has_pair, then Pair.

688
00:55:21,680 --> 00:55:24,274
I'm going to have to implement
full house quickly.

689
00:55:27,020 --> 00:55:31,760
Missing a def here.
Here we go, it's has_three and...

690
00:55:33,680 --> 00:55:35,710
Maybe not multiply these [laughter].

691
00:55:37,050 --> 00:55:40,457
I don't know what that does
actually, if you multiply two methods.

692
00:55:40,502 --> 00:55:42,600
It complains loudly but I don't know how.

693
00:55:43,000 --> 00:55:47,900
This feels more readable.
TS: Does it work?

694
00:55:48,050 --> 00:55:52,570
CB: That's what I would like to check!
[Laughter]

695
00:55:52,571 --> 00:55:54,490
No it absolutely doesn't.

696
00:55:55,820 --> 00:55:59,910
That's because question marks are nice

697
00:55:59,960 --> 00:56:03,990
[Camille ponders]

698
00:56:04,091 --> 00:56:07,020
It's maybe not the day to invent
new methods in Ruby.

699
00:56:07,020 --> 00:56:17,931
Undefined local variable or method
has_pair simply because I called it has_two.

700
00:56:18,170 --> 00:56:19,390
Let's keep it that way.

701
00:56:22,630 --> 00:56:24,068
Go...

702
00:56:24,170 --> 00:56:29,005
And now we're back in action,
this is more readable.

703
00:56:29,050 --> 00:56:30,680
We're checking things in order.

704
00:56:30,937 --> 00:56:34,628
There is a better way of doing that
but let's wait until I have a couple more hands

705
00:56:34,640 --> 00:56:36,845
and I can drive out something
a bit better.

706
00:56:36,845 --> 00:56:40,491
I had an idea with a ranking
but I'm not quite happy with it yet.

707
00:56:40,502 --> 00:56:41,360
TS: Ok.

708
00:56:41,360 --> 00:56:45,577
CB: So, what are our next hands?

709
00:56:45,620 --> 00:56:48,510
Do you have a favorite
hand that you want to implement next?

710
00:56:48,510 --> 00:56:51,817
TS: Well I don't want to prejudice
you. What's your favorite hand?

711
00:56:51,850 --> 00:56:52,880
CB: A straight flush.

712
00:56:52,880 --> 00:56:54,250
TS: Then go with that.

713
00:56:57,800 --> 00:56:59,270
CB: We'll have a straight flush.

714
00:56:59,280 --> 00:57:03,930
TS: Seems a bit optimistic as you
don't have straights or flushes yet

715
00:57:04,150 --> 00:57:05,280
but if you want to yes.

716
00:57:05,280 --> 00:57:09,120
I think that's going to
drive out the changes quickly.

717
00:57:09,280 --> 00:57:12,010
But yes you're right,
may be a bit optimistic.

718
00:57:14,685 --> 00:57:18,420
In much the same way that full
house is a has_two and has_three situation.

719
00:57:18,422 --> 00:57:21,740
a straight flush is a straight
and is a flush.

720
00:57:21,748 --> 00:57:24,777
TS: Is straight or flush easier to do?

721
00:57:27,220 --> 00:57:28,754
I reckon flush.

722
00:57:28,765 --> 00:57:30,170
TS: Why don't we do flush then.

723
00:57:30,170 --> 00:57:31,245
CB: Alright.

724
00:57:32,880 --> 00:57:36,960
Let's quickly create a flush hand.

725
00:57:39,680 --> 00:57:44,754
The test definition is right at
the top. This file is getting verbose.

726
00:57:46,080 --> 00:57:50,034
TS: It's a good job you've got that
hand parser otherwise it would be even worse.

727
00:57:51,450 --> 00:57:55,565
CB: I don't want to imagine what it would
look like if we had to do doubles for this.

728
00:57:57,760 --> 00:58:02,170
So flush, let's go for all Hearts.

729
00:58:02,170 --> 00:58:05,314
[Camille types]

730
00:58:06,880 --> 00:58:12,540
I'm going to give myself
a very disappointing hand.

731
00:58:12,910 --> 00:58:16,980
If you had that hand in Poker,
you would say WHY!

732
00:58:18,850 --> 00:58:23,417
So that should give me a flush and
I'm going to check that it's definitely failing.

733
00:58:24,020 --> 00:58:25,400
TS: What does it think it is?

734
00:58:27,480 --> 00:58:30,400
CB:  Oh! That's an interesting one. So...

735
00:58:32,480 --> 00:58:33,800
We have a new problem now.

736
00:58:33,805 --> 00:58:34,822
TS: What's gone wrong?

737
00:58:35,690 --> 00:58:42,617
CB: Well, 10, it's got two numbers.
So it's not parsing it properly.

738
00:58:42,610 --> 00:58:47,760
I'm taking the first character only and in
the second I'm taking the second character only.

739
00:58:48,845 --> 00:58:50,620
There's two ways we can solve this...

740
00:58:50,620 --> 00:58:55,954
I represent 10 in another way, like zero
or something silly. I don't want to do that,

741
00:58:55,950 --> 00:59:00,845
We can just very quickly change the
parser so that it doesn't take the zero, and the one,

742
00:59:00,857 --> 00:59:02,940
and it takes something a bit smarter.

743
00:59:02,940 --> 00:59:07,314
TS: The error that's coming out there is
that because you did the fetch on the hash?

744
00:59:07,310 --> 00:59:11,062
CB: Yes, if I hadn't done a fetch on
a hash, and I had put a default value.

745
00:59:11,080 --> 00:59:16,422
Who knows what would happen
in that parser #TODO: fail loudly.

746
00:59:16,434 --> 00:59:18,034
TS: Yes, it's already paying off.

747
00:59:18,040 --> 00:59:22,731
CB: It is failing loudly, so OK...

748
00:59:22,740 --> 00:59:28,651
So here we're taking only the first
character, and here only the last character.

749
00:59:28,680 --> 00:59:32,674
What I want to do is take the last one.

750
00:59:33,211 --> 00:59:39,405
So how do I get the last char out
of a string? I can do something along the lines of:

751
00:59:39,400 --> 00:59:43,868
[Camille ponders]

752
00:59:44,020 --> 00:59:45,460
Oh! I don't even know.

753
00:59:45,510 --> 00:59:49,097
Now how I would do that,
(and I know that's incorrect),

754
00:59:53,360 --> 00:59:55,450
would be something along those lines.

755
00:59:56,340 --> 00:59:58,310
There must be a better way though.

756
00:59:58,320 --> 01:00:01,910
[Camille types]

757
01:00:02,910 --> 01:00:08,137
I know there's a way of doing it with minus
ones but I don't want to do that right now.

758
01:00:08,480 --> 01:00:10,140
I'm feeling particularly lazy.

759
01:00:11,170 --> 01:00:14,857
Here, I want to go up to cards.

760
01:00:15,230 --> 01:00:17,710
String length minus one,
take that as a string.

761
01:00:18,740 --> 01:00:23,325
I want to run the spec quickly
because I reckon I've got this wrong.

762
01:00:24,200 --> 01:00:27,714
Wrong number of arguments,
what have we done now?

763
01:00:27,710 --> 01:00:34,228
[Silence]

764
01:00:35,000 --> 01:00:37,554
This is still fetching a string.

765
01:00:38,000 --> 01:00:45,017
I will make sure I've got a test
that does the 10 might as well...

766
01:00:46,857 --> 01:00:49,920
Let's just run this file now.

767
01:00:50,000 --> 01:00:56,262
Now we have a hand parser...
line 20...length, so that's not right.

768
01:00:56,420 --> 01:01:01,005
So hand parser on
line 20 calling length on...

769
01:01:01,000 --> 01:01:05,354
[Camille ponders]

770
01:01:06,220 --> 01:01:08,380
It's an array, no.

771
01:01:10,760 --> 01:01:13,931
No it's called card string,
I would suspect that it's a string.

772
01:01:14,000 --> 01:01:18,800
So wrong number of arguments one for
zero why does it think it has an argument?

773
01:01:19,120 --> 01:01:22,297
because parentheses...

774
01:01:25,400 --> 01:01:29,420
Ah, extract method, this is terrible.

775
01:01:30,148 --> 01:01:33,668
So last number of...

776
01:01:36,310 --> 01:01:41,028
This is terrible,
I should just do it with minus ones.

777
01:01:41,080 --> 01:01:42,970
TS: How does the minus one thing work?

778
01:01:42,970 --> 01:01:46,840
CB: I believe it puts you
in an imaginary space between

779
01:01:47,050 --> 01:01:50,630
the start and end of your
array, but I might be wrong.

780
01:01:50,720 --> 01:02:00,800
So the end_of_the_card_number_index
is where I want to be.

781
01:02:01,360 --> 01:02:06,902
And here I want to go up to the
end_of_card_number_index

782
01:02:08,017 --> 01:02:12,468
[Silence]

783
01:02:12,514 --> 01:02:17,108
And here I want to go from
zero to the end card index minus one

784
01:02:17,140 --> 01:02:19,880
No, I want to go to the end of card index

785
01:02:20,560 --> 01:02:24,400
and here I want to go to this.

786
01:02:26,050 --> 01:02:27,780
So this should still fail.

787
01:02:27,782 --> 01:02:30,068
I reckon I've got something else wrong.

788
01:02:30,891 --> 01:02:32,388
TS: [Laughter] That's not very optimistic.

789
01:02:32,420 --> 01:02:34,060
CB: We have key not found.

790
01:02:34,060 --> 01:02:36,440
[Camille ponders]

791
01:02:37,880 --> 01:02:41,360
Fetch is failing again.
That's relatively good news.

792
01:02:42,050 --> 01:02:46,914
So my card string of this
is not working out.

793
01:02:46,970 --> 01:02:58,480
So this is nil because end of card
number plus one is not quite what I want it to be.

794
01:02:59,480 --> 01:03:01,737
Why is old code popping up?

795
01:03:04,430 --> 01:03:08,140
So now that it has been
determined that I am terrible at array indexing

796
01:03:09,570 --> 01:03:12,150
Let's get back to our tests.

797
01:03:12,510 --> 01:03:15,040
It's lucky that I spotted that when I did.

798
01:03:15,040 --> 01:03:18,954
[Silence]

799
01:03:19,770 --> 01:03:23,400
This is the failure which led us
to another failure.

800
01:03:23,850 --> 01:03:25,400
But this is good.

801
01:03:27,080 --> 01:03:29,000
Now, where is our flush?

802
01:03:29,490 --> 01:03:35,480
This is where I don't know Poker
quite as we'll as I would like to

803
01:03:36,080 --> 01:03:41,405
So elsif flush, type flush.

804
01:03:43,510 --> 01:03:46,260
Where does flush belong on
this sort of thing?

805
01:03:47,020 --> 01:03:52,925
It is above full house. Yes.

806
01:03:53,710 --> 01:03:55,220
TS: It doesn't actually matter.

807
01:03:55,220 --> 01:04:00,845
CB: No, that's right but it would
matter to someone who plays Poker perhaps.

808
01:04:00,840 --> 01:04:06,914
TS: At the moment you don't have any code
that compares two hands to find out which one is better.

809
01:04:06,914 --> 01:04:09,577
as long as they are correctly classified
that's OK.

810
01:04:09,577 --> 01:04:15,211
CB: Yes, so let's implement
a very quick flush.

811
01:04:18,217 --> 01:04:23,954
So what my flush is... in much the same way as
I'm doing do I have two cards of the same thing.

812
01:04:23,950 --> 01:04:28,251
I'm saying can you look at all my
suits and tell me if they're all the same.

813
01:04:28,251 --> 01:04:31,154
and that's about it.

814
01:04:31,490 --> 01:04:34,662
Much in the same way I'm doing
the pip count, I probably want something

815
01:04:34,674 --> 01:04:40,910
along the lines of a suit
count, that does this but with suits.

816
01:04:41,000 --> 01:04:51,020
And here I'm going to do the dupe
flag which means I've copy/pasted this.

817
01:04:51,620 --> 01:04:54,940
Maybe there's a better abstraction
to use here.

818
01:04:55,250 --> 01:04:57,394
So here I'm grouping it by suits.

819
01:04:59,650 --> 01:05:03,680
I'm going to write a quick test to
make sure this is doing what I think it is

820
01:05:04,740 --> 01:05:11,520
because I'm not confident enough
to reckon that it's all going to be fine.

821
01:05:11,600 --> 01:05:17,691
So in this hand I have my Pair hand
which I am using.

822
01:05:17,760 --> 01:05:21,760
It has 4 Diamonds and 1 Heart.

823
01:05:22,740 --> 01:05:28,480
So I should have Heart 1 and Diamonds 4.

824
01:05:29,200 --> 01:05:33,405
It shouldn't be the pip
count, it should be the suit count

825
01:05:33,405 --> 01:05:36,740
I believe that's what I called it. Yes.

826
01:05:39,770 --> 01:05:42,777
Now I have two failures.
This is the expected failure.

827
01:05:43,020 --> 01:05:44,650
Expected method suits.

828
01:05:46,200 --> 01:05:54,651
Not the interface I was programming
to. So this should be suit and not suits.

829
01:05:55,760 --> 01:05:56,948
TS: OK.

830
01:05:56,970 --> 01:06:02,948
CB: Now it seems to be working and we're
back to our problem: permitting flush.

831
01:06:03,000 --> 01:06:06,502
But now if I have some kind of flush count

832
01:06:06,525 --> 01:06:12,971
Oh no, suit count, then
suddenly my life is quite a lot easier.

833
01:06:12,970 --> 01:06:20,914
Because...
If I can type! [laughter]

834
01:06:20,937 --> 01:06:24,948
I can implement this... let's see...

835
01:06:25,005 --> 01:06:26,000
Now I have a flush.

836
01:06:26,000 --> 01:06:27,154
[Camille types]

837
01:06:33,828 --> 01:06:35,970
So very quickly a straight.

838
01:06:38,310 --> 01:06:44,925
This should be more interesting and more
complicated. It's not something we've done so far.

839
01:06:45,370 --> 01:06:50,571
So I have 5 of Hearts, 6 of Hearts 7,
of Hearts, 8 of Hearts and a 9 of Diamonds,

840
01:06:50,571 --> 01:06:54,430
because it's not a straight flush.

841
01:06:54,650 --> 01:06:57,140
Let's check if this is failing nicely.
Yes.

842
01:06:57,840 --> 01:07:02,308
And let's put our straight
somewhere in there.

843
01:07:08,605 --> 01:07:09,890
There we go.

844
01:07:09,920 --> 01:07:13,588
And if flush and straight
in much the same way...

845
01:07:15,680 --> 01:07:19,040
Let's have a look and see if those...

846
01:07:19,680 --> 01:07:22,410
What I care about is the straight
and not the suits.

847
01:07:22,540 --> 01:07:28,342
I'm going to look at the cards and their face
values and I need to make sure they are consecutive.

848
01:07:28,350 --> 01:07:29,680
TS: Ok.

849
01:07:30,250 --> 01:07:31,800
CB: How will I do that?

850
01:07:32,170 --> 01:07:33,120
TS: Good question.

851
01:07:34,110 --> 01:07:37,570
CB: The first thing I would
probably want to do is extract out

852
01:07:37,600 --> 01:07:40,937
of the cards array just the
array of values.

853
01:07:40,940 --> 01:07:42,811
Because this is what I care about.

854
01:07:46,000 --> 01:07:47,790
Let's see, where are our cards?

855
01:07:48,650 --> 01:07:50,120
What I want is this:

856
01:07:50,910 --> 01:07:56,200
Now I have some kind of array
that is 3567, something like that.

857
01:07:56,450 --> 01:08:01,748
In all likelihood it could be
47892 and be completely unsorted.

858
01:08:05,600 --> 01:08:16,788
So let's just sort that really
quickly... And we have sorted card values

859
01:08:17,000 --> 01:08:19,570
I don't know why I'm doing it
in a destructive way.

860
01:08:22,020 --> 01:08:25,850
I just like bangs, but that's a bit silly.

861
01:08:26,440 --> 01:08:32,000
So I have sorted card values.
I want to know if they are consecutive.

862
01:08:35,370 --> 01:08:40,560
Is there something that does that
in ruby or do I need to re-implement it?

863
01:08:40,560 --> 01:08:41,480
TS: I'm not sure.

864
01:08:41,500 --> 01:08:46,331
CB: OK, so what I care about if I'm
trying to determine if things are consecutive.

865
01:08:47,280 --> 01:08:50,920
Let's assume we live in
a world where Aces don't exist.

866
01:08:51,370 --> 01:08:51,870
TS: OK.

867
01:08:53,970 --> 01:08:57,062
CB: Because Aces...
No I don't want to go there.

868
01:08:57,080 --> 01:09:02,860
So if I have 12345 as
in Ace 2345, that's a straight.

869
01:09:03,250 --> 01:09:07,220
but I can also count Ace as the high card,
so after King.

870
01:09:08,170 --> 01:09:15,474
My initial idea was I could just have a bunch
of numbers and all I need to care about is...

871
01:09:15,720 --> 01:09:18,110
I look at the face
value on there and on there,

872
01:09:18,280 --> 01:09:23,942
they are sorted, so if the difference between
this Pair and this Pair and this Pair is always one,

873
01:09:24,220 --> 01:09:25,820
then I've won and it's a straight.

874
01:09:26,720 --> 01:09:30,160
But I can't really do that if
I'm doing Aces because

875
01:09:30,280 --> 01:09:34,470
my Ace would potentially sit on
one side or other of the array.

876
01:09:38,110 --> 01:09:41,000
Let's assume Aces are just ones for now.

877
01:09:41,910 --> 01:09:46,708
And then I'm going to make sure that I
write a test

878
01:09:46,720 --> 01:10:00,765
which is "it works with a straight with high
Ace", and it works with a straight with low ace.

879
01:10:01,000 --> 01:10:04,102
TS: Which one of those is
the special case?

880
01:10:04,170 --> 01:10:07,080
CB: It depends how I classify an Ace.

881
01:10:07,800 --> 01:10:12,651
If Ace is a one in the way I write
it then low Ace isn't my special case.

882
01:10:12,800 --> 01:10:18,617
But if I write Ace as an A for example,
which then puts it in the category of King Queen....

883
01:10:18,970 --> 01:10:22,450
which I would assign a higher point value.

884
01:10:22,750 --> 01:10:29,977
So then 10 is 10, Jack is 11,
Queen is 12, King is 13, then ace is both one and 14.

885
01:10:29,977 --> 01:10:31,337
TS: OK.

886
01:10:33,131 --> 01:10:35,640
CB: Which might be how I implement it.

887
01:10:36,090 --> 01:10:41,337
If you see an Ace in there...
look at the array and count it as a one,

888
01:10:41,348 --> 01:10:46,331
and then look at the array and
count it as 14, and see where it takes you.

889
01:10:47,820 --> 01:10:53,325
You can't really have a straight that takes
both anyway so that should sort us out nicely.

890
01:10:53,380 --> 01:10:57,840
We might be looking later at
what is my high card, on a hand,

891
01:10:57,880 --> 01:11:04,960
then that's also going to come into
play, this both 1 and 14 type of thing.

892
01:11:05,050 --> 01:11:12,114
Let's assume that we are taking Aces
as... (do I have any examples here?) No.

893
01:11:12,310 --> 01:11:17,691
So I'm going to write Aces with an A because
of just personal preference. No particular reason.

894
01:11:17,702 --> 01:11:23,820
My special case is going to be it
works with straight with a low Ace

895
01:11:32,620 --> 01:11:36,540
I've just realized something
that I had completely forgotten about.

896
01:11:38,080 --> 01:11:40,285
Right now if we look at the hand parser.

897
01:11:40,285 --> 01:11:48,354
I've chosen cards that
translate in a lovely way to integers,

898
01:11:48,354 --> 01:11:50,510
but if I do something like that....

899
01:11:52,880 --> 01:11:59,805
Let's say Queen of Diamonds.
Let's say 10 is 10 Jack is 11, Queen is 12.

900
01:12:00,140 --> 01:12:02,080
I actually would want this to happen.

901
01:12:04,570 --> 01:12:06,540
Number 12, got zero, excellent.

902
01:12:08,050 --> 01:12:13,245
Let's go back into my hand parser, this is
going to be another one of those special cases.

903
01:12:15,710 --> 01:12:19,530
So let's say Pips for heads.

904
01:12:22,110 --> 01:12:23,310
TS: What does that mean?

905
01:12:23,310 --> 01:12:32,582
CB: This is me being terrible at English
for heads I mean Jack, Queen, King, Ace.

906
01:12:32,740 --> 01:12:42,982
Let's say, if you get a Q card, then
I'm going to assign it the value 12.

907
01:12:46,510 --> 01:12:52,468
Let's start with a Jack, and that's an
11 and then I have Queen and that's 12,

908
01:12:53,200 --> 01:12:58,411
and that's a King and that's 13,
and the Ace is 14.

909
01:13:04,540 --> 01:13:07,810
So this is number of Pips.

910
01:13:08,340 --> 01:13:13,840
I'm going to put it into a different
variable because this is getting too crowded.

911
01:13:15,110 --> 01:13:18,045
Number of Pips equals this for now.

912
01:13:18,210 --> 01:13:22,605
Just to check I haven't done
something stupid. There we go.

913
01:13:22,840 --> 01:13:27,080
So expected 12, got zero, perfect, so now

914
01:13:27,080 --> 01:13:35,360
what I want is "check if the beginning
of that string is one of those special cases,

915
01:13:35,394 --> 01:13:38,120
otherwise you should just
go with face value.

916
01:13:39,600 --> 01:13:46,137
So I can have something like
Pips for heads dot fetch.

917
01:13:51,000 --> 01:13:55,897
This is what I said at the
beginning, before I specified suit.

918
01:13:56,220 --> 01:14:01,360
This is my Pips string.
And this is what it looks like.

919
01:14:01,794 --> 01:14:03,782
So what I'm going to do is...

920
01:14:05,200 --> 01:14:08,270
I take Pips for heads and
I fetch my Pips string.

921
01:14:08,270 --> 01:14:13,040
[Silence]

922
01:14:13,200 --> 01:14:19,828
So, if it's in there we can go forward
and if it's not then I want it to fail gracefully

923
01:14:20,170 --> 01:14:21,080
and do this...

924
01:14:21,110 --> 01:14:27,382
Now, the issue with that is, for example
if someone goes along the lines of

925
01:14:27,480 --> 01:14:31,177
entering a queen with a
capital Q, then that would not work.

926
01:14:31,700 --> 01:14:38,320
Because it will try to translate it into an
integer and that would not work very nicely.

927
01:14:40,780 --> 01:14:46,777
If I want to do something foolproof
I would put something along the lines of...

928
01:14:46,940 --> 01:14:50,450
"and by the way can you check
that the pip string only has digits in it",

929
01:14:50,600 --> 01:14:58,834
before I cast it to an integer. Which will save
me the pain of how do I handle Queens a bit later on.

930
01:14:59,080 --> 01:15:00,680
TS: Are you worried about that?

931
01:15:00,680 --> 01:15:02,840
CB: No. [laughter]

932
01:15:03,600 --> 01:15:06,840
If I was shipping this then yes, but no.

933
01:15:07,097 --> 01:15:15,540
So this assumes correct capitalization,

934
01:15:15,760 --> 01:15:20,600
correct letters all kinds of assumptions.

935
01:15:21,840 --> 01:15:23,085
And that's fine.

936
01:15:23,080 --> 01:15:24,940
I'm making that compromise for now

937
01:15:24,940 --> 01:15:29,510
because I don't think that's part
of the problem that I'm most interested in.

938
01:15:30,740 --> 01:15:36,422
So now we have a 'thing' and it parses queens,
12 of Diamonds and that's all working out fine.

939
01:15:36,740 --> 01:15:39,474
Now, I've got my card values.

940
01:15:39,485 --> 01:15:43,291
Let's go back to our hand spec
and see where that leaves us.

941
01:15:43,302 --> 01:15:46,525
TS:  Is your priority now
to implement ordinary straights

942
01:15:46,525 --> 01:15:50,022
or are you going straight for
the one that has an Ace in it?

943
01:15:51,200 --> 01:15:54,914
CB: I'm going with an ordinary straight.

944
01:15:54,910 --> 01:16:01,714
So my straight hand in here just
has 5,6,7,8,9, which is quite reasonable.

945
01:16:02,220 --> 01:16:04,370
I've accidentally broken things because

946
01:16:04,388 --> 01:16:08,660
my straight is broken and
tells me that everything is fine.

947
01:16:08,710 --> 01:16:10,708
But now other tests are failing.

948
01:16:11,540 --> 01:16:17,820
So I could do something like that.
TS: Now you'll only have 1 failing test!

949
01:16:18,000 --> 01:16:22,500
CB: Yes. This is a slightly
more sensible place to be in.

950
01:16:22,820 --> 01:16:29,090
I have sorted card values
and I want to look at each of the things

951
01:16:29,200 --> 01:16:32,600
They are in a sorted order and I'm going
to calculate the difference between all of them

952
01:16:33,017 --> 01:16:40,274
If at the end I am in an array
of only ones. I will be quite happy.

953
01:16:40,285 --> 01:16:40,960
TS: I see.

954
01:16:41,020 --> 01:16:45,170
CB: And if it's not then... I'm not happy.

955
01:16:45,310 --> 01:16:46,620
So far so good.

956
01:16:50,850 --> 01:16:56,582
I'm going to go for a naive implementation of
his now because I don't quite know where I'm going yet.

957
01:16:58,810 --> 01:17:03,405
I look at my card values.
Actually that's not what I want to do.

958
01:17:03,480 --> 01:17:08,548
I want to use each_with_index because
I want to know where I am in that array.

959
01:17:08,822 --> 01:17:13,611
I have my value and my index and
I am looking at my sorted card values.

960
01:17:13,645 --> 01:17:15,680
And what I want is...

961
01:17:18,670 --> 01:17:25,257
I have my card in sorted_card_values
and I want to compare it to the next card value

962
01:17:25,260 --> 01:17:28,125
So I want to compare those two values.

963
01:17:30,820 --> 01:17:32,834
And I only want to go...

964
01:17:33,620 --> 01:17:35,920
This is going to throw a very...

965
01:17:35,940 --> 01:17:41,348
reached the end of the array
situation. Which is not where I want to be.

966
01:17:48,400 --> 01:17:52,160
This is silly, I always have 5 cards,
it's a hand

967
01:17:52,200 --> 01:17:55,920
So I'm going to put
a magic number in there.

968
01:17:56,000 --> 01:17:56,525
I'm sorry.

969
01:17:56,740 --> 01:17:57,760
TS: No, no.

970
01:17:57,760 --> 01:18:01,125
[Camille types]

971
01:18:02,125 --> 01:18:05,108
CB: This is the kind of thing
where going to production

972
01:18:05,108 --> 01:18:10,520
you have a thing that defines
what 5 is somewhere.

973
01:18:10,620 --> 01:18:12,290
So magic number 4...

974
01:18:17,250 --> 01:18:21,330
OK always 5 cards per hand.

975
01:18:22,680 --> 01:18:26,811
It is reasonable for me to say,
and by the way do this 4 times.

976
01:18:33,720 --> 01:18:37,360
I need to start with an assumption
that's just wrong,

977
01:18:37,370 --> 01:18:42,125
and then I have some kind of
integer and then...

978
01:18:42,200 --> 01:18:46,800
There's got to be a better way of doing this,
but this is the first thing that comes to mind.

979
01:18:47,080 --> 01:18:53,325
So I'm looking at my sorted card value
and also at my other sorted card value.

980
01:18:54,080 --> 01:18:56,525
This is it.

981
01:18:56,620 --> 01:19:00,080
Let's try something like this...

982
01:19:01,165 --> 01:19:04,150
the zero index, and...

983
01:19:05,400 --> 01:19:06,354
TS: I see.

984
01:19:06,420 --> 01:19:09,180
CB: So these two things I want to compare.

985
01:19:09,280 --> 01:19:18,240
Just get rid of that and...  basically if I
want the absolute difference between the two.

986
01:19:18,262 --> 01:19:19,977
They are sorted, so actually

987
01:19:25,508 --> 01:19:27,325
So what I want is...

988
01:19:27,320 --> 01:19:33,720
[Camille ponders]

989
01:19:34,710 --> 01:19:37,954
So the first naive thing is...

990
01:19:40,250 --> 01:19:42,125
actually the result is...

991
01:19:43,820 --> 01:19:48,220
old result and...

992
01:19:49,220 --> 01:19:52,190
This is equals to one, so now...

993
01:19:54,960 --> 01:19:58,354
This will have to go somewhere
else because it's getting verbose.

994
01:19:58,354 --> 01:20:04,240
What this chunk of code
is doing there is saying:

995
01:20:07,220 --> 01:20:10,220
difference_between_cards.

996
01:20:11,880 --> 01:20:15,140
And different Pips on a card.

997
01:20:16,160 --> 01:20:19,108
And basically...

998
01:20:23,290 --> 01:20:24,040
Dislike.

999
01:20:27,080 --> 01:20:28,970
TS: Yes, it's getting the value of that...

1000
01:20:29,400 --> 01:20:31,920
CB: Yes, I absolutely don't like this.

1001
01:20:31,940 --> 01:20:37,850
For now use a variable before
I do something silly and unnecessary.

1002
01:20:39,931 --> 01:20:41,740
This should be the loop.

1003
01:20:43,200 --> 01:20:44,600
Let's get rid of that.

1004
01:20:45,050 --> 01:20:47,531
A slightly misguided abstraction.

1005
01:20:48,400 --> 01:20:53,725
If my difference_between_pips is one,
then I continue.

1006
01:20:53,740 --> 01:20:56,270
Actually I don't like how I'm doing this.

1007
01:20:56,605 --> 01:21:01,980
It's: while(difference_always_1)

1008
01:21:06,880 --> 01:21:12,468
So what I want to do is say
difference of one is true to start with.

1009
01:21:12,510 --> 01:21:15,977
And the second I get a difference
that is not one between the cards,

1010
01:21:15,988 --> 01:21:18,845
I exit out of the loop and
get out of there.

1011
01:21:18,880 --> 01:21:22,274
So I start with true and while it's true

1012
01:21:22,290 --> 01:21:30,742
And my index is below 4.
Or sorted_card_values.count.

1013
01:21:30,765 --> 01:21:32,091
[Camille ponders]

1014
01:21:41,234 --> 01:21:43,390
Magic number 4 that's fine.

1015
01:21:43,394 --> 01:21:46,370
OK, so while difference_always_one
we do that.

1016
01:21:48,650 --> 01:21:52,422
So if difference_between_pips is
that and difference_always_1 is...

1017
01:21:55,250 --> 01:21:58,845
And the new difference_between_pips
is one.

1018
01:21:59,851 --> 01:22:01,714
This we no longer need.

1019
01:22:02,310 --> 01:22:04,091
Those we no longer need.

1020
01:22:04,110 --> 01:22:07,680
This is called 'i' because I don't
want to rename all the variables.

1021
01:22:09,450 --> 01:22:11,020
I need to close my loops.

1022
01:22:12,370 --> 01:22:15,070
And now what I want to do is....

1023
01:22:17,880 --> 01:22:20,891
Maybe initialize that,
that seems like a good idea.

1024
01:22:24,110 --> 01:22:28,742
I start at index zero. I'm assuming
that it is going to be a straight.

1025
01:22:28,770 --> 01:22:31,748
and then I continue until
something proves me wrong.

1026
01:22:31,800 --> 01:22:38,388
So either I'm done with my
calculation or that's failed.

1027
01:22:38,400 --> 01:22:44,514
So if it's not equal to one it should
be false and then exit, and it's all quite nice.

1028
01:22:45,050 --> 01:22:47,405
So now, test time...

1029
01:22:48,365 --> 01:22:49,120
No...

1030
01:22:55,820 --> 01:22:58,250
And now the computer fails [laughter].

1031
01:22:58,510 --> 01:23:00,510
TS: It looks like it's stuck in a loop.

1032
01:23:01,880 --> 01:23:03,970
CB: Maybe because I have an infinite loop.

1033
01:23:05,800 --> 01:23:08,880
I think I haven't incremented the index...
There we go.

1034
01:23:08,880 --> 01:23:09,520
[Silence]

1035
01:23:15,250 --> 01:23:17,371
Every time, just failing.

1036
01:23:17,600 --> 01:23:21,371
This is now still failing.

1037
01:23:21,720 --> 01:23:23,954
But this is OK.

1038
01:23:23,970 --> 01:23:25,140
Still the same failure.

1039
01:23:25,970 --> 01:23:27,350
So different straight.

1040
01:23:27,680 --> 01:23:33,337
TS: When that loop finishes, how do
you know whether or not it was a straight?

1041
01:23:35,560 --> 01:23:36,360
Ah, OK.

1042
01:23:37,370 --> 01:23:38,860
CB: I'm missing a return value.

1043
01:23:42,020 --> 01:23:47,554
By the time we get there, I want, if
it's a straight to exit because of this failing.

1044
01:23:47,748 --> 01:23:50,765
And then it should return the result.

1045
01:23:50,940 --> 01:23:52,020
Which is still wrong.

1046
01:23:52,710 --> 01:23:53,820
OK, so let's have a look.

1047
01:23:56,040 --> 01:23:58,660
So I start an index here
and as I go along.

1048
01:23:58,880 --> 01:24:02,150
My difference is....

1049
01:24:02,290 --> 01:24:04,650
have I sorted them....yes.

1050
01:24:05,170 --> 01:24:08,125
I would do something naughty now...

1051
01:24:12,510 --> 01:24:16,502
print the thing out so
I know where I'm heading.

1052
01:24:16,540 --> 01:24:19,740
I've got 56789 which seems 'straightish'

1053
01:24:20,300 --> 01:24:24,845
Now let's walk through this.
So difference_always_1 is true, fine.

1054
01:24:24,940 --> 01:24:30,182
While this is true, the difference
between Pips is this minus this.

1055
01:24:30,194 --> 01:24:35,291
This should be one difference_always_1,
this is equals to one.

1056
01:24:35,290 --> 01:24:36,594
[Camille ponders]

1057
01:24:39,250 --> 01:24:41,405
Yet, this returns as false.

1058
01:24:41,400 --> 01:24:42,742
[Camille ponders]

1059
01:24:47,370 --> 01:24:53,222
I'm going to run one test,
just that one 5679.

1060
01:24:53,460 --> 01:24:58,754
I'm going to shell out a few things
because I don't know what's going on.

1061
01:24:58,765 --> 01:25:00,370
TS: It looked like it passed there.

1062
01:25:01,000 --> 01:25:04,280
CB: Yes, this is why I'm a bit confused.

1063
01:25:04,340 --> 01:25:06,280
TS: Is it a different test that's failing?

1064
01:25:06,280 --> 01:25:11,645
CB: Good point. Maybe one of
my cases is actually a straight.

1065
01:25:14,650 --> 01:25:16,360
Let's get rid of those.

1066
01:25:17,250 --> 01:25:18,970
I'm going to run this entire file...

1067
01:25:19,497 --> 01:25:20,910
And where is my failure?

1068
01:25:22,880 --> 01:25:25,737
Should be a highest and it got
a straight... Ah!

1069
01:25:26,850 --> 01:25:30,510
Oh yes, one of my test cases
is a straight.

1070
01:25:31,650 --> 01:25:37,310
I'm feeling really clever now because...

1071
01:25:37,310 --> 01:25:41,310
and it's not a flush so it's not
going to cause me sorrow at any point.

1072
01:25:43,540 --> 01:25:44,422
Yes, it's all fine.

1073
01:25:44,422 --> 01:25:45,177
TS: Great.

1074
01:25:49,200 --> 01:25:58,251
CB: I have an Ace which is a 14
but it's also a 1 when I want it to be

1075
01:25:58,400 --> 01:26:03,508
So straight hand low
Ace, still straight, same result.

1076
01:26:08,525 --> 01:26:10,950
If we do this, and we have a hand parser.

1077
01:26:13,820 --> 01:26:19,691
Actually, no we don't want to do that.
We have an Ace now, we don't want a one.

1078
01:26:21,782 --> 01:26:24,342
So we have 2345 and A.

1079
01:26:25,200 --> 01:26:25,977
TS: Ok,

1080
01:26:29,050 --> 01:26:30,310
The order doesn't matter?

1081
01:26:30,310 --> 01:26:33,520
CB: The order shouldn't matter
because I'm sorting them anyway.

1082
01:26:33,520 --> 01:26:36,468
TS: So that's going to show
up as just being a high card hand.

1083
01:26:36,480 --> 01:26:37,085
CB: Correct.

1084
01:26:37,140 --> 01:26:40,240
This is showing up as a highest,
and I want it to be a straight.

1085
01:26:40,251 --> 01:26:42,980
So let's go in there and implement that.

1086
01:26:45,420 --> 01:26:50,925
This is a method that takes sorted card
values then it can work out if it's a straight or not.

1087
01:26:51,000 --> 01:26:53,748
Now if I have an Ace in my hand,

1088
01:26:54,000 --> 01:26:58,480
I want it to work out: is this a straight
if it behaves like a 14?

1089
01:26:58,480 --> 01:27:01,720
and: is this a straight
if it behaves like a 1?

1090
01:27:01,720 --> 01:27:04,617
So what I want to do is basically...

1091
01:27:05,350 --> 01:27:09,560
If this fails when I treat my Ace
as a 14, then just do again with a 1.

1092
01:27:12,342 --> 01:27:14,730
Let's extract that method out.

1093
01:27:16,970 --> 01:27:22,080
And this takes an array of cards
and determines if they are consecutive.

1094
01:27:22,125 --> 01:27:23,880
So, consecutive cards...

1095
01:27:23,880 --> 01:27:25,051
[Camille types]

1096
01:27:36,370 --> 01:27:41,668
This says my cards are consecutive.
I don't like the fact that it's living here.

1097
01:27:43,880 --> 01:27:45,714
This is just odd.

1098
01:27:48,450 --> 01:27:55,220
If I had more time I would want
to move this to a helper somewhere.

1099
01:27:55,710 --> 01:28:01,051
This is a utility type function
which has no business being here.

1100
01:28:01,120 --> 01:28:04,251
TS: It doesn't have to be
an instance method?

1101
01:28:04,280 --> 01:28:11,268
CB: Correct. The concept of consecutive
numbers has nothing to do with the hand.

1102
01:28:11,480 --> 01:28:13,620
The hand needs it in order to rank itself.

1103
01:28:13,620 --> 01:28:17,394
But the actual implementation
should not live here.

1104
01:28:17,400 --> 01:28:18,800
TS: It could be any numbers?

1105
01:28:18,850 --> 01:28:23,931
CB: Absolutely, it could be just
some random thing, that takes an array,

1106
01:28:23,950 --> 01:28:27,497
and determines whether they
are in some sort of nice order.

1107
01:28:27,497 --> 01:28:28,548
TS: OK.

1108
01:28:31,510 --> 01:28:39,485
CB: I'm just going to check
that it is still behaving nicely.

1109
01:28:39,480 --> 01:28:43,017
So now what I want is...

1110
01:28:48,110 --> 01:28:53,725
In the case where sorted card values
include the value 14, which is the Ace,

1111
01:28:53,725 --> 01:29:00,628
I also want to change that array
and do the same thing with the 1.

1112
01:29:01,110 --> 01:29:02,770
And then check if it's a straight.

1113
01:29:03,540 --> 01:29:07,862
So let's say sorted card values.

1114
01:29:13,620 --> 01:29:17,325
I'm going to do
something naive, if it includes 14

1115
01:29:26,650 --> 01:29:33,760
This is where I want to know
what my Array lets me do.

1116
01:29:34,365 --> 01:29:37,177
Just to have a bit of drop...

1117
01:29:37,340 --> 01:29:39,690
No that's drop a certain number of things.

1118
01:29:39,740 --> 01:29:43,302
I want to delete a thing from an array.

1119
01:29:43,310 --> 01:29:47,970
That is not the array documentation.

1120
01:29:50,080 --> 01:29:54,285
I do this all the time.
I have a relatively bad memory,

1121
01:29:54,280 --> 01:29:56,610
when it comes to remembering
all the things.

1122
01:29:56,880 --> 01:30:00,502
TS: It's probably not a good
idea to try to memorize them anyway.

1123
01:30:00,540 --> 01:30:05,554
CB: Once you start programming in more
than three languages, it becomes a little difficult.

1124
01:30:08,388 --> 01:30:12,000
TS: So you're going to delete
all of the 14s from the array?

1125
01:30:12,170 --> 01:30:16,340
CB: Yes, and I need to know
how many 14s I'm deleting,

1126
01:30:16,354 --> 01:30:19,291
In order to add that exact
number of 1s on the other side.

1127
01:30:19,314 --> 01:30:23,960
Otherwise I might end up with something
crazy such as an array with only three cards

1128
01:30:23,977 --> 01:30:28,537
which will explode because it is
expecting a certain number of things in there;

1129
01:30:28,530 --> 01:30:33,097
remember my magic number in
there? It would not be a good idea.

1130
01:30:41,462 --> 01:30:45,005
Delete 14.

1131
01:30:45,005 --> 01:30:54,697
According to the Ruby
documentation this is deleted_aces.

1132
01:30:56,340 --> 01:31:01,360
This gives me back all that it's deleted.

1133
01:31:02,050 --> 01:31:03,910
TS: It returns the last deleted item?

1134
01:31:03,931 --> 01:31:07,337
CB:  Yes, but it doesn't
tell me how many, interesting.

1135
01:31:07,330 --> 01:31:08,628
[Camille ponders]

1136
01:31:11,820 --> 01:31:15,440
I want to know how many 14s I have,

1137
01:31:16,600 --> 01:31:20,750
So I want to count the number of
things that match.

1138
01:31:25,840 --> 01:31:26,891
How do I do that?

1139
01:31:31,600 --> 01:31:34,400
My implementation is this...

1140
01:31:34,400 --> 01:31:35,520
[Camille types]

1141
01:31:38,650 --> 01:31:45,737
This can go somewhere else, and be called
what it actually is which is number of Aces.

1142
01:31:46,540 --> 01:31:51,622
And if my number of Aces is bigger
than one, then I want to delete all the Aces.

1143
01:31:53,560 --> 01:31:57,910
And add two sorted card values, ones.

1144
01:31:58,080 --> 01:32:00,970
But I want to do that
exactly the number of aces times.

1145
01:32:04,220 --> 01:32:08,834
I could do it in a better way by
concatenating two sorted card values

1146
01:32:08,834 --> 01:32:15,794
in an array of exactly the
number of aces as ones.

1147
01:32:16,000 --> 01:32:21,965
But let's leave that for now and
let's check if things have gone wrong.

1148
01:32:22,200 --> 01:32:23,000
They have.

1149
01:32:25,480 --> 01:32:27,870
This is just terrible parenthesis use.

1150
01:32:30,450 --> 01:32:34,340
Because it turns out
blocks don't take round brackets.

1151
01:32:39,310 --> 01:32:43,394
It's not working but it's not
failing any more.

1152
01:32:45,680 --> 01:32:50,354
TS: Is it because your number of Aces
is equal to one not greater than one?

1153
01:32:54,420 --> 01:32:58,811
CB: Yes, and there is also
the fact that here...

1154
01:33:00,650 --> 01:33:02,540
I think it's going to fail another way.

1155
01:33:04,420 --> 01:33:05,600
And let me explain why...

1156
01:33:07,310 --> 01:33:18,537
I think what I just wrote is going to fail in the
case of high ace, because of how I've implemented it.

1157
01:33:18,770 --> 01:33:22,114
To prove my point I'm going to write...

1158
01:33:24,685 --> 01:33:26,788
There we go straight_hand_high_ace.

1159
01:33:31,850 --> 01:33:35,577
What I mean by that... and do that.

1160
01:33:36,540 --> 01:33:39,405
Undefined method `add` for array...
interesting.

1161
01:33:39,417 --> 01:33:42,160
TS: There are two failures,
on both of those Ace tests.

1162
01:33:42,220 --> 01:33:43,110
CB: Correct.

1163
01:33:44,050 --> 01:33:47,650
So this is you can't add and I expect
it's insert. Yes.

1164
01:33:53,702 --> 01:33:57,725
So now it's actually going
in the loop which is good news.

1165
01:34:01,062 --> 01:34:03,577
Undefined '-' method class.

1166
01:34:04,480 --> 01:34:06,502
Let's debug our way through this.

1167
01:34:08,148 --> 01:34:11,268
It's happening on consecutive cards.

1168
01:34:12,250 --> 01:34:16,537
And it's happening on line eighty three...
Which is here.

1169
01:34:21,420 --> 01:34:23,897
TS: What does the documentation
for insert say?

1170
01:34:25,062 --> 01:34:26,674
CB: It's not destructive is it?

1171
01:34:28,280 --> 01:34:32,697
TS: It sets the given value with the
given index so you have to provide an index.

1172
01:34:32,697 --> 01:34:34,365
CB: OK, alright, so...

1173
01:34:35,600 --> 01:34:39,250
I'm going to insert it at the
start because it doesn't really matter

1174
01:34:41,650 --> 01:34:47,520
Or I could go for the lazy option
[laughter]

1175
01:34:57,770 --> 01:34:58,800
TS: Has that fixed it?

1176
01:34:59,000 --> 01:35:02,434
CB: No, so many things going
wrong right now.

1177
01:35:05,680 --> 01:35:15,714
This is take my sorted card values and
give me other possible card values for Aces.

1178
01:35:22,640 --> 01:35:23,540
A bit premature.

1179
01:35:23,540 --> 01:35:26,411
I want to count the number of Aces and...

1180
01:35:26,510 --> 01:35:32,297
If the number of Aces is bigger
than one then I want to have...

1181
01:35:36,080 --> 01:35:39,177
Aces as ones.

1182
01:35:40,600 --> 01:35:42,620
Which is just like sorted card values.

1183
01:35:44,600 --> 01:35:46,571
I want to manipulate that.

1184
01:35:46,610 --> 01:35:49,140
TS: So you're going to leave
the original one alone?

1185
01:35:49,140 --> 01:35:51,020
CB: Correct. I don't want to touch that.

1186
01:35:51,020 --> 01:35:54,930
And then in the case of straight
I want to check

1187
01:35:55,280 --> 01:35:58,770
either it works out fine
with the usual way of doing it.

1188
01:35:59,280 --> 01:36:05,200
Or it works out with the using
Ace as ones, way of doing it.

1189
01:36:06,148 --> 01:36:08,434
So either is true.

1190
01:36:08,708 --> 01:36:15,165
If the number of Aces is none,

1191
01:36:15,600 --> 01:36:19,851
then it's the usual check
"do I have consecutive cards"?

1192
01:36:22,050 --> 01:36:24,800
Now that's going to fail nicely
in places, excellent.

1193
01:36:27,110 --> 01:36:30,102
It still doesn't work with
a straight with low ace.

1194
01:36:35,770 --> 01:36:38,510
I want to check what my
Aces as ones is like.

1195
01:36:40,480 --> 01:36:44,010
This is my best chance of
understanding what's going on.

1196
01:36:44,830 --> 01:36:49,554
So my Aces as ones looks like 123, aha!
It's not sorted

1197
01:36:49,570 --> 01:36:54,034
I'm doing my sort here and
I am doing my sort again.

1198
01:36:55,142 --> 01:37:00,990
How about... we just don't sort them here

1199
01:37:01,170 --> 01:37:04,450
TS: And then consecutive cards
is going to be in charge of that.

1200
01:37:04,537 --> 01:37:10,630
CB: I'll give it any number of cards
in any odd number called card values

1201
01:37:10,742 --> 01:37:16,045
and inside here my job is
just to sort them.

1202
01:37:17,862 --> 01:37:18,628
TS: OK.

1203
01:37:18,650 --> 01:37:22,320
And then go ahead with
the rest of the code.

1204
01:37:24,060 --> 01:37:30,228
Which I have changed variable
names so it should be less angry at me.

1205
01:37:31,440 --> 01:37:35,930
Good, straights with low Aces
and straights with high Aces.

1206
01:37:37,280 --> 01:37:43,508
TS: Ok so we are nearly out of time now,
what would you like to do to wrap this up.

1207
01:37:43,680 --> 01:37:47,691
CB: I was supposed to write a hand
comparer, and now I've written a hand ranker,

1208
01:37:47,714 --> 01:37:52,270
I'd like to try that out and
see what happens

1209
01:37:52,308 --> 01:37:54,960
TS: So ranking the hands
you've already implemented?

1210
01:37:55,000 --> 01:38:00,480
CB: Yes, there are a few hands
missing but not a lot of work left to do.

1211
01:38:03,760 --> 01:38:11,188
Let me just correct this so that
we are following the rules of poker.

1212
01:38:11,188 --> 01:38:13,180
Which might be helpful with ranker.

1213
01:38:14,540 --> 01:38:17,988
I've got a hand, it's told me what
the rank it is but if I had two cards,

1214
01:38:18,010 --> 01:38:24,308
I want to give my hand to my other
hand and say "Are you better than that hand".

1215
01:38:24,331 --> 01:38:25,097
TS: Yes.

1216
01:38:25,170 --> 01:38:32,651
In my public interface with my hand
I would like to have, is_better? than other hand.

1217
01:38:34,200 --> 01:38:36,217
TS: And it's going to return
true or false.

1218
01:38:36,217 --> 01:38:38,148
CB: Yes, exactly.

1219
01:38:38,628 --> 01:38:41,540
How about we have a very quick...

1220
01:38:42,422 --> 01:38:44,971
I will describe 'better than'.

1221
01:38:49,771 --> 01:38:51,428
We can just say...

1222
01:38:57,990 --> 01:39:01,200
It tells me if the hand is better.

1223
01:39:05,420 --> 01:39:08,742
We already have some very handy hands.

1224
01:39:10,430 --> 01:39:17,600
We know, for example, the 4 of a
kind hand should be better than full house.

1225
01:39:18,280 --> 01:39:25,782
Let's start with those, so
full_house.better_than? 4 of a kind hand.

1226
01:39:25,850 --> 01:39:30,937
So I expect all of this to be true.

1227
01:39:34,480 --> 01:39:39,577
TS: Is that the right way round.
A full house is better than 4 of a kind?

1228
01:39:39,600 --> 01:39:43,302
CB: No it's not - thank you.

1229
01:39:45,420 --> 01:39:46,740
That looks more sensible.

1230
01:39:49,940 --> 01:39:51,588
Let's run this.

1231
01:39:51,840 --> 01:39:54,171
I want to find a 'better than' for hand.

1232
01:39:54,200 --> 01:39:57,771
Oh, that's because I've
implemented it as a Poker method.

1233
01:39:59,740 --> 01:40:01,337
Let's run this...

1234
01:40:01,400 --> 01:40:03,710
and now it's getting nil, excellent.

1235
01:40:06,680 --> 01:40:11,920
So I have the rank of both hands
and I want to know which is the better.

1236
01:40:12,274 --> 01:40:16,845
This comes back to the thing
which I was thinking about an hour ago.

1237
01:40:17,450 --> 01:40:25,805
If only I'd known there was a ranking that
told me the best hand. and next possible best hand.

1238
01:40:26,400 --> 01:40:28,040
So this is what we want.

1239
01:40:28,420 --> 01:40:32,754
If we have big poker ranks...

1240
01:40:34,200 --> 01:40:39,462
and it's an array and
ordered thing for now.

1241
01:40:40,280 --> 01:40:42,320
and if we go forward and say.....

1242
01:40:43,140 --> 01:40:50,525
This is a naive implementation. So if
we have 4 of a kind, full house and straight.

1243
01:40:50,540 --> 01:40:56,110
What I could do is in
POKER_RANKS I can just get the index of rank,

1244
01:41:00,650 --> 01:41:05,474
and compare that to the
POKER_RANKS index of the other hand.

1245
01:41:05,820 --> 01:41:12,788
And that would give me a straightforward
answer for hands that, you know...

1246
01:41:12,970 --> 01:41:15,740
I'm assuming that the
index is here, I'm not really sure.

1247
01:41:18,740 --> 01:41:23,550
This is me, this is my rank,
and this is confusing.

1248
01:41:26,340 --> 01:41:29,188
TS: You're putting the worst first.

1249
01:41:29,220 --> 01:41:35,234
CB: Yes because it's a lower rank. And if it's
a high rank I want to be happier with it.

1250
01:41:35,250 --> 01:41:38,750
TS: The the question will be
is my index greater than?

1251
01:41:38,750 --> 01:41:45,817
CB: Yes and I am going to say it's strictly
greater than. I'll get back to that in a second.

1252
01:41:47,940 --> 01:41:51,450
But yes, index 1 doesn't exist obviously.

1253
01:41:52,220 --> 01:41:56,365
Let's now assume if we have
some method on the array,

1254
01:41:56,400 --> 01:42:01,085
that is find index, that's
the one I probably want... Is it?

1255
01:42:06,540 --> 01:42:12,640
Yes, it returns the index of a thing,
so just index would have worked better.

1256
01:42:13,177 --> 01:42:15,885
Let's go back here...

1257
01:42:21,570 --> 01:42:25,220
Go and define method
something for nil class, excellent.

1258
01:42:32,680 --> 01:42:35,760
This is apparently nil.

1259
01:42:36,110 --> 01:42:38,850
TS: Because it was not finding
the rank in that array?

1260
01:42:38,850 --> 01:42:39,450
CB: Correct.

1261
01:42:44,194 --> 01:42:48,445
Do I not have...
what am I comparing in my hand spec?

1262
01:42:48,510 --> 01:42:52,590
I am comparing four of a kind
and full house.

1263
01:42:55,080 --> 01:43:02,320
I'm going to print out the rank of the
other hands because I'm running out of time

1264
01:43:02,331 --> 01:43:05,588
so I don't want to spend ages
debugging this.

1265
01:43:07,610 --> 01:43:10,937
Oh of course it's a hash [laughter].

1266
01:43:13,430 --> 01:43:18,811
So I'm not comparing that.
I'm just assuming there is a type.

1267
01:43:18,822 --> 01:43:22,914
If there isn't a type then I should
be wary so I'm going to let that fail.

1268
01:43:25,520 --> 01:43:29,428
And we have no failures, so
now we can compare two hands.

1269
01:43:30,102 --> 01:43:34,765
There is a tiny bit of work left.
There's a few hands I haven't implemented.

1270
01:43:34,940 --> 01:43:36,970
And there's a bit of work left
in terms of...

1271
01:43:37,497 --> 01:43:41,050
well, we should probably
have all the rankings in nice order.

1272
01:43:41,250 --> 01:43:49,062
There's an obvious refactoring step which is,
well, now I have a list of things that rank things

1273
01:43:49,291 --> 01:43:56,571
and then my rank method is executing
and checking for things in a certain order.

1274
01:43:56,740 --> 01:43:59,510
The order that I'm defining
in this POKER_RANKS array

1275
01:43:59,565 --> 01:44:03,062
Is the exact same one which
I want to be ranking those cards.

1276
01:44:03,200 --> 01:44:05,830
So I should be doing something
really clever here.

1277
01:44:06,342 --> 01:44:10,710
The big piece of functionality
that's missing is...

1278
01:44:11,588 --> 01:44:14,760
If I have two straights,
how do I know who has one?

1279
01:44:14,850 --> 01:44:21,005
And this is why I'm returning this rank
as type something because I had in mind,

1280
01:44:21,010 --> 01:44:27,977
I don't only care about the type of hand.
I also care about the highest card in that hand.

1281
01:44:28,340 --> 01:44:34,708
For a straight, for example, I
would get the highest card in that hand.

1282
01:44:34,740 --> 01:44:42,411
With the mix of Ace should be counted as
1 or 14 depending on the kind of straight that I have.

1283
01:44:42,411 --> 01:44:45,348
And I would return that as
the type of rank.

1284
01:44:45,370 --> 01:44:48,740
And if my rank method gives
me back not just the type of my hand

1285
01:44:48,940 --> 01:44:57,245
but also the highest possible tie breaker in
some hands but in others it's different things,

1286
01:44:57,257 --> 01:45:01,428
then I can definitely determine
if my hand has won or not.

1287
01:45:01,450 --> 01:45:02,520
TS: Ok, great.

1288
01:45:02,620 --> 01:45:05,400
Well I think that would be
a good place to wrap it up.

1289
01:45:05,740 --> 01:45:08,148
Thank you very much for
showing us this today.

1290
01:45:08,148 --> 01:45:11,560
It's been fascinating watching
you work. So again, thank you very much.

1291
01:45:11,565 --> 01:45:12,400
CB: Thanks.

1292
01:45:12,400 --> 01:45:18,000
Captions produced by Bonnie Roworth
